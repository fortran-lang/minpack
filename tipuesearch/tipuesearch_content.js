var tipuesearch = {"pages":[{"title":" minpack ","text":"minpack Modernized Minpack Description Minpack includes software for solving nonlinear equations and\nnonlinear least squares problems.  Five algorithmic paths each include\na core subroutine and an easy-to-use driver.  The algorithms proceed\neither from an analytic specification of the Jacobian matrix or\ndirectly from the problem functions.  The paths include facilities for\nsystems of equations with a banded Jacobian matrix, for least squares\nproblems with a large amount of data, and for checking the consistency\nof the Jacobian matrix with the functions. This version is a modernization of the original Fortran 77 code. This is a work in progress. Modifications include:\n* Conversion from fixed ( .f ) to free-form ( .f90 ) source.\n* Modified the tests so they can be automatically run in the CI Further updates are planned... Decision trees Decision tree for systems of nonlinear equations flowchart TB\n    start[Is the Jacobian matrix available?]\n    start--Yes-->middle1[Is flexibility required?]\n    start--No-->middle2[Is flexibility required?]\n    middle1--Yes-->b1[ <a href= 'https://fortran-lang.github.io/minpack/proc/hybrj.html' > hybrj </a> ]\n    middle1--No-->b2[ <a href= 'https://fortran-lang.github.io/minpack/proc/hybrj1.html' > hybrj1 </a> ]\n    middle2--Yes-->b3[ <a href= 'https://fortran-lang.github.io/minpack/proc/hybrd.html' > hybrd </a> ]\n    middle2--No-->b4[ <a href= 'https://fortran-lang.github.io/minpack/proc/hybrd1.html' > hybrd1 </a> ] Decision tree for nonlinear least squares problems flowchart TB\n    start[Is the Jacobian matrix available?]\n    start--Yes-->m1[Is storage limited?]\n    start--No-->m2[Is flexibility required?]\n    m1--Yes-->ml1[Is flexibility required?]\n    m1--No-->ml2[Is flexibility required?]\n    ml1--Yes-->b1[ <a href= 'https://fortran-lang.github.io/minpack/proc/lmstr.html' > lmstr < /a/>]\n    ml1--No-->b2[ <a href= 'https://fortran-lang.github.io/minpack/proc/lmstr1.html' > lmstr1 < /a/>]\n    ml2--Yes-->b3[ <a href= 'https://fortran-lang.github.io/minpack/proc/lmder.html' > lmder < /a/>]\n    ml2--No-->b4[ <a href= 'https://fortran-lang.github.io/minpack/proc/lmder1.html' > lmder1 < /a/>]\n    m2--Yes-->mr1[ <a href= 'https://fortran-lang.github.io/minpack/proc/lmdif.html' > lmdif < /a/>]\n    m2--No-->mr2[ <a href= 'https://fortran-lang.github.io/minpack/proc/lmdif1.html' > lmdif1 < /a/>] Documentation The API documentation for the latest default branch can be found here .  This is generated by processing the source files with FORD . License The Minpack source code and related files and documentation are distributed under a permissive free software license (BSD-style). History Minpack has been developed in 1980 by Jorge J. Moré, Burton S. Garbow, Kenneth\nE.  Hillstrom and other contributors as listed on page 8 of the User Guide for\nMINPACK-1 . Since 2012 Ondřej Čertík has maintained a GitHub repository for minpack with\nmany contributions from Carlos Une and Zuo Zhihua. In 2021 Jacob Williams started a new minpack repository at GitHub and\ntranslated all files from fixed form to free form and other modernizations. We have discussed at https://github.com/fortran-lang/minpack/issues/8 which\nversion to use as the community maintained fortran-lang version and decided to\nuse the latter repository, which became the fortran-lang version. We have\nbeen porting improvements from the former repository over to the new fortran-lang repository. Contributors Many people have contributed to Minpack over the years: Jorge J. Moré, Burton S. Garbow, Kenneth E.  Hillstrom and other contributors\n  as listed on page 8 of the User Guide for MINPACK-1 . Ondřej Čertík Carlos Une Zuo Zhihua Jacob Williams Sebastian Ehlert See also nlesolver-fortran References Original sourcecode from: Netlib J. J. Moré, B. S. Garbow, and K. E. Hillstrom, User Guide for MINPACK-1 , Argonne National Laboratory Report ANL-80-74, Argonne, Ill., 1980. J. J. Moré, D. C. Sorensen, K. E. Hillstrom, and B. S. Garbow, The MINPACK Project, in Sources and Development of Mathematical Software, W. J. Cowell, ed., Prentice-Hall, pages 88-111, 1984. M. J. D. Powell, A Hybrid Method for Nonlinear Equations. Numerical Methods for Nonlinear Algebraic Equations, P. Rabinowitz, editor. Gordon and Breach, 1970. Jorge J. More, The Levenberg-Marquardt Algorithm, Implementation and Theory. Numerical Analysis, G. A. Watson, editor. Lecture Notes in Mathematics 630, Springer-Verlag, 1977. MINPACK-2 Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"minpack.f90 – minpack","text":"Files dependent on this one sourcefile~~minpack.f90~~AfferentGraph sourcefile~minpack.f90 minpack.f90 sourcefile~minpack_capi.f90 minpack_capi.f90 sourcefile~minpack_capi.f90->sourcefile~minpack.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules minpack_module Source Code minpack.f90 Source Code !***************************************************************************************** !> !  Modernized Minpack ! !### Authors !  * argonne national laboratory. minpack project. march 1980. !    burton s. garbow, kenneth e. hillstrom, jorge j. more. !  * Jacob Williams, Sept 2021, updated to modern standards. module minpack_module use iso_fortran_env , only : wp => real64 implicit none real ( wp ), dimension ( 3 ), parameter :: dpmpar = [ epsilon ( 1.0_wp ), & tiny ( 1.0_wp ), & huge ( 1.0_wp )] !! machine constants real ( wp ), parameter , private :: epsmch = dpmpar ( 1 ) !! the machine precision real ( wp ), parameter , private :: one = 1.0_wp real ( wp ), parameter , private :: zero = 0.0_wp abstract interface subroutine func ( n , x , fvec , iflag ) !! user-supplied subroutine for [[hybrd]], [[hybrd1]], and [[fdjac1]] import :: wp implicit none integer , intent ( in ) :: n !! the number of variables. real ( wp ), intent ( in ) :: x ( n ) !! independant variable vector real ( wp ), intent ( out ) :: fvec ( n ) !! value of function at `x` integer , intent ( inout ) :: iflag !! set to <0 to terminate execution end subroutine func subroutine func2 ( m , n , x , fvec , iflag ) !! user-supplied subroutine for [[fdjac2]], [[lmdif]], and [[lmdif1]] import :: wp implicit none integer , intent ( in ) :: m !! the number of functions. integer , intent ( in ) :: n !! the number of variables. real ( wp ), intent ( in ) :: x ( n ) !! independant variable vector real ( wp ), intent ( out ) :: fvec ( m ) !! value of function at `x` integer , intent ( inout ) :: iflag !! the value of iflag should not be changed unless !! the user wants to terminate execution of lmdif. !! in this case set iflag to a negative integer. end subroutine func2 subroutine fcn_hybrj ( n , x , fvec , fjac , ldfjac , iflag ) !! user-supplied subroutine for [[hybrj]] and [[hybrj1]] import :: wp implicit none integer , intent ( in ) :: n !! the number of variables. real ( wp ), dimension ( n ), intent ( in ) :: x !! independant variable vector integer , intent ( in ) :: ldfjac !! leading dimension of the array fjac. real ( wp ), dimension ( n ), intent ( out ) :: fvec !! value of function at `x` real ( wp ), dimension ( ldfjac , n ), intent ( out ) :: fjac !! jacobian matrix at `x` integer , intent ( inout ) :: iflag !! if iflag = 1 calculate the functions at x and !! return this vector in fvec. do not alter fjac. !! if iflag = 2 calculate the jacobian at x and !! return this matrix in fjac. do not alter fvec. !! !! the value of iflag should not be changed by fcn unless !! the user wants to terminate execution of hybrj. !! in this case set iflag to a negative integer. end subroutine fcn_hybrj subroutine fcn_lmder ( m , n , x , fvec , fjac , ldfjac , iflag ) !! user-supplied subroutine for [[lmder]] and [[lmder1]] import :: wp implicit none integer , intent ( in ) :: m !! the number of functions. integer , intent ( in ) :: n !! the number of variables. integer , intent ( in ) :: ldfjac !! leading dimension of the array fjac. integer , intent ( inout ) :: iflag !! if iflag = 1 calculate the functions at x and !! return this vector in fvec. do not alter fjac. !! if iflag = 2 calculate the jacobian at x and !! return this matrix in fjac. do not alter fvec. !! !! the value of iflag should not be changed by fcn unless !! the user wants to terminate execution of lmder. !! in this case set iflag to a negative integer. real ( wp ), intent ( in ) :: x ( n ) !! independant variable vector real ( wp ), intent ( inout ) :: fvec ( m ) !! value of function at `x` real ( wp ), intent ( inout ) :: fjac ( ldfjac , n ) !! jacobian matrix at `x` end subroutine fcn_lmder subroutine fcn_lmstr ( m , n , x , fvec , fjrow , iflag ) import :: wp implicit none integer , intent ( in ) :: m !! the number of functions. integer , intent ( in ) :: n !! the number of variables. integer , intent ( inout ) :: iflag !! if iflag = 1 calculate the functions at x and !! return this vector in fvec. !! if iflag = i calculate the (i-1)-st row of the !! jacobian at x and return this vector in fjrow. !! !! the value of iflag should not be changed by fcn unless !! the user wants to terminate execution of lmstr. !! in this case set iflag to a negative integer. real ( wp ), intent ( in ) :: x ( n ) !! independent variable vector real ( wp ), intent ( inout ) :: fvec ( m ) !! value of function at `x` real ( wp ), intent ( inout ) :: fjrow ( n ) !! jacobian row end subroutine fcn_lmstr end interface contains !***************************************************************************************** !***************************************************************************************** !> !  this subroutine checks the gradients of m nonlinear functions !  in n variables, evaluated at a point x, for consistency with !  the functions themselves. ! !  the subroutine does not perform reliably if cancellation or !  rounding errors cause a severe loss of significance in the !  evaluation of a function. therefore, none of the components !  of x should be unusually small (in particular, zero) or any !  other value which may cause loss of significance. subroutine chkder ( m , n , x , Fvec , Fjac , Ldfjac , Xp , Fvecp , Mode , Err ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of functions. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of variables. integer , intent ( in ) :: Ldfjac !! a positive integer input parameter not less than m !! which specifies the leading dimension of the array fjac. integer , intent ( in ) :: Mode !! an integer input variable set to 1 on the first call !! and 2 on the second. other values of mode are equivalent !! to mode = 1. !! !! the user must call chkder twice, !! first with mode = 1 and then with mode = 2. !! !!  * mode = 1. **on input**, x must contain the point of evaluation. !!    **on output**, xp is set to a neighboring point. !! !!  * mode = 2. **on input**, fvec must contain the functions and the !!    rows of fjac must contain the gradients !!    of the respective functions each evaluated !!    at x, and fvecp must contain the functions !!    evaluated at xp. !!    **on output**, err contains measures of correctness of !!    the respective gradients. real ( wp ), intent ( in ) :: x ( n ) !! input array real ( wp ), intent ( in ) :: Fvec ( m ) !! an array of length m. on input when mode = 2, !! fvec must contain the functions evaluated at x. real ( wp ), intent ( in ) :: Fjac ( Ldfjac , n ) !! an m by n array. on input when mode = 2, !! the rows of fjac must contain the gradients of !! the respective functions evaluated at x. real ( wp ), intent ( out ) :: Xp ( n ) !! an array of length n. on output when mode = 1, !! xp is set to a neighboring point of x. real ( wp ), intent ( in ) :: Fvecp ( m ) !! an array of length m. on input when mode = 2, !! fvecp must contain the functions evaluated at xp. real ( wp ), intent ( out ) :: Err ( m ) !! an array of length m. on output when mode = 2, !! err contains measures of correctness of the respective !! gradients. if there is no severe loss of significance, !! then if err(i) is 1.0 the i-th gradient is correct, !! while if err(i) is 0.0 the i-th gradient is incorrect. !! for values of err between 0.0 and 1.0, the categorization !! is less certain. in general, a value of err(i) greater !! than 0.5 indicates that the i-th gradient is probably !! correct, while a value of err(i) less than 0.5 indicates !! that the i-th gradient is probably incorrect. integer :: i , j real ( wp ) :: temp real ( wp ), parameter :: eps = sqrt ( epsmch ) real ( wp ), parameter :: factor = 10 0.0_wp real ( wp ), parameter :: epsf = factor * epsmch real ( wp ), parameter :: epslog = log10 ( eps ) select case ( Mode ) case ( 2 ) Err = zero do j = 1 , n temp = abs ( x ( j )) if ( temp == zero ) temp = one do i = 1 , m Err ( i ) = Err ( i ) + temp * Fjac ( i , j ) end do end do do i = 1 , m temp = one if ( Fvec ( i ) /= zero . and . Fvecp ( i ) /= zero . and . abs ( Fvecp ( i ) - Fvec ( i )) >= epsf * abs ( Fvec ( i ))) & temp = eps * abs (( Fvecp ( i ) - Fvec ( i )) / eps - Err ( i )) / ( abs ( Fvec ( i )) + abs ( Fvecp ( i ))) Err ( i ) = one if ( temp > epsmch . and . temp < eps ) Err ( i ) = ( log10 ( temp ) - epslog ) / epslog if ( temp >= eps ) Err ( i ) = zero end do case ( 1 ) do j = 1 , n temp = eps * abs ( x ( j )) if ( temp == zero ) temp = eps Xp ( j ) = x ( j ) + temp end do case default error stop 'invalid mode in chkder' end select end subroutine chkder !***************************************************************************************** !***************************************************************************************** !> !  given an m by n matrix a, an n by n nonsingular diagonal !  matrix d, an m-vector b, and a positive number delta, the !  problem is to determine the convex combination x of the !  gauss-newton and scaled gradient directions that minimizes !  (a*x - b) in the least squares sense, subject to the !  restriction that the euclidean norm of d*x be at most delta. ! !  this subroutine completes the solution of the problem !  if it is provided with the necessary information from the !  qr factorization of a. that is, if a = q*r, where q has !  orthogonal columns and r is an upper triangular matrix, !  then dogleg expects the full upper triangle of r and !  the first n components of (q transpose)*b. subroutine dogleg ( n , r , Lr , Diag , Qtb , Delta , x , Wa1 , Wa2 ) implicit none integer , intent ( in ) :: n !! a positive integer input variable set to the order of r. integer , intent ( in ) :: Lr !! a positive integer input variable not less than (n*(n+1))/2. real ( wp ), intent ( in ) :: Delta !! a positive input variable which specifies an upper !! bound on the euclidean norm of d*x. real ( wp ), intent ( in ) :: r ( Lr ) !! an input array of length lr which must contain the upper !! triangular matrix r stored by rows. real ( wp ), intent ( in ) :: Diag ( n ) !! an input array of length n which must contain the !! diagonal elements of the matrix d. real ( wp ), intent ( in ) :: Qtb ( n ) !! an input array of length n which must contain the first !! n elements of the vector (q transpose)*b. real ( wp ), intent ( out ) :: x ( n ) !! an output array of length n which contains the desired !! convex combination of the gauss-newton direction and the !! scaled gradient direction. real ( wp ), intent ( inout ) :: Wa1 ( n ) !! work arrays of length n real ( wp ), intent ( inout ) :: Wa2 ( n ) !! work arrays of length n integer :: i , j , jj , jp1 , k , l real ( wp ) :: alpha , bnorm , gnorm , qnorm , sgnorm , sum , temp ! first, calculate the gauss-newton direction. jj = ( n * ( n + 1 )) / 2 + 1 do k = 1 , n j = n - k + 1 jp1 = j + 1 jj = jj - k l = jj + 1 sum = zero if ( n >= jp1 ) then do i = jp1 , n sum = sum + r ( l ) * x ( i ) l = l + 1 end do end if temp = r ( jj ) if ( temp == zero ) then l = j do i = 1 , j temp = max ( temp , abs ( r ( l ))) l = l + n - i end do temp = epsmch * temp if ( temp == zero ) temp = epsmch end if x ( j ) = ( Qtb ( j ) - sum ) / temp end do ! test whether the gauss-newton direction is acceptable. do j = 1 , n Wa1 ( j ) = zero Wa2 ( j ) = Diag ( j ) * x ( j ) end do qnorm = enorm ( n , Wa2 ) if ( qnorm > Delta ) then ! the gauss-newton direction is not acceptable. ! next, calculate the scaled gradient direction. l = 1 do j = 1 , n temp = Qtb ( j ) do i = j , n Wa1 ( i ) = Wa1 ( i ) + r ( l ) * temp l = l + 1 end do Wa1 ( j ) = Wa1 ( j ) / Diag ( j ) end do ! calculate the norm of the scaled gradient and test for ! the special case in which the scaled gradient is zero. gnorm = enorm ( n , Wa1 ) sgnorm = zero alpha = Delta / qnorm if ( gnorm /= zero ) then ! calculate the point along the scaled gradient ! at which the quadratic is minimized. do j = 1 , n Wa1 ( j ) = ( Wa1 ( j ) / gnorm ) / Diag ( j ) end do l = 1 do j = 1 , n sum = zero do i = j , n sum = sum + r ( l ) * Wa1 ( i ) l = l + 1 end do Wa2 ( j ) = sum end do temp = enorm ( n , Wa2 ) sgnorm = ( gnorm / temp ) / temp ! test whether the scaled gradient direction is acceptable. alpha = zero if ( sgnorm < Delta ) then ! the scaled gradient direction is not acceptable. ! finally, calculate the point along the dogleg ! at which the quadratic is minimized. bnorm = enorm ( n , Qtb ) temp = ( bnorm / gnorm ) * ( bnorm / qnorm ) * ( sgnorm / Delta ) temp = temp - ( Delta / qnorm ) * ( sgnorm / Delta ) ** 2 + & sqrt (( temp - ( Delta / qnorm )) ** 2 + & ( one - ( Delta / qnorm ) ** 2 ) * ( one - ( sgnorm / Delta ) ** 2 )) alpha = (( Delta / qnorm ) * ( one - ( sgnorm / Delta ) ** 2 )) / temp end if end if ! form appropriate convex combination of the gauss-newton ! direction and the scaled gradient direction. temp = ( one - alpha ) * min ( sgnorm , Delta ) do j = 1 , n x ( j ) = temp * Wa1 ( j ) + alpha * x ( j ) end do end if end subroutine dogleg !***************************************************************************************** !***************************************************************************************** !> !  given an n-vector x, this function calculates the !  euclidean norm of x. ! !  the euclidean norm is computed by accumulating the sum of !  squares in three different sums. the sums of squares for the !  small and large components are scaled so that no overflows !  occur. non-destructive underflows are permitted. underflows !  and overflows do not occur in the computation of the unscaled !  sum of squares for the intermediate components. !  the definitions of small, intermediate and large components !  depend on two constants, rdwarf and rgiant. the main !  restrictions on these constants are that rdwarf**2 not !  underflow and rgiant**2 not overflow. the constants !  given here are suitable for every known computer. pure real ( wp ) function enorm ( n , x ) implicit none integer , intent ( in ) :: n !! a positive integer input variable. real ( wp ), intent ( in ) :: x ( n ) !! an input array of length n. integer :: i real ( wp ) :: agiant , s1 , s2 , s3 , xabs , x1max , x3max real ( wp ), parameter :: rdwarf = 3.834e-20_wp real ( wp ), parameter :: rgiant = 1.304e19_wp s1 = zero s2 = zero s3 = zero x1max = zero x3max = zero agiant = rgiant / real ( n , wp ) do i = 1 , n xabs = abs ( x ( i )) if ( xabs > rdwarf . and . xabs < agiant ) then ! sum for intermediate components. s2 = s2 + xabs ** 2 elseif ( xabs <= rdwarf ) then ! sum for small components. if ( xabs <= x3max ) then if ( xabs /= zero ) s3 = s3 + ( xabs / x3max ) ** 2 else s3 = one + s3 * ( x3max / xabs ) ** 2 x3max = xabs end if ! sum for large components. elseif ( xabs <= x1max ) then s1 = s1 + ( xabs / x1max ) ** 2 else s1 = one + s1 * ( x1max / xabs ) ** 2 x1max = xabs end if end do ! calculation of norm. if ( s1 /= zero ) then enorm = x1max * sqrt ( s1 + ( s2 / x1max ) / x1max ) elseif ( s2 == zero ) then enorm = x3max * sqrt ( s3 ) else if ( s2 >= x3max ) enorm = sqrt ( s2 * ( one + ( x3max / s2 ) * ( x3max * s3 ))) if ( s2 < x3max ) enorm = sqrt ( x3max * (( s2 / x3max ) + ( x3max * s3 ))) end if end function enorm !***************************************************************************************** !***************************************************************************************** !> !  this subroutine computes a forward-difference approximation !  to the n by n jacobian matrix associated with a specified !  problem of n functions in n variables. if the jacobian has !  a banded form, then function evaluations are saved by only !  approximating the nonzero terms. subroutine fdjac1 ( fcn , n , x , Fvec , Fjac , Ldfjac , Iflag , Ml , Mu , Epsfcn , Wa1 , Wa2 ) implicit none procedure ( func ) :: fcn !! the user-supplied subroutine which !! calculates the functions. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of functions and variables. integer , intent ( in ) :: Ldfjac !! a positive integer input variable not less than n !! which specifies the leading dimension of the array fjac. integer , intent ( out ) :: Iflag !! an integer variable which can be used to terminate !! the execution of fdjac1. see description of [[func]]. integer , intent ( in ) :: Ml !! a nonnegative integer input variable which specifies !! the number of subdiagonals within the band of the !! jacobian matrix. if the jacobian is not banded, set !! ml to at least n - 1. integer , intent ( in ) :: Mu !! a nonnegative integer input variable which specifies !! the number of superdiagonals within the band of the !! jacobian matrix. if the jacobian is not banded, set !! mu to at least n - 1. real ( wp ), intent ( in ) :: Epsfcn !! an input variable used in determining a suitable !! step length for the forward-difference approximation. this !! approximation assumes that the relative errors in the !! functions are of the order of epsfcn. if epsfcn is less !! than the machine precision, it is assumed that the relative !! errors in the functions are of the order of the machine !! precision. real ( wp ), intent ( inout ) :: x ( n ) !! an input array of length n. real ( wp ), intent ( in ) :: Fvec ( n ) !! an input array of length n which must contain the !! functions evaluated at x. real ( wp ), intent ( out ) :: Fjac ( Ldfjac , n ) !! an output n by n array which contains the !! approximation to the jacobian matrix evaluated at x. real ( wp ), intent ( inout ) :: Wa1 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa2 ( n ) !! work array of length n. if ml + mu + 1 is at !! least n, then the jacobian is considered dense, and wa2 is !! not referenced. integer :: i , j , k , msum real ( wp ) :: eps , h , temp eps = sqrt ( max ( Epsfcn , epsmch )) msum = Ml + Mu + 1 if ( msum < n ) then ! computation of banded approximate jacobian. do k = 1 , msum do j = k , n , msum Wa2 ( j ) = x ( j ) h = eps * abs ( Wa2 ( j )) if ( h == zero ) h = eps x ( j ) = Wa2 ( j ) + h end do Iflag = 1 ! JW added call fcn ( n , x , Wa1 , Iflag ) if ( Iflag < 0 ) return do j = k , n , msum x ( j ) = Wa2 ( j ) h = eps * abs ( Wa2 ( j )) if ( h == zero ) h = eps do i = 1 , n Fjac ( i , j ) = zero if ( i >= j - Mu . and . i <= j + Ml ) Fjac ( i , j ) = ( Wa1 ( i ) - Fvec ( i )) / h end do end do end do else ! computation of dense approximate jacobian. do j = 1 , n temp = x ( j ) h = eps * abs ( temp ) if ( h == zero ) h = eps x ( j ) = temp + h Iflag = 1 ! JW added call fcn ( n , x , Wa1 , Iflag ) if ( Iflag < 0 ) return x ( j ) = temp do i = 1 , n Fjac ( i , j ) = ( Wa1 ( i ) - Fvec ( i )) / h end do end do end if end subroutine fdjac1 !***************************************************************************************** !***************************************************************************************** !> !  this subroutine computes a forward-difference approximation !  to the m by n jacobian matrix associated with a specified !  problem of m functions in n variables. subroutine fdjac2 ( fcn , m , n , x , Fvec , Fjac , Ldfjac , Iflag , Epsfcn , Wa ) implicit none procedure ( func2 ) :: fcn !! the user-supplied subroutine which !! calculates the functions. integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of functions. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of variables. n must not exceed m. integer , intent ( in ) :: Ldfjac !! a positive integer input variable not less than m !! which specifies the leading dimension of the array fjac. integer , intent ( out ) :: Iflag !! an integer variable which can be used to terminate !! the execution of fdjac2. see description of [[func2]]. real ( wp ), intent ( in ) :: Epsfcn !! an input variable used in determining a suitable !! step length for the forward-difference approximation. this !! approximation assumes that the relative errors in the !! functions are of the order of epsfcn. if epsfcn is less !! than the machine precision, it is assumed that the relative !! errors in the functions are of the order of the machine !! precision. real ( wp ), intent ( inout ) :: x ( n ) !! an input array of length n. real ( wp ), intent ( in ) :: Fvec ( m ) !! an input array of length m which must contain the !! functions evaluated at x. real ( wp ), intent ( out ) :: Fjac ( Ldfjac , n ) !! an output m by n array which contains the !! approximation to the jacobian matrix evaluated at x. real ( wp ), intent ( inout ) :: Wa ( m ) !! a work array of length m. integer :: i , j real ( wp ) :: eps , h , temp eps = sqrt ( max ( Epsfcn , epsmch )) do j = 1 , n temp = x ( j ) h = eps * abs ( temp ) if ( h == zero ) h = eps x ( j ) = temp + h call fcn ( m , n , x , Wa , Iflag ) if ( Iflag < 0 ) return x ( j ) = temp do i = 1 , m Fjac ( i , j ) = ( Wa ( i ) - Fvec ( i )) / h end do end do end subroutine fdjac2 !***************************************************************************************** !***************************************************************************************** !> !  the purpose of hybrd is to find a zero of a system of !  n nonlinear functions in n variables by a modification !  of the powell hybrid method. the user must provide a !  subroutine which calculates the functions. the jacobian is !  then calculated by a forward-difference approximation. subroutine hybrd ( fcn , n , x , Fvec , Xtol , Maxfev , Ml , Mu , Epsfcn , Diag , Mode , & Factor , Nprint , Info , Nfev , Fjac , Ldfjac , r , Lr , Qtf , Wa1 , & Wa2 , Wa3 , Wa4 ) implicit none procedure ( func ) :: fcn !! user-supplied subroutine which calculates the functions integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of functions and variables. integer , intent ( in ) :: maxfev !! a positive integer input variable. termination !! occurs when the number of calls to `fcn` is at least `maxfev` !! by the end of an iteration. integer , intent ( in ) :: ml !! a nonnegative integer input variable which specifies !! the number of subdiagonals within the band of the !! jacobian matrix. if the jacobian is not banded, set !! `ml` to at least `n - 1`. integer , intent ( in ) :: mu !! a nonnegative integer input variable which specifies !! the number of superdiagonals within the band of the !! jacobian matrix. if the jacobian is not banded, set !! `mu` to at least` n - 1`. integer , intent ( in ) :: mode !! if `mode = 1`, the !! variables will be scaled internally. if `mode = 2`, !! the scaling is specified by the input `diag`. other !! values of `mode` are equivalent to `mode = 1`. integer , intent ( in ) :: nprint !! an integer input variable that enables controlled !! printing of iterates if it is positive. in this case, !! `fcn` is called with `iflag = 0` at the beginning of the first !! iteration and every `nprint` iterations thereafter and !! immediately prior to return, with `x` and `fvec` available !! for printing. if `nprint` is not positive, no special calls !! of `fcn` with `iflag = 0` are made. integer , intent ( out ) :: info !! an integer output variable. if the user has !! terminated execution, `info` is set to the (negative) !! value of `iflag`. see description of `fcn`. otherwise, !! `info` is set as follows: !! !!  * ***info = 0*** improper input parameters. !!  * ***info = 1*** relative error between two consecutive iterates !!    is at most `xtol`. !!  * ***info = 2*** number of calls to `fcn` has reached or exceeded !!    `maxfev`. !!  * ***info = 3*** `xtol` is too small. no further improvement in !!    the approximate solution `x` is possible. !!  * ***info = 4*** iteration is not making good progress, as !!    measured by the improvement from the last !!    five jacobian evaluations. !!  * ***info = 5*** iteration is not making good progress, as !!    measured by the improvement from the last !!    ten iterations. integer , intent ( out ) :: nfev !! output variable set to the number of calls to `fcn`. integer , intent ( in ) :: ldfjac !! a positive integer input variable not less than `n` !! which specifies the leading dimension of the array `fjac`. integer , intent ( in ) :: lr !! a positive integer input variable not less than `(n*(n+1))/2`. real ( wp ), intent ( in ) :: xtol !! a nonnegative input variable. termination !! occurs when the relative error between two consecutive !! iterates is at most `xtol`. real ( wp ), intent ( in ) :: epsfcn !! an input variable used in determining a suitable !! step length for the forward-difference approximation. this !! approximation assumes that the relative errors in the !! functions are of the order of `epsfcn`. if `epsfcn` is less !! than the machine precision, it is assumed that the relative !! errors in the functions are of the order of the machine !! precision. real ( wp ), intent ( in ) :: factor !! a positive input variable used in determining the !! initial step bound. this bound is set to the product of !! `factor` and the euclidean norm of `diag*x` if nonzero, or else !! to `factor` itself. in most cases factor should lie in the !! interval (.1,100.). 100. is a generally recommended value. real ( wp ), intent ( inout ) :: x ( n ) !! array of length n. on input `x` must contain !! an initial estimate of the solution vector. on output `x` !! contains the final estimate of the solution vector. real ( wp ), intent ( out ) :: fvec ( n ) !! an output array of length `n` which contains !! the functions evaluated at the output `x`. real ( wp ), intent ( inout ) :: diag ( n ) !! an array of length `n`. if `mode = 1` (see !! below), `diag` is internally set. if `mode = 2`, `diag` !! must contain positive entries that serve as !! multiplicative scale factors for the variables. real ( wp ), intent ( out ) :: fjac ( ldfjac , n ) !! array which contains the !! orthogonal matrix `q` produced by the QR factorization !! of the final approximate jacobian. real ( wp ), intent ( out ) :: r ( lr ) !! an output array which contains the !! upper triangular matrix produced by the QR factorization !! of the final approximate jacobian, stored rowwise. real ( wp ), intent ( out ) :: qtf ( n ) !! an output array of length `n` which contains !! the vector `(q transpose)*fvec`. real ( wp ), intent ( inout ) :: wa1 ( n ) !! work array real ( wp ), intent ( inout ) :: wa2 ( n ) !! work array real ( wp ), intent ( inout ) :: wa3 ( n ) !! work array real ( wp ), intent ( inout ) :: wa4 ( n ) !! work array integer :: i , iflag , iter , j , jm1 , l , msum , ncfail , ncsuc , nslow1 , nslow2 integer :: iwa ( 1 ) logical :: jeval , sing real ( wp ) :: actred , delta , fnorm , fnorm1 , pnorm , prered , ratio , sum , temp , xnorm real ( wp ), parameter :: p1 = 1.0e-1_wp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p001 = 1.0e-3_wp real ( wp ), parameter :: p0001 = 1.0e-4_wp Info = 0 iflag = 0 Nfev = 0 ! check the input parameters for errors. if ( n <= 0 . or . Xtol < zero . or . Maxfev <= 0 . or . Ml < 0 . or . Mu < 0 . or . & Factor <= zero . or . Ldfjac < n . or . Lr < ( n * ( n + 1 )) / 2 ) goto 300 if ( Mode == 2 ) then do j = 1 , n if ( Diag ( j ) <= zero ) goto 300 end do end if ! evaluate the function at the starting point ! and calculate its norm. iflag = 1 call fcn ( n , x , Fvec , iflag ) Nfev = 1 if ( iflag < 0 ) goto 300 fnorm = enorm ( n , Fvec ) ! determine the number of calls to fcn needed to compute ! the jacobian matrix. msum = min0 ( Ml + Mu + 1 , n ) ! initialize iteration counter and monitors. iter = 1 ncsuc = 0 ncfail = 0 nslow1 = 0 nslow2 = 0 ! beginning of the outer loop. 100 jeval = . true . ! calculate the jacobian matrix. iflag = 2 call fdjac1 ( fcn , n , x , Fvec , Fjac , Ldfjac , iflag , Ml , Mu , Epsfcn , Wa1 , Wa2 ) Nfev = Nfev + msum if ( iflag < 0 ) goto 300 ! compute the qr factorization of the jacobian. call qrfac ( n , n , Fjac , Ldfjac , . false ., iwa , 1 , Wa1 , Wa2 , Wa3 ) ! on the first iteration and if mode is 1, scale according ! to the norms of the columns of the initial jacobian. if ( iter == 1 ) then if ( Mode /= 2 ) then do j = 1 , n Diag ( j ) = Wa2 ( j ) if ( Wa2 ( j ) == zero ) Diag ( j ) = one end do end if ! on the first iteration, calculate the norm of the scaled x ! and initialize the step bound delta. do j = 1 , n Wa3 ( j ) = Diag ( j ) * x ( j ) end do xnorm = enorm ( n , Wa3 ) delta = Factor * xnorm if ( delta == zero ) delta = Factor end if ! form (q transpose)*fvec and store in qtf. do i = 1 , n Qtf ( i ) = Fvec ( i ) end do do j = 1 , n if ( Fjac ( j , j ) /= zero ) then sum = zero do i = j , n sum = sum + Fjac ( i , j ) * Qtf ( i ) end do temp = - sum / Fjac ( j , j ) do i = j , n Qtf ( i ) = Qtf ( i ) + Fjac ( i , j ) * temp end do end if end do ! copy the triangular factor of the qr factorization into r. sing = . false . do j = 1 , n l = j jm1 = j - 1 if ( jm1 >= 1 ) then do i = 1 , jm1 r ( l ) = Fjac ( i , j ) l = l + n - i end do end if r ( l ) = Wa1 ( j ) if ( Wa1 ( j ) == zero ) sing = . true . end do ! accumulate the orthogonal factor in fjac. call qform ( n , n , Fjac , Ldfjac , Wa1 ) ! rescale if necessary. if ( Mode /= 2 ) then do j = 1 , n Diag ( j ) = max ( Diag ( j ), Wa2 ( j )) end do end if ! beginning of the inner loop. ! if requested, call fcn to enable printing of iterates. 200 if ( Nprint > 0 ) then iflag = 0 if ( mod ( iter - 1 , Nprint ) == 0 ) call fcn ( n , x , Fvec , iflag ) if ( iflag < 0 ) goto 300 end if ! determine the direction p. call dogleg ( n , r , Lr , Diag , Qtf , delta , Wa1 , Wa2 , Wa3 ) ! store the direction p and x + p. calculate the norm of p. do j = 1 , n Wa1 ( j ) = - Wa1 ( j ) Wa2 ( j ) = x ( j ) + Wa1 ( j ) Wa3 ( j ) = Diag ( j ) * Wa1 ( j ) end do pnorm = enorm ( n , Wa3 ) ! on the first iteration, adjust the initial step bound. if ( iter == 1 ) delta = min ( delta , pnorm ) ! evaluate the function at x + p and calculate its norm. iflag = 1 call fcn ( n , Wa2 , Wa4 , iflag ) Nfev = Nfev + 1 if ( iflag >= 0 ) then fnorm1 = enorm ( n , Wa4 ) ! compute the scaled actual reduction. actred = - one if ( fnorm1 < fnorm ) actred = one - ( fnorm1 / fnorm ) ** 2 ! compute the scaled predicted reduction. l = 1 do i = 1 , n sum = zero do j = i , n sum = sum + r ( l ) * Wa1 ( j ) l = l + 1 end do Wa3 ( i ) = Qtf ( i ) + sum end do temp = enorm ( n , Wa3 ) prered = zero if ( temp < fnorm ) prered = one - ( temp / fnorm ) ** 2 ! compute the ratio of the actual to the predicted ! reduction. ratio = zero if ( prered > zero ) ratio = actred / prered ! update the step bound. if ( ratio >= p1 ) then ncfail = 0 ncsuc = ncsuc + 1 if ( ratio >= p5 . or . ncsuc > 1 ) delta = max ( delta , pnorm / p5 ) if ( abs ( ratio - one ) <= p1 ) delta = pnorm / p5 else ncsuc = 0 ncfail = ncfail + 1 delta = p5 * delta end if ! test for successful iteration. if ( ratio >= p0001 ) then ! successful iteration. update x, fvec, and their norms. do j = 1 , n x ( j ) = Wa2 ( j ) Wa2 ( j ) = Diag ( j ) * x ( j ) Fvec ( j ) = Wa4 ( j ) end do xnorm = enorm ( n , Wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! determine the progress of the iteration. nslow1 = nslow1 + 1 if ( actred >= p001 ) nslow1 = 0 if ( jeval ) nslow2 = nslow2 + 1 if ( actred >= p1 ) nslow2 = 0 ! test for convergence. if ( delta <= Xtol * xnorm . or . fnorm == zero ) Info = 1 if ( Info == 0 ) then ! tests for termination and stringent tolerances. if ( Nfev >= Maxfev ) Info = 2 if ( p1 * max ( p1 * delta , pnorm ) <= epsmch * xnorm ) Info = 3 if ( nslow2 == 5 ) Info = 4 if ( nslow1 == 10 ) Info = 5 if ( Info == 0 ) then ! criterion for recalculating jacobian approximation ! by forward differences. if ( ncfail == 2 ) goto 100 ! calculate the rank one modification to the jacobian ! and update qtf if necessary. do j = 1 , n sum = zero do i = 1 , n sum = sum + Fjac ( i , j ) * Wa4 ( i ) end do Wa2 ( j ) = ( sum - Wa3 ( j )) / pnorm Wa1 ( j ) = Diag ( j ) * (( Diag ( j ) * Wa1 ( j )) / pnorm ) if ( ratio >= p0001 ) Qtf ( j ) = sum end do ! compute the qr factorization of the updated jacobian. call r1updt ( n , n , r , Lr , Wa1 , Wa2 , Wa3 , sing ) call r1mpyq ( n , n , Fjac , Ldfjac , Wa2 , Wa3 ) call r1mpyq ( 1 , n , Qtf , 1 , Wa2 , Wa3 ) ! end of the inner loop. jeval = . false . ! end of the outer loop. goto 200 end if end if end if ! termination, either normal or user imposed. 300 if ( iflag < 0 ) Info = iflag iflag = 0 if ( Nprint > 0 ) call fcn ( n , x , Fvec , iflag ) end subroutine hybrd !***************************************************************************************** !***************************************************************************************** !> !  the purpose of hybrd1 is to find a zero of a system of !  n nonlinear functions in n variables by a modification !  of the powell hybrid method. this is done by using the !  more general nonlinear equation solver hybrd. the user !  must provide a subroutine which calculates the functions. !  the jacobian is then calculated by a forward-difference !  approximation. subroutine hybrd1 ( fcn , n , x , Fvec , Tol , Info , Wa , Lwa ) implicit none procedure ( func ) :: fcn !! user-supplied subroutine which calculates the functions integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of functions and variables. integer , intent ( out ) :: info !! an integer output variable. if the user has !! terminated execution, info is set to the (negative) !! value of `iflag`. see description of `fcn`. otherwise, !! `info` is set as follows: !! !!  * ***info = 0*** improper input parameters. !!  * ***info = 1*** algorithm estimates that the relative error !!  between `x` and the solution is at most `tol`. !!  * ***info = 2*** number of calls to `fcn` has reached or exceeded !!  `200*(n+1)`. !!  * ***info = 3*** `tol` is too small. no further improvement in !!  the approximate solution `x` is possible. !!  * ***info = 4*** iteration is not making good progress. real ( wp ), intent ( in ) :: tol !! a nonnegative input variable. termination occurs !! when the algorithm estimates that the relative error !! between `x` and the solution is at most `tol`. real ( wp ), dimension ( n ), intent ( inout ) :: x !! an array of length `n`. on input `x` must contain !! an initial estimate of the solution vector. on output `x` !! contains the final estimate of the solution vector. real ( wp ), dimension ( n ), intent ( out ) :: fvec !! an output array of length `n` which contains !! the functions evaluated at the output `x`. integer , intent ( in ) :: Lwa !! a positive integer input variable not less than !! (n*(3*n+13))/2. real ( wp ), intent ( inout ) :: Wa ( Lwa ) !! a work array of length lwa. integer :: index , j , lr , maxfev , ml , mode , mu , nfev , nprint real ( wp ) :: epsfcn , xtol reaL ( wp ), parameter :: factor = 10 0.0_wp Info = 0 ! check the input parameters for errors. if ( n > 0 . and . Tol >= zero . and . Lwa >= ( n * ( 3 * n + 13 )) / 2 ) then ! call hybrd. maxfev = 200 * ( n + 1 ) xtol = Tol ml = n - 1 mu = n - 1 epsfcn = zero mode = 2 do j = 1 , n Wa ( j ) = one end do nprint = 0 lr = ( n * ( n + 1 )) / 2 index = 6 * n + lr call hybrd ( fcn , n , x , Fvec , xtol , maxfev , ml , mu , epsfcn , Wa ( 1 ), mode , & factor , nprint , Info , nfev , Wa ( index + 1 ), n , Wa ( 6 * n + 1 ), lr , & Wa ( n + 1 ), Wa ( 2 * n + 1 ), Wa ( 3 * n + 1 ), Wa ( 4 * n + 1 ), Wa ( 5 * n + 1 )) if ( Info == 5 ) Info = 4 end if end subroutine hybrd1 !***************************************************************************************** !***************************************************************************************** !> !  the purpose of hybrj is to find a zero of a system of !  n nonlinear functions in n variables by a modification !  of the powell hybrid method. the user must provide a !  subroutine which calculates the functions and the jacobian. subroutine hybrj ( fcn , n , x , Fvec , Fjac , Ldfjac , Xtol , Maxfev , Diag , Mode , & Factor , Nprint , Info , Nfev , Njev , r , Lr , Qtf , Wa1 , Wa2 , & Wa3 , Wa4 ) implicit none procedure ( fcn_hybrj ) :: fcn !! the user-supplied subroutine which !! calculates the functions and the jacobian integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of functions and variables. integer , intent ( in ) :: Ldfjac !! a positive integer input variable not less than n !! which specifies the leading dimension of the array fjac. integer , intent ( in ) :: Maxfev !! a positive integer input variable. termination !! occurs when the number of calls to fcn with iflag = 1 !! has reached maxfev. integer , intent ( in ) :: Mode !! an integer input variable. if mode = 1, the !! variables will be scaled internally. if mode = 2, !! the scaling is specified by the input diag. other !! values of mode are equivalent to mode = 1. integer , intent ( in ) :: Nprint !! an integer input variable that enables controlled !! printing of iterates if it is positive. in this case, !! fcn is called with iflag = 0 at the beginning of the first !! iteration and every nprint iterations thereafter and !! immediately prior to return, with x and fvec available !! for printing. fvec and fjac should not be altered. !! if nprint is not positive, no special calls of fcn !! with iflag = 0 are made. integer , intent ( out ) :: Info !! an integer output variable. if the user has !! terminated execution, info is set to the (negative) !! value of iflag. see description of fcn. otherwise, !! info is set as follows: !! !!  * ***info = 0***   improper input parameters. !!  * ***info = 1***   relative error between two consecutive iterates !!    is at most xtol. !!  * ***info = 2***   number of calls to fcn with iflag = 1 has !!    reached maxfev. !!  * ***info = 3***   xtol is too small. no further improvement in !!    the approximate solution x is possible. !!  * ***info = 4***   iteration is not making good progress, as !!    measured by the improvement from the last !!    five jacobian evaluations. !!  * ***info = 5***   iteration is not making good progress, as !!    measured by the improvement from the last !!    ten iterations. integer , intent ( out ) :: Nfev !! an integer output variable set to the number of !! calls to fcn with iflag = 1. integer , intent ( out ) :: Njev !! an integer output variable set to the number of !! calls to fcn with iflag = 2. integer , intent ( in ) :: Lr !! a positive integer input variable not less than !! (n*(n+1))/2. real ( wp ), intent ( in ) :: Xtol !! a nonnegative input variable. termination !! occurs when the relative error between two consecutive !! iterates is at most xtol. real ( wp ), intent ( in ) :: Factor !! a positive input variable used in determining the !! initial step bound. this bound is set to the product of !! factor and the euclidean norm of diag*x if nonzero, or else !! to factor itself. in most cases factor should lie in the !! interval (.1,100.). 100. is a generally recommended value. real ( wp ), intent ( inout ) :: x ( n ) !! an array of length n. on input x must contain !! an initial estimate of the solution vector. on output x !! contains the final estimate of the solution vector. real ( wp ), intent ( out ) :: Fvec ( n ) !! an output array of length n which contains !! the functions evaluated at the output x. real ( wp ), intent ( out ) :: Fjac ( Ldfjac , n ) !! an output n by n array which contains the !! orthogonal matrix q produced by the qr factorization !! of the final approximate jacobian. real ( wp ), intent ( inout ) :: Diag ( n ) !! an array of length n. if mode = 1 (see !! below), diag is internally set. if mode = 2, diag !! must contain positive entries that serve as !! multiplicative scale factors for the variables. real ( wp ), intent ( out ) :: r ( Lr ) !! an output array of length lr which contains the !! upper triangular matrix produced by the qr factorization !! of the final approximate jacobian, stored rowwise. real ( wp ), intent ( out ) :: Qtf ( n ) !! an output array of length n which contains !! the vector (q transpose)*fvec. real ( wp ), intent ( inout ) :: Wa1 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa2 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa3 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa4 ( n ) !! work array of length n. integer :: i , iflag , iter , j , jm1 , l , ncfail , ncsuc , nslow1 , nslow2 integer :: iwa ( 1 ) logical :: jeval , sing real ( wp ) :: actred , delta , fnorm , fnorm1 , pnorm , prered , ratio , sum , temp , xnorm real ( wp ), parameter :: p1 = 1.0e-1_wp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p001 = 1.0e-3_wp real ( wp ), parameter :: p0001 = 1.0e-4_wp Info = 0 iflag = 0 Nfev = 0 Njev = 0 ! check the input parameters for errors. if ( n <= 0 . or . Ldfjac < n . or . Xtol < zero . or . Maxfev <= 0 . or . & Factor <= zero . or . Lr < ( n * ( n + 1 )) / 2 ) goto 300 if ( Mode == 2 ) then do j = 1 , n if ( Diag ( j ) <= zero ) goto 300 end do end if ! evaluate the function at the starting point ! and calculate its norm. iflag = 1 call fcn ( n , x , Fvec , Fjac , Ldfjac , iflag ) Nfev = 1 if ( iflag < 0 ) goto 300 fnorm = enorm ( n , Fvec ) ! initialize iteration counter and monitors. iter = 1 ncsuc = 0 ncfail = 0 nslow1 = 0 nslow2 = 0 ! beginning of the outer loop. 100 jeval = . true . ! calculate the jacobian matrix. iflag = 2 call fcn ( n , x , Fvec , Fjac , Ldfjac , iflag ) Njev = Njev + 1 if ( iflag < 0 ) goto 300 ! compute the qr factorization of the jacobian. call qrfac ( n , n , Fjac , Ldfjac , . false ., iwa , 1 , Wa1 , Wa2 , Wa3 ) ! on the first iteration and if mode is 1, scale according ! to the norms of the columns of the initial jacobian. if ( iter == 1 ) then if ( Mode /= 2 ) then do j = 1 , n Diag ( j ) = Wa2 ( j ) if ( Wa2 ( j ) == zero ) Diag ( j ) = one end do end if ! on the first iteration, calculate the norm of the scaled x ! and initialize the step bound delta. do j = 1 , n Wa3 ( j ) = Diag ( j ) * x ( j ) end do xnorm = enorm ( n , Wa3 ) delta = Factor * xnorm if ( delta == zero ) delta = Factor end if ! form (q transpose)*fvec and store in qtf. do i = 1 , n Qtf ( i ) = Fvec ( i ) end do do j = 1 , n if ( Fjac ( j , j ) /= zero ) then sum = zero do i = j , n sum = sum + Fjac ( i , j ) * Qtf ( i ) end do temp = - sum / Fjac ( j , j ) do i = j , n Qtf ( i ) = Qtf ( i ) + Fjac ( i , j ) * temp end do end if end do ! copy the triangular factor of the qr factorization into r. sing = . false . do j = 1 , n l = j jm1 = j - 1 if ( jm1 >= 1 ) then do i = 1 , jm1 r ( l ) = Fjac ( i , j ) l = l + n - i end do end if r ( l ) = Wa1 ( j ) if ( Wa1 ( j ) == zero ) sing = . true . end do ! accumulate the orthogonal factor in fjac. call qform ( n , n , Fjac , Ldfjac , Wa1 ) ! rescale if necessary. if ( Mode /= 2 ) then do j = 1 , n Diag ( j ) = max ( Diag ( j ), Wa2 ( j )) end do end if ! beginning of the inner loop. ! if requested, call fcn to enable printing of iterates. 200 if ( Nprint > 0 ) then iflag = 0 if ( mod ( iter - 1 , Nprint ) == 0 ) & call fcn ( n , x , Fvec , Fjac , Ldfjac , iflag ) if ( iflag < 0 ) goto 300 end if ! determine the direction p. call dogleg ( n , r , Lr , Diag , Qtf , delta , Wa1 , Wa2 , Wa3 ) ! store the direction p and x + p. calculate the norm of p. do j = 1 , n Wa1 ( j ) = - Wa1 ( j ) Wa2 ( j ) = x ( j ) + Wa1 ( j ) Wa3 ( j ) = Diag ( j ) * Wa1 ( j ) end do pnorm = enorm ( n , Wa3 ) ! on the first iteration, adjust the initial step bound. if ( iter == 1 ) delta = min ( delta , pnorm ) ! evaluate the function at x + p and calculate its norm. iflag = 1 call fcn ( n , Wa2 , Wa4 , Fjac , Ldfjac , iflag ) Nfev = Nfev + 1 if ( iflag >= 0 ) then fnorm1 = enorm ( n , Wa4 ) ! compute the scaled actual reduction. actred = - one if ( fnorm1 < fnorm ) actred = one - ( fnorm1 / fnorm ) ** 2 ! compute the scaled predicted reduction. l = 1 do i = 1 , n sum = zero do j = i , n sum = sum + r ( l ) * Wa1 ( j ) l = l + 1 end do Wa3 ( i ) = Qtf ( i ) + sum end do temp = enorm ( n , Wa3 ) prered = zero if ( temp < fnorm ) prered = one - ( temp / fnorm ) ** 2 ! compute the ratio of the actual to the predicted ! reduction. ratio = zero if ( prered > zero ) ratio = actred / prered ! update the step bound. if ( ratio >= p1 ) then ncfail = 0 ncsuc = ncsuc + 1 if ( ratio >= p5 . or . ncsuc > 1 ) delta = max ( delta , pnorm / p5 ) if ( abs ( ratio - one ) <= p1 ) delta = pnorm / p5 else ncsuc = 0 ncfail = ncfail + 1 delta = p5 * delta end if ! test for successful iteration. if ( ratio >= p0001 ) then ! successful iteration. update x, fvec, and their norms. do j = 1 , n x ( j ) = Wa2 ( j ) Wa2 ( j ) = Diag ( j ) * x ( j ) Fvec ( j ) = Wa4 ( j ) end do xnorm = enorm ( n , Wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! determine the progress of the iteration. nslow1 = nslow1 + 1 if ( actred >= p001 ) nslow1 = 0 if ( jeval ) nslow2 = nslow2 + 1 if ( actred >= p1 ) nslow2 = 0 ! test for convergence. if ( delta <= Xtol * xnorm . or . fnorm == zero ) Info = 1 if ( Info == 0 ) then ! tests for termination and stringent tolerances. if ( Nfev >= Maxfev ) Info = 2 if ( p1 * max ( p1 * delta , pnorm ) <= epsmch * xnorm ) Info = 3 if ( nslow2 == 5 ) Info = 4 if ( nslow1 == 10 ) Info = 5 if ( Info == 0 ) then ! criterion for recalculating jacobian. if ( ncfail == 2 ) goto 100 ! calculate the rank one modification to the jacobian ! and update qtf if necessary. do j = 1 , n sum = zero do i = 1 , n sum = sum + Fjac ( i , j ) * Wa4 ( i ) end do Wa2 ( j ) = ( sum - Wa3 ( j )) / pnorm Wa1 ( j ) = Diag ( j ) * (( Diag ( j ) * Wa1 ( j )) / pnorm ) if ( ratio >= p0001 ) Qtf ( j ) = sum end do ! compute the qr factorization of the updated jacobian. call r1updt ( n , n , r , Lr , Wa1 , Wa2 , Wa3 , sing ) call r1mpyq ( n , n , Fjac , Ldfjac , Wa2 , Wa3 ) call r1mpyq ( 1 , n , Qtf , 1 , Wa2 , Wa3 ) ! end of the inner loop. jeval = . false . ! end of the outer loop. goto 200 end if end if end if ! termination, either normal or user imposed. 300 if ( iflag < 0 ) Info = iflag iflag = 0 if ( Nprint > 0 ) call fcn ( n , x , Fvec , Fjac , Ldfjac , iflag ) end subroutine hybrj !***************************************************************************************** !***************************************************************************************** !> !  the purpose of hybrj1 is to find a zero of a system of !  n nonlinear functions in n variables by a modification !  of the powell hybrid method. this is done by using the !  more general nonlinear equation solver hybrj. the user !  must provide a subroutine which calculates the functions !  and the jacobian. subroutine hybrj1 ( fcn , n , x , Fvec , Fjac , Ldfjac , Tol , Info , Wa , Lwa ) implicit none procedure ( fcn_hybrj ) :: fcn !! the user-supplied subroutine which !! calculates the functions and the jacobian integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of functions and variables. integer , intent ( in ) :: Ldfjac !! a positive integer input variable not less than n !! which specifies the leading dimension of the array fjac. integer , intent ( out ) :: Info !! an integer output variable. if the user has !! terminated execution, info is set to the (negative) !! value of iflag. see description of fcn. otherwise, !! info is set as follows: !! !!  * ***info = 0***   improper input parameters. !!  * ***info = 1***   algorithm estimates that the relative error !!    between x and the solution is at most tol. !!  * ***info = 2***   number of calls to fcn with iflag = 1 has !!    reached 100*(n+1). !!  * ***info = 3***   tol is too small. no further improvement in !!    the approximate solution x is possible. !!  * ***info = 4***   iteration is not making good progress. integer , intent ( in ) :: Lwa !! a positive integer input variable not less than !! (n*(n+13))/2. real ( wp ), intent ( in ) :: Tol !! a nonnegative input variable. termination occurs !! when the algorithm estimates that the relative error !! between x and the solution is at most tol. real ( wp ), intent ( inout ) :: x ( n ) !! an array of length n. on input x must contain !! an initial estimate of the solution vector. on output x !! contains the final estimate of the solution vector. real ( wp ), intent ( out ) :: Fvec ( n ) !! an output array of length n which contains !! the functions evaluated at the output x. real ( wp ), intent ( out ) :: Fjac ( Ldfjac , n ) !! an output n by n array which contains the !! orthogonal matrix q produced by the qr factorization !! of the final approximate jacobian. real ( wp ), intent ( inout ) :: Wa ( Lwa ) !! a work array of length lwa. integer :: j , lr , maxfev , mode , nfev , njev , nprint real ( wp ) :: xtol real ( wp ), parameter :: factor = 10 0.0_wp Info = 0 ! check the input parameters for errors. if ( n > 0 . and . Ldfjac >= n . and . Tol >= zero . and . Lwa >= ( n * ( n + 13 )) / 2 ) then ! call hybrj. maxfev = 100 * ( n + 1 ) xtol = Tol mode = 2 do j = 1 , n Wa ( j ) = one end do nprint = 0 lr = ( n * ( n + 1 )) / 2 call hybrj ( fcn , n , x , Fvec , Fjac , Ldfjac , xtol , maxfev , Wa ( 1 ), mode , & factor , nprint , Info , nfev , njev , Wa ( 6 * n + 1 ), lr , Wa ( n + 1 ), & Wa ( 2 * n + 1 ), Wa ( 3 * n + 1 ), Wa ( 4 * n + 1 ), Wa ( 5 * n + 1 )) if ( Info == 5 ) Info = 4 end if end subroutine hybrj1 !***************************************************************************************** !***************************************************************************************** !> !  the purpose of lmder is to minimize the sum of the squares of !  m nonlinear functions in n variables by a modification of !  the levenberg-marquardt algorithm. the user must provide a !  subroutine which calculates the functions and the jacobian. subroutine lmder ( fcn , m , n , x , Fvec , Fjac , Ldfjac , Ftol , Xtol , Gtol , Maxfev , & Diag , Mode , Factor , Nprint , Info , Nfev , Njev , Ipvt , Qtf , & Wa1 , Wa2 , Wa3 , Wa4 ) implicit none procedure ( fcn_lmder ) :: fcn !! the user-supplied subroutine which !! calculates the functions and the jacobian integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of functions. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of variables. n must not exceed m. integer , intent ( in ) :: Ldfjac !! a positive integer input variable not less than m !! which specifies the leading dimension of the array fjac. integer , intent ( in ) :: Maxfev !! a positive integer input variable. termination !! occurs when the number of calls to fcn with iflag = 1 !! has reached maxfev. integer , intent ( in ) :: Mode !! an integer input variable. if mode = 1, the !! variables will be scaled internally. if mode = 2, !! the scaling is specified by the input diag. other !! values of mode are equivalent to mode = 1. integer , intent ( in ) :: Nprint !! an integer input variable that enables controlled !! printing of iterates if it is positive. in this case, !! fcn is called with iflag = 0 at the beginning of the first !! iteration and every nprint iterations thereafter and !! immediately prior to return, with x, fvec, and fjac !! available for printing. fvec and fjac should not be !! altered. if nprint is not positive, no special calls !! of fcn with iflag = 0 are made. integer , intent ( out ) :: Info !! an integer output variable. if the user has !! terminated execution, info is set to the (negative) !! value of iflag. see description of fcn. otherwise, !! info is set as follows: !! !!  * ***info = 0***  improper input parameters. !!  * ***info = 1***  both actual and predicted relative reductions !!    in the sum of squares are at most ftol. !!  * ***info = 2***  relative error between two consecutive iterates !!    is at most xtol. !!  * ***info = 3***  conditions for info = 1 and info = 2 both hold. !!  * ***info = 4***  the cosine of the angle between fvec and any !!    column of the jacobian is at most gtol in !!    absolute value. !!  * ***info = 5***  number of calls to fcn with iflag = 1 has !!    reached maxfev. !!  * ***info = 6***  ftol is too small. no further reduction in !!    the sum of squares is possible. !!  * ***info = 7***  xtol is too small. no further improvement in !!    the approximate solution x is possible. !!  * ***info = 8***  gtol is too small. fvec is orthogonal to the !!    columns of the jacobian to machine precision. integer , intent ( out ) :: Nfev !! an integer output variable set to the number of !! calls to fcn with iflag = 1. integer , intent ( out ) :: Njev !! an integer output variable set to the number of !! calls to fcn with iflag = 2. integer , intent ( out ) :: Ipvt ( n ) !! an integer output array of length n. ipvt !! defines a permutation matrix p such that jac*p = q*r, !! where jac is the final calculated jacobian, q is !! orthogonal (not stored), and r is upper triangular !! with diagonal elements of nonincreasing magnitude. !! column j of p is column ipvt(j) of the identity matrix. real ( wp ), intent ( in ) :: Ftol !! a nonnegative input variable. termination !! occurs when both the actual and predicted relative !! reductions in the sum of squares are at most ftol. !! therefore, ftol measures the relative error desired !! in the sum of squares. real ( wp ), intent ( in ) :: Xtol !! a nonnegative input variable. termination !! occurs when the relative error between two consecutive !! iterates is at most xtol. therefore, xtol measures the !! relative error desired in the approximate solution. real ( wp ), intent ( in ) :: Gtol !! a nonnegative input variable. termination !! occurs when the cosine of the angle between fvec and !! any column of the jacobian is at most gtol in absolute !! value. therefore, gtol measures the orthogonality !! desired between the function vector and the columns !! of the jacobian. real ( wp ), intent ( in ) :: Factor !! a positive input variable used in determining the !! initial step bound. this bound is set to the product of !! factor and the euclidean norm of diag*x if nonzero, or else !! to factor itself. in most cases factor should lie in the !! interval (.1,100.).100. is a generally recommended value. real ( wp ), intent ( inout ) :: x ( n ) !! an array of length n. on input x must contain !! an initial estimate of the solution vector. on output x !! contains the final estimate of the solution vector. real ( wp ), intent ( out ) :: Fvec ( m ) !! an output array of length m which contains !! the functions evaluated at the output x. real ( wp ), intent ( out ) :: Fjac ( Ldfjac , n ) !! an output m by n array. the upper n by n submatrix !! of fjac contains an upper triangular matrix r with !! diagonal elements of nonincreasing magnitude such that !!``` !!        t     t           t !!       p *(jac *jac)*p = r *r, !!``` !! where p is a permutation matrix and jac is the final !! calculated jacobian. column j of p is column ipvt(j) !! (see below) of the identity matrix. the lower trapezoidal !! part of fjac contains information generated during !! the computation of r. real ( wp ), intent ( inout ) :: Diag ( n ) !! an array of length n. if mode = 1 (see !! below), diag is internally set. if mode = 2, diag !! must contain positive entries that serve as !! multiplicative scale factors for the variables. real ( wp ), intent ( out ) :: Qtf ( n ) !! an output array of length n which contains !! the first n elements of the vector (q transpose)*fvec. real ( wp ), intent ( inout ) :: Wa1 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa2 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa3 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa4 ( m ) !! work array of length n. integer :: i , iflag , iter , j , l real ( wp ) :: actred , delta , dirder , fnorm , fnorm1 , gnorm , par , & pnorm , prered , ratio , sum , temp , temp1 , temp2 , xnorm real ( wp ), parameter :: p1 = 1.0e-1_wp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p25 = 2.5e-1_wp real ( wp ), parameter :: p75 = 7.5e-1_wp real ( wp ), parameter :: p0001 = 1.0e-4_wp Info = 0 iflag = 0 Nfev = 0 Njev = 0 ! check the input parameters for errors. if ( n > 0 . and . m >= n . and . Ldfjac >= m . and . Ftol >= zero . and . & Xtol >= zero . and . Gtol >= zero . and . Maxfev > 0 . and . & Factor > zero ) then if ( Mode == 2 ) then do j = 1 , n if ( Diag ( j ) <= zero ) goto 100 end do end if ! evaluate the function at the starting point ! and calculate its norm. iflag = 1 call fcn ( m , n , x , Fvec , Fjac , Ldfjac , iflag ) Nfev = 1 if ( iflag >= 0 ) then fnorm = enorm ( m , Fvec ) ! initialize levenberg-marquardt parameter and iteration counter. par = zero iter = 1 ! beginning of the outer loop. ! calculate the jacobian matrix. 20 iflag = 2 call fcn ( m , n , x , Fvec , Fjac , Ldfjac , iflag ) Njev = Njev + 1 if ( iflag >= 0 ) then ! if requested, call fcn to enable printing of iterates. if ( Nprint > 0 ) then iflag = 0 if ( mod ( iter - 1 , Nprint ) == 0 ) & call fcn ( m , n , x , Fvec , Fjac , Ldfjac , iflag ) if ( iflag < 0 ) goto 100 end if ! compute the qr factorization of the jacobian. call qrfac ( m , n , Fjac , Ldfjac , . true ., Ipvt , n , Wa1 , Wa2 , Wa3 ) ! on the first iteration and if mode is 1, scale according ! to the norms of the columns of the initial jacobian. if ( iter == 1 ) then if ( Mode /= 2 ) then do j = 1 , n Diag ( j ) = Wa2 ( j ) if ( Wa2 ( j ) == zero ) Diag ( j ) = one end do end if ! on the first iteration, calculate the norm of the scaled x ! and initialize the step bound delta. do j = 1 , n Wa3 ( j ) = Diag ( j ) * x ( j ) end do xnorm = enorm ( n , Wa3 ) delta = Factor * xnorm if ( delta == zero ) delta = Factor end if ! form (q transpose)*fvec and store the first n components in ! qtf. do i = 1 , m Wa4 ( i ) = Fvec ( i ) end do do j = 1 , n if ( Fjac ( j , j ) /= zero ) then sum = zero do i = j , m sum = sum + Fjac ( i , j ) * Wa4 ( i ) end do temp = - sum / Fjac ( j , j ) do i = j , m Wa4 ( i ) = Wa4 ( i ) + Fjac ( i , j ) * temp end do end if Fjac ( j , j ) = Wa1 ( j ) Qtf ( j ) = Wa4 ( j ) end do ! compute the norm of the scaled gradient. gnorm = zero if ( fnorm /= zero ) then do j = 1 , n l = Ipvt ( j ) if ( Wa2 ( l ) /= zero ) then sum = zero do i = 1 , j sum = sum + Fjac ( i , j ) * ( Qtf ( i ) / fnorm ) end do gnorm = max ( gnorm , abs ( sum / Wa2 ( l ))) end if end do end if ! test for convergence of the gradient norm. if ( gnorm <= Gtol ) Info = 4 if ( Info == 0 ) then ! rescale if necessary. if ( Mode /= 2 ) then do j = 1 , n Diag ( j ) = max ( Diag ( j ), Wa2 ( j )) end do end if ! beginning of the inner loop. ! determine the levenberg-marquardt parameter. 25 call lmpar ( n , Fjac , Ldfjac , Ipvt , Diag , Qtf , delta , par , Wa1 , Wa2 , Wa3 , Wa4 ) ! store the direction p and x + p. calculate the norm of p. do j = 1 , n Wa1 ( j ) = - Wa1 ( j ) Wa2 ( j ) = x ( j ) + Wa1 ( j ) Wa3 ( j ) = Diag ( j ) * Wa1 ( j ) end do pnorm = enorm ( n , Wa3 ) ! on the first iteration, adjust the initial step bound. if ( iter == 1 ) delta = min ( delta , pnorm ) ! evaluate the function at x + p and calculate its norm. iflag = 1 call fcn ( m , n , Wa2 , Wa4 , Fjac , Ldfjac , iflag ) Nfev = Nfev + 1 if ( iflag >= 0 ) then fnorm1 = enorm ( m , Wa4 ) ! compute the scaled actual reduction. actred = - one if ( p1 * fnorm1 < fnorm ) actred = one - ( fnorm1 / fnorm ) ** 2 ! compute the scaled predicted reduction and ! the scaled directional derivative. do j = 1 , n Wa3 ( j ) = zero l = Ipvt ( j ) temp = Wa1 ( l ) do i = 1 , j Wa3 ( i ) = Wa3 ( i ) + Fjac ( i , j ) * temp end do end do temp1 = enorm ( n , Wa3 ) / fnorm temp2 = ( sqrt ( par ) * pnorm ) / fnorm prered = temp1 ** 2 + temp2 ** 2 / p5 dirder = - ( temp1 ** 2 + temp2 ** 2 ) ! compute the ratio of the actual to the predicted ! reduction. ratio = zero if ( prered /= zero ) ratio = actred / prered ! update the step bound. if ( ratio <= p25 ) then if ( actred >= zero ) temp = p5 if ( actred < zero ) temp = p5 * dirder / ( dirder + p5 * actred ) if ( p1 * fnorm1 >= fnorm . or . temp < p1 ) temp = p1 delta = temp * min ( delta , pnorm / p1 ) par = par / temp elseif ( par == zero . or . ratio >= p75 ) then delta = pnorm / p5 par = p5 * par end if ! test for successful iteration. if ( ratio >= p0001 ) then ! successful iteration. update x, fvec, and their norms. do j = 1 , n x ( j ) = Wa2 ( j ) Wa2 ( j ) = Diag ( j ) * x ( j ) end do do i = 1 , m Fvec ( i ) = Wa4 ( i ) end do xnorm = enorm ( n , Wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! tests for convergence. if ( abs ( actred ) <= Ftol . and . prered <= Ftol . and . p5 * ratio <= one ) Info = 1 if ( delta <= Xtol * xnorm ) Info = 2 if ( abs ( actred ) <= Ftol . and . prered <= Ftol . and . p5 * ratio <= one . and . Info == 2 ) Info = 3 if ( Info == 0 ) then ! tests for termination and stringent tolerances. if ( Nfev >= Maxfev ) Info = 5 if ( abs ( actred ) <= epsmch . and . prered <= epsmch . and . p5 * ratio <= one ) Info = 6 if ( delta <= epsmch * xnorm ) Info = 7 if ( gnorm <= epsmch ) Info = 8 if ( Info == 0 ) then ! end of the inner loop. repeat if iteration unsuccessful. ! end of the outer loop. if ( ratio >= p0001 ) goto 20 goto 25 end if end if end if end if end if end if end if ! termination, either normal or user imposed. 100 if ( iflag < 0 ) Info = iflag iflag = 0 if ( Nprint > 0 ) call fcn ( m , n , x , Fvec , Fjac , Ldfjac , iflag ) end subroutine lmder !***************************************************************************************** !***************************************************************************************** !> !  the purpose of lmder1 is to minimize the sum of the squares of !  m nonlinear functions in n variables by a modification of the !  levenberg-marquardt algorithm. this is done by using the more !  general least-squares solver lmder. the user must provide a !  subroutine which calculates the functions and the jacobian. subroutine lmder1 ( fcn , m , n , x , Fvec , Fjac , Ldfjac , Tol , Info , Ipvt , Wa , Lwa ) implicit none procedure ( fcn_lmder ) :: fcn !! user-supplied subroutine which !! calculates the functions and the jacobian. integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of functions. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of variables. n must not exceed m. integer , intent ( in ) :: Ldfjac !! a positive integer input variable not less than m !! which specifies the leading dimension of the array fjac. integer , intent ( out ) :: Info !! an integer output variable. if the user has !! terminated execution, info is set to the (negative) !! value of iflag. see description of fcn. otherwise, !! info is set as follows. !! !!  * ***info = 0***  improper input parameters. !!  * ***info = 1***  algorithm estimates that the relative error !!    in the sum of squares is at most tol. !!  * ***info = 2***  algorithm estimates that the relative error !!    between x and the solution is at most tol. !!  * ***info = 3***  conditions for info = 1 and info = 2 both hold. !!  * ***info = 4***  fvec is orthogonal to the columns of the !!    jacobian to machine precision. !!  * ***info = 5***  number of calls to fcn with iflag = 1 has !!    reached 100*(n+1). !!  * ***info = 6***  tol is too small. no further reduction in !!    the sum of squares is possible. !!  * ***info = 7***  tol is too small. no further improvement in !!    the approximate solution x is possible. integer , intent ( in ) :: Lwa !! a positive integer input variable not less than 5*n+m. integer , intent ( out ) :: Ipvt ( n ) !! an integer output array of length n. ipvt !! defines a permutation matrix p such that jac*p = q*r, !! where jac is the final calculated jacobian, q is !! orthogonal (not stored), and r is upper triangular !! with diagonal elements of nonincreasing magnitude. !! column j of p is column ipvt(j) of the identity matrix. real ( wp ), intent ( in ) :: Tol !! a nonnegative input variable. termination occurs !! when the algorithm estimates either that the relative !! error in the sum of squares is at most tol or that !! the relative error between x and the solution is at !! most tol. real ( wp ), intent ( inout ) :: x ( n ) !! an array of length n. on input x must contain !! an initial estimate of the solution vector. on output x !! contains the final estimate of the solution vector. real ( wp ), intent ( out ) :: Fvec ( m ) !! an output array of length m which contains !! the functions evaluated at the output x. real ( wp ), intent ( out ) :: Fjac ( Ldfjac , n ) !! an output m by n array. the upper n by n submatrix !! of fjac contains an upper triangular matrix r with !! diagonal elements of nonincreasing magnitude such that !!``` !!        t     t           t !!       p *(jac *jac)*p = r *r, !!``` !! where p is a permutation matrix and jac is the final !! calculated jacobian. column j of p is column ipvt(j) !! (see below) of the identity matrix. the lower trapezoidal !! part of fjac contains information generated during !! the computation of r. real ( wp ), intent ( inout ) :: Wa ( Lwa ) !! a work array of length lwa. integer :: maxfev , mode , nfev , njev , nprint real ( wp ) :: ftol , gtol , xtol real ( wp ), parameter :: factor = 10 0.0_wp Info = 0 ! check the input parameters for errors. if ( n > 0 . and . m >= n . and . Ldfjac >= m . and . Tol >= zero . and . & Lwa >= 5 * n + m ) then ! call lmder. maxfev = 100 * ( n + 1 ) ftol = Tol xtol = Tol gtol = zero mode = 1 nprint = 0 call lmder ( fcn , m , n , x , Fvec , Fjac , Ldfjac , ftol , xtol , gtol , maxfev , & & Wa ( 1 ), mode , factor , nprint , Info , nfev , njev , Ipvt , Wa ( n + 1 )& & , Wa ( 2 * n + 1 ), Wa ( 3 * n + 1 ), Wa ( 4 * n + 1 ), Wa ( 5 * n + 1 )) if ( Info == 8 ) Info = 4 end if end subroutine lmder1 !***************************************************************************************** !***************************************************************************************** !> !  the purpose of lmdif is to minimize the sum of the squares of !  m nonlinear functions in n variables by a modification of !  the levenberg-marquardt algorithm. the user must provide a !  subroutine which calculates the functions. the jacobian is !  then calculated by a forward-difference approximation. subroutine lmdif ( fcn , m , n , x , Fvec , Ftol , Xtol , Gtol , Maxfev , Epsfcn , Diag , & Mode , Factor , Nprint , Info , Nfev , Fjac , Ldfjac , Ipvt , & Qtf , Wa1 , Wa2 , Wa3 , Wa4 ) implicit none procedure ( func2 ) :: fcn !! the user-supplied subroutine which !! calculates the functions. integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of functions. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of variables. n must not exceed m. integer , intent ( in ) :: Maxfev !! a positive integer input variable. termination !! occurs when the number of calls to fcn is at least !! maxfev by the end of an iteration. integer , intent ( in ) :: Mode !! an integer input variable. if mode = 1, the !! variables will be scaled internally. if mode = 2, !! the scaling is specified by the input diag. other !! values of mode are equivalent to mode = 1. integer , intent ( in ) :: Nprint !! an integer input variable that enables controlled !! printing of iterates if it is positive. in this case, !! fcn is called with iflag = 0 at the beginning of the first !! iteration and every nprint iterations thereafter and !! immediately prior to return, with x and fvec available !! for printing. if nprint is not positive, no special calls !! of fcn with iflag = 0 are made. integer , intent ( out ) :: Info !! an integer output variable. if the user has !! terminated execution, info is set to the (negative) !! value of iflag. see description of fcn. otherwise, !! info is set as follows: !! !!  * ***info = 0***  improper input parameters. !!  * ***info = 1***  both actual and predicted relative reductions !!    in the sum of squares are at most ftol. !!  * ***info = 2***  relative error between two consecutive iterates !!    is at most xtol. !!  * ***info = 3***  conditions for info = 1 and info = 2 both hold. !!  * ***info = 4***  the cosine of the angle between fvec and any !!    column of the jacobian is at most gtol in !!    absolute value. !!  * ***info = 5***  number of calls to fcn has reached or !!    exceeded maxfev. !!  * ***info = 6***  ftol is too small. no further reduction in !!    the sum of squares is possible. !!  * ***info = 7***  xtol is too small. no further improvement in !!    the approximate solution x is possible. !!  * ***info = 8***  gtol is too small. fvec is orthogonal to the !!    columns of the jacobian to machine precision. integer , intent ( out ) :: Nfev !! an integer output variable set to the number of !! calls to fcn. integer , intent ( in ) :: Ldfjac !! a positive integer input variable not less than m !! which specifies the leading dimension of the array fjac. integer , intent ( out ) :: Ipvt ( n ) !! an integer output array of length n. ipvt !! defines a permutation matrix p such that jac*p = q*r, !! where jac is the final calculated jacobian, q is !! orthogonal (not stored), and r is upper triangular !! with diagonal elements of nonincreasing magnitude. !! column j of p is column ipvt(j) of the identity matrix. real ( wp ), intent ( in ) :: Ftol !! a nonnegative input variable. termination !! occurs when both the actual and predicted relative !! reductions in the sum of squares are at most ftol. !! therefore, ftol measures the relative error desired !! in the sum of squares. real ( wp ), intent ( in ) :: Xtol !! a nonnegative input variable. termination !! occurs when the relative error between two consecutive !! iterates is at most xtol. therefore, xtol measures the !! relative error desired in the approximate solution. real ( wp ), intent ( in ) :: Gtol !! a nonnegative input variable. termination !! occurs when the cosine of the angle between fvec and !! any column of the jacobian is at most gtol in absolute !! value. therefore, gtol measures the orthogonality !! desired between the function vector and the columns !! of the jacobian. real ( wp ), intent ( in ) :: Epsfcn !! an input variable used in determining a suitable !! step length for the forward-difference approximation. this !! approximation assumes that the relative errors in the !! functions are of the order of epsfcn. if epsfcn is less !! than the machine precision, it is assumed that the relative !! errors in the functions are of the order of the machine !! precision. real ( wp ), intent ( in ) :: Factor !! a positive input variable used in determining the !! initial step bound. this bound is set to the product of !! factor and the euclidean norm of diag*x if nonzero, or else !! to factor itself. in most cases factor should lie in the !! interval (.1,100.). 100. is a generally recommended value. real ( wp ), intent ( inout ) :: x ( n ) !!  an array of length n. on input x must contain !! an initial estimate of the solution vector. on output x !! contains the final estimate of the solution vector. real ( wp ), intent ( out ) :: Fvec ( m ) !! an output array of length m which contains !! the functions evaluated at the output x. real ( wp ), intent ( inout ) :: Diag ( n ) !! an array of length n. if mode = 1 (see !! below), diag is internally set. if mode = 2, diag !! must contain positive entries that serve as !! multiplicative scale factors for the variables. real ( wp ), intent ( out ) :: Fjac ( Ldfjac , n ) !! an output m by n array. the upper n by n submatrix !! of fjac contains an upper triangular matrix r with !! diagonal elements of nonincreasing magnitude such that !!``` !!        t     t           t !!       p *(jac *jac)*p = r *r, !!``` !! where p is a permutation matrix and jac is the final !! calculated jacobian. column j of p is column ipvt(j) !! (see below) of the identity matrix. the lower trapezoidal !! part of fjac contains information generated during !! the computation of r. real ( wp ), intent ( out ) :: Qtf ( n ) !! an output array of length n which contains !! the first n elements of the vector (q transpose)*fvec. real ( wp ), intent ( inout ) :: Wa1 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa2 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa3 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa4 ( m ) !! work array of length n. integer :: i , iflag , iter , j , l real ( wp ) :: actred , delta , dirder , fnorm , & fnorm1 , gnorm , par , pnorm , prered , & ratio , sum , temp , temp1 , temp2 , xnorm real ( wp ), parameter :: p1 = 1.0e-1_wp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p25 = 2.5e-1_wp real ( wp ), parameter :: p75 = 7.5e-1_wp real ( wp ), parameter :: p0001 = 1.0e-4_wp Info = 0 iflag = 0 Nfev = 0 ! check the input parameters for errors. if ( n > 0 . and . m >= n . and . Ldfjac >= m . and . Ftol >= zero . and . & Xtol >= zero . and . Gtol >= zero . and . Maxfev > 0 . and . & Factor > zero ) then if ( Mode == 2 ) then do j = 1 , n if ( Diag ( j ) <= zero ) goto 100 end do end if ! evaluate the function at the starting point ! and calculate its norm. iflag = 1 call fcn ( m , n , x , Fvec , iflag ) Nfev = 1 if ( iflag >= 0 ) then fnorm = enorm ( m , Fvec ) ! initialize levenberg-marquardt parameter and iteration counter. par = zero iter = 1 ! beginning of the outer loop. ! calculate the jacobian matrix. 20 iflag = 2 call fdjac2 ( fcn , m , n , x , Fvec , Fjac , Ldfjac , iflag , Epsfcn , Wa4 ) Nfev = Nfev + n if ( iflag >= 0 ) then ! if requested, call fcn to enable printing of iterates. if ( Nprint > 0 ) then iflag = 0 if ( mod ( iter - 1 , Nprint ) == 0 ) & call fcn ( m , n , x , Fvec , iflag ) if ( iflag < 0 ) goto 100 end if ! compute the qr factorization of the jacobian. call qrfac ( m , n , Fjac , Ldfjac , . true ., Ipvt , n , Wa1 , Wa2 , Wa3 ) ! on the first iteration and if mode is 1, scale according ! to the norms of the columns of the initial jacobian. if ( iter == 1 ) then if ( Mode /= 2 ) then do j = 1 , n Diag ( j ) = Wa2 ( j ) if ( Wa2 ( j ) == zero ) Diag ( j ) = one end do end if ! on the first iteration, calculate the norm of the scaled x ! and initialize the step bound delta. do j = 1 , n Wa3 ( j ) = Diag ( j ) * x ( j ) end do xnorm = enorm ( n , Wa3 ) delta = Factor * xnorm if ( delta == zero ) delta = Factor end if ! form (q transpose)*fvec and store the first n components in ! qtf. do i = 1 , m Wa4 ( i ) = Fvec ( i ) end do do j = 1 , n if ( Fjac ( j , j ) /= zero ) then sum = zero do i = j , m sum = sum + Fjac ( i , j ) * Wa4 ( i ) end do temp = - sum / Fjac ( j , j ) do i = j , m Wa4 ( i ) = Wa4 ( i ) + Fjac ( i , j ) * temp end do end if Fjac ( j , j ) = Wa1 ( j ) Qtf ( j ) = Wa4 ( j ) end do ! compute the norm of the scaled gradient. gnorm = zero if ( fnorm /= zero ) then do j = 1 , n l = Ipvt ( j ) if ( Wa2 ( l ) /= zero ) then sum = zero do i = 1 , j sum = sum + Fjac ( i , j ) * ( Qtf ( i ) / fnorm ) end do gnorm = max ( gnorm , abs ( sum / Wa2 ( l ))) end if end do end if ! test for convergence of the gradient norm. if ( gnorm <= Gtol ) Info = 4 if ( Info == 0 ) then ! rescale if necessary. if ( Mode /= 2 ) then do j = 1 , n Diag ( j ) = max ( Diag ( j ), Wa2 ( j )) end do end if ! beginning of the inner loop. ! determine the levenberg-marquardt parameter. 25 call lmpar ( n , Fjac , Ldfjac , Ipvt , Diag , Qtf , delta , par , Wa1 , & Wa2 , Wa3 , Wa4 ) ! store the direction p and x + p. calculate the norm of p. do j = 1 , n Wa1 ( j ) = - Wa1 ( j ) Wa2 ( j ) = x ( j ) + Wa1 ( j ) Wa3 ( j ) = Diag ( j ) * Wa1 ( j ) end do pnorm = enorm ( n , Wa3 ) ! on the first iteration, adjust the initial step bound. if ( iter == 1 ) delta = min ( delta , pnorm ) ! evaluate the function at x + p and calculate its norm. iflag = 1 call fcn ( m , n , Wa2 , Wa4 , iflag ) Nfev = Nfev + 1 if ( iflag >= 0 ) then fnorm1 = enorm ( m , Wa4 ) ! compute the scaled actual reduction. actred = - one if ( p1 * fnorm1 < fnorm ) actred = one - ( fnorm1 / fnorm ) ** 2 ! compute the scaled predicted reduction and ! the scaled directional derivative. do j = 1 , n Wa3 ( j ) = zero l = Ipvt ( j ) temp = Wa1 ( l ) do i = 1 , j Wa3 ( i ) = Wa3 ( i ) + Fjac ( i , j ) * temp end do end do temp1 = enorm ( n , Wa3 ) / fnorm temp2 = ( sqrt ( par ) * pnorm ) / fnorm prered = temp1 ** 2 + temp2 ** 2 / p5 dirder = - ( temp1 ** 2 + temp2 ** 2 ) ! compute the ratio of the actual to the predicted ! reduction. ratio = zero if ( prered /= zero ) ratio = actred / prered ! update the step bound. if ( ratio <= p25 ) then if ( actred >= zero ) temp = p5 if ( actred < zero ) & temp = p5 * dirder / ( dirder + p5 * actred ) if ( p1 * fnorm1 >= fnorm . or . temp < p1 ) temp = p1 delta = temp * min ( delta , pnorm / p1 ) par = par / temp elseif ( par == zero . or . ratio >= p75 ) then delta = pnorm / p5 par = p5 * par end if ! test for successful iteration. if ( ratio >= p0001 ) then ! successful iteration. update x, fvec, and their norms. do j = 1 , n x ( j ) = Wa2 ( j ) Wa2 ( j ) = Diag ( j ) * x ( j ) end do do i = 1 , m Fvec ( i ) = Wa4 ( i ) end do xnorm = enorm ( n , Wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! tests for convergence. if ( abs ( actred ) <= Ftol . and . prered <= Ftol . and . & p5 * ratio <= one ) Info = 1 if ( delta <= Xtol * xnorm ) Info = 2 if ( abs ( actred ) <= Ftol . and . prered <= Ftol . and . & p5 * ratio <= one . and . Info == 2 ) Info = 3 if ( Info == 0 ) then ! tests for termination and stringent tolerances. if ( Nfev >= Maxfev ) Info = 5 if ( abs ( actred ) <= epsmch . and . & prered <= epsmch . and . p5 * ratio <= one ) & Info = 6 if ( delta <= epsmch * xnorm ) Info = 7 if ( gnorm <= epsmch ) Info = 8 if ( Info == 0 ) then ! end of the inner loop. repeat if iteration unsuccessful. ! end of the outer loop. if ( ratio >= p0001 ) goto 20 goto 25 end if end if end if end if end if end if end if ! termination, either normal or user imposed. 100 if ( iflag < 0 ) Info = iflag iflag = 0 if ( Nprint > 0 ) call fcn ( m , n , x , Fvec , iflag ) end subroutine lmdif !***************************************************************************************** !***************************************************************************************** !> !  the purpose of lmdif1 is to minimize the sum of the squares of !  m nonlinear functions in n variables by a modification of the !  levenberg-marquardt algorithm. this is done by using the more !  general least-squares solver lmdif. the user must provide a !  subroutine which calculates the functions. the jacobian is !  then calculated by a forward-difference approximation. subroutine lmdif1 ( fcn , m , n , x , Fvec , Tol , Info , Iwa , Wa , Lwa ) implicit none procedure ( func2 ) :: fcn !! the user-supplied subroutine which !! calculates the functions. integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of functions. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of variables. n must not exceed m. integer , intent ( out ) :: Info !! an integer output variable. if the user has !! terminated execution, info is set to the (negative) !! value of iflag. see description of fcn. otherwise, !! info is set as follows: !! !!  * ***info = 0***  improper input parameters. !!  * ***info = 1***  algorithm estimates that the relative error !!    in the sum of squares is at most tol. !!  * ***info = 2***  algorithm estimates that the relative error !!    between x and the solution is at most tol. !!  * ***info = 3***  conditions for info = 1 and info = 2 both hold. !!  * ***info = 4***  fvec is orthogonal to the columns of the !!    jacobian to machine precision. !!  * ***info = 5***  number of calls to fcn has reached or !!    exceeded 200*(n+1). !!  * ***info = 6***  tol is too small. no further reduction in !!    the sum of squares is possible. !!  * ***info = 7***  tol is too small. no further improvement in !!    the approximate solution x is possible. integer , intent ( in ) :: Lwa !! a positive integer input variable not less than !! m*n+5*n+m. integer , intent ( inout ) :: Iwa ( n ) !! an integer work array of length n. real ( wp ), intent ( in ) :: Tol !! a nonnegative input variable. termination occurs !! when the algorithm estimates either that the relative !! error in the sum of squares is at most tol or that !! the relative error between x and the solution is at !! most tol. real ( wp ), intent ( inout ) :: x ( n ) !! an array of length n. on input x must contain !! an initial estimate of the solution vector. on output x !! contains the final estimate of the solution vector. real ( wp ), intent ( out ) :: Fvec ( m ) !! an output array of length m which contains !! the functions evaluated at the output x. real ( wp ), intent ( inout ) :: Wa ( Lwa ) !! a work array of length lwa. integer :: maxfev , mode , mp5n , nfev , nprint real ( wp ) :: epsfcn , ftol , gtol , xtol real ( wp ), parameter :: factor = 1.0e2_wp Info = 0 ! check the input parameters for errors. if ( n > 0 . and . m >= n . and . Tol >= zero . and . Lwa >= m * n + 5 * n + m ) then ! call lmdif. maxfev = 200 * ( n + 1 ) ftol = Tol xtol = Tol gtol = zero epsfcn = zero mode = 1 nprint = 0 mp5n = m + 5 * n call lmdif ( fcn , m , n , x , Fvec , ftol , xtol , gtol , maxfev , epsfcn , Wa ( 1 ), & mode , factor , nprint , Info , nfev , Wa ( mp5n + 1 ), m , Iwa , & Wa ( n + 1 ), Wa ( 2 * n + 1 ), Wa ( 3 * n + 1 ), Wa ( 4 * n + 1 ), Wa ( 5 * n + 1 )) if ( Info == 8 ) Info = 4 end if end subroutine lmdif1 !***************************************************************************************** !***************************************************************************************** !> !  given an m by n matrix a, an n by n nonsingular diagonal !  matrix d, an m-vector b, and a positive number delta, !  the problem is to determine a value for the parameter !  par such that if x solves the system !``` !        a*x = b ,     sqrt(par)*d*x = 0 , !``` !  in the least squares sense, and dxnorm is the euclidean !  norm of d*x, then either par is zero and !``` !        (dxnorm-delta) <= 0.1*delta , !``` !  or par is positive and !``` !        abs(dxnorm-delta) <= 0.1*delta . !``` !  this subroutine completes the solution of the problem !  if it is provided with the necessary information from the !  qr factorization, with column pivoting, of a. that is, if !  a*p = q*r, where p is a permutation matrix, q has orthogonal !  columns, and r is an upper triangular matrix with diagonal !  elements of nonincreasing magnitude, then lmpar expects !  the full upper triangle of r, the permutation matrix p, !  and the first n components of (q transpose)*b. on output !  lmpar also provides an upper triangular matrix s such that !``` !         t   t                   t !        p *(a *a + par*d*d)*p = s *s . !``` !  s is employed within lmpar and may be of separate interest. ! !  only a few iterations are generally needed for convergence !  of the algorithm. if, however, the limit of 10 iterations !  is reached, then the output par will contain the best !  value obtained so far. subroutine lmpar ( n , r , Ldr , Ipvt , Diag , Qtb , Delta , Par , x , Sdiag , Wa1 , Wa2 ) implicit none integer , intent ( in ) :: n !! a positive integer input variable set to the order of r. integer , intent ( in ) :: Ldr !! a positive integer input variable not less than n !! which specifies the leading dimension of the array r. integer , intent ( in ) :: Ipvt ( n ) !! an integer input array of length n which defines the !! permutation matrix p such that a*p = q*r. column j of p !! is column ipvt(j) of the identity matrix. real ( wp ) :: Delta !! a positive input variable which specifies an upper !! bound on the euclidean norm of d*x. real ( wp ), intent ( inout ) :: Par !! a nonnegative variable. on input par contains an !! initial estimate of the levenberg-marquardt parameter. !! on output par contains the final estimate. real ( wp ), intent ( inout ) :: r ( Ldr , n ) !! an n by n array. on input the full upper triangle !! must contain the full upper triangle of the matrix r. !! on output the full upper triangle is unaltered, and the !! strict lower triangle contains the strict upper triangle !! (transposed) of the upper triangular matrix s. real ( wp ), intent ( in ) :: Diag ( n ) !! an input array of length n which must contain the !! diagonal elements of the matrix d. real ( wp ), intent ( in ) :: Qtb ( n ) !! an input array of length n which must contain the first !! n elements of the vector (q transpose)*b. real ( wp ), intent ( out ) :: x ( n ) !! an output array of length n which contains the least !! squares solution of the system a*x = b, sqrt(par)*d*x = 0, !! for the output par. real ( wp ), intent ( out ) :: Sdiag ( n ) !! an output array of length n which contains the !! diagonal elements of the upper triangular matrix s. real ( wp ), intent ( inout ) :: Wa1 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa2 ( n ) !! work array of length n. integer :: i , iter , j , jm1 , jp1 , k , l , nsing real ( wp ) :: dxnorm , fp , gnorm , parc , parl , paru , sum , temp real ( wp ), parameter :: p1 = 1.0e-1_wp real ( wp ), parameter :: p001 = 1.0e-3_wp real ( wp ), parameter :: dwarf = dpmpar ( 2 ) !! the smallest positive magnitude ! compute and store in x the gauss-newton direction. if the ! jacobian is rank-deficient, obtain a least squares solution. nsing = n do j = 1 , n Wa1 ( j ) = Qtb ( j ) if ( r ( j , j ) == zero . and . nsing == n ) nsing = j - 1 if ( nsing < n ) Wa1 ( j ) = zero end do if ( nsing >= 1 ) then do k = 1 , nsing j = nsing - k + 1 Wa1 ( j ) = Wa1 ( j ) / r ( j , j ) temp = Wa1 ( j ) jm1 = j - 1 if ( jm1 >= 1 ) then do i = 1 , jm1 Wa1 ( i ) = Wa1 ( i ) - r ( i , j ) * temp end do end if end do end if do j = 1 , n l = Ipvt ( j ) x ( l ) = Wa1 ( j ) end do ! initialize the iteration counter. ! evaluate the function at the origin, and test ! for acceptance of the gauss-newton direction. iter = 0 do j = 1 , n Wa2 ( j ) = Diag ( j ) * x ( j ) end do dxnorm = enorm ( n , Wa2 ) fp = dxnorm - Delta if ( fp <= p1 * Delta ) then ! termination. if ( iter == 0 ) Par = zero else ! if the jacobian is not rank deficient, the newton ! step provides a lower bound, parl, for the zero of ! the function. otherwise set this bound to zero. parl = zero if ( nsing >= n ) then do j = 1 , n l = Ipvt ( j ) Wa1 ( j ) = Diag ( l ) * ( Wa2 ( l ) / dxnorm ) end do do j = 1 , n sum = zero jm1 = j - 1 if ( jm1 >= 1 ) then do i = 1 , jm1 sum = sum + r ( i , j ) * Wa1 ( i ) end do end if Wa1 ( j ) = ( Wa1 ( j ) - sum ) / r ( j , j ) end do temp = enorm ( n , Wa1 ) parl = (( fp / Delta ) / temp ) / temp end if ! calculate an upper bound, paru, for the zero of the function. do j = 1 , n sum = zero do i = 1 , j sum = sum + r ( i , j ) * Qtb ( i ) end do l = Ipvt ( j ) Wa1 ( j ) = sum / Diag ( l ) end do gnorm = enorm ( n , Wa1 ) paru = gnorm / Delta if ( paru == zero ) paru = dwarf / min ( Delta , p1 ) ! if the input par lies outside of the interval (parl,paru), ! set par to the closer endpoint. Par = max ( Par , parl ) Par = min ( Par , paru ) if ( Par == zero ) Par = gnorm / dxnorm ! beginning of an iteration. 50 iter = iter + 1 ! evaluate the function at the current value of par. if ( Par == zero ) Par = max ( dwarf , p001 * paru ) temp = sqrt ( Par ) do j = 1 , n Wa1 ( j ) = temp * Diag ( j ) end do call qrsolv ( n , r , Ldr , Ipvt , Wa1 , Qtb , x , Sdiag , Wa2 ) do j = 1 , n Wa2 ( j ) = Diag ( j ) * x ( j ) end do dxnorm = enorm ( n , Wa2 ) temp = fp fp = dxnorm - Delta ! if the function is small enough, accept the current value ! of par. also test for the exceptional cases where parl ! is zero or the number of iterations has reached 10. if ( abs ( fp ) <= p1 * Delta . or . parl == zero . and . fp <= temp . and . & temp < zero . or . iter == 10 ) then if ( iter == 0 ) Par = zero else ! compute the newton correction. do j = 1 , n l = Ipvt ( j ) Wa1 ( j ) = Diag ( l ) * ( Wa2 ( l ) / dxnorm ) end do do j = 1 , n Wa1 ( j ) = Wa1 ( j ) / Sdiag ( j ) temp = Wa1 ( j ) jp1 = j + 1 if ( n >= jp1 ) then do i = jp1 , n Wa1 ( i ) = Wa1 ( i ) - r ( i , j ) * temp end do end if end do temp = enorm ( n , Wa1 ) parc = (( fp / Delta ) / temp ) / temp ! depending on the sign of the function, update parl or paru. if ( fp > zero ) parl = max ( parl , Par ) if ( fp < zero ) paru = min ( paru , Par ) ! compute an improved estimate for par. Par = max ( parl , Par + parc ) ! end of an iteration. goto 50 end if end if end subroutine lmpar !***************************************************************************************** !***************************************************************************************** !> !  the purpose of lmstr is to minimize the sum of the squares of !  m nonlinear functions in n variables by a modification of !  the levenberg-marquardt algorithm which uses minimal storage. !  the user must provide a subroutine which calculates the !  functions and the rows of the jacobian. subroutine lmstr ( fcn , m , n , x , Fvec , Fjac , Ldfjac , Ftol , Xtol , Gtol , Maxfev , & Diag , Mode , Factor , Nprint , Info , Nfev , Njev , Ipvt , Qtf , & Wa1 , Wa2 , Wa3 , Wa4 ) implicit none procedure ( fcn_lmstr ) :: fcn !! user-supplied subroutine which !! calculates the functions and the rows of the jacobian. integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of functions. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of variables. n must not exceed m. integer , intent ( in ) :: Ldfjac !! a positive integer input variable not less than n !! which specifies the leading dimension of the array fjac. integer , intent ( in ) :: Maxfev !! a positive integer input variable. termination !! occurs when the number of calls to fcn with iflag = 1 !! has reached maxfev. integer , intent ( in ) :: Mode !! an integer input variable. if mode = 1, the !! variables will be scaled internally. if mode = 2, !! the scaling is specified by the input diag. other !! values of mode are equivalent to mode = 1. integer , intent ( in ) :: Nprint !! an integer input variable that enables controlled !! printing of iterates if it is positive. in this case, !! fcn is called with iflag = 0 at the beginning of the first !! iteration and every nprint iterations thereafter and !! immediately prior to return, with x and fvec available !! for printing. if nprint is not positive, no special calls !! of fcn with iflag = 0 are made. integer , intent ( out ) :: Info !! an integer output variable. if the user has !! terminated execution, info is set to the (negative) !! value of iflag. see description of fcn. otherwise, !! info is set as follows: !! !!  * ***info = 0***  improper input parameters. !!  * ***info = 1***  both actual and predicted relative reductions !!    in the sum of squares are at most ftol. !!  * ***info = 2***  relative error between two consecutive iterates !!    is at most xtol. !!  * ***info = 3***  conditions for info = 1 and info = 2 both hold. !!  * ***info = 4***  the cosine of the angle between fvec and any !!    column of the jacobian is at most gtol in !!    absolute value. !!  * ***info = 5***  number of calls to fcn with iflag = 1 has !!    reached maxfev. !!  * ***info = 6***  ftol is too small. no further reduction in !!    the sum of squares is possible. !!  * ***info = 7***  xtol is too small. no further improvement in !!    the approximate solution x is possible. !!  * ***info = 8***  gtol is too small. fvec is orthogonal to the !!    columns of the jacobian to machine precision. integer , intent ( out ) :: Nfev !! an integer output variable set to the number of !! calls to fcn with iflag = 1. integer , intent ( out ) :: Njev !! an integer output variable set to the number of !! calls to fcn with iflag = 2. integer , intent ( out ) :: Ipvt ( n ) !! an integer output array of length n. ipvt !! defines a permutation matrix p such that jac*p = q*r, !! where jac is the final calculated jacobian, q is !! orthogonal (not stored), and r is upper triangular. !! column j of p is column ipvt(j) of the identity matrix. real ( wp ), intent ( in ) :: Ftol !! a nonnegative input variable. termination !! occurs when both the actual and predicted relative !! reductions in the sum of squares are at most ftol. !! therefore, ftol measures the relative error desired !! in the sum of squares. real ( wp ), intent ( in ) :: Xtol !! a nonnegative input variable. termination !! occurs when the relative error between two consecutive !! iterates is at most xtol. therefore, xtol measures the !! relative error desired in the approximate solution. real ( wp ), intent ( in ) :: Gtol !! a nonnegative input variable. termination !! occurs when the cosine of the angle between fvec and !! any column of the jacobian is at most gtol in absolute !! value. therefore, gtol measures the orthogonality !! desired between the function vector and the columns !! of the jacobian. real ( wp ), intent ( in ) :: Factor !! a positive input variable used in determining the !! initial step bound. this bound is set to the product of !! factor and the euclidean norm of diag*x if nonzero, or else !! to factor itself. in most cases factor should lie in the !! interval (.1,100.). 100. is a generally recommended value. real ( wp ), intent ( inout ) :: x ( n ) !! an array of length n. on input x must contain !! an initial estimate of the solution vector. on output x !! contains the final estimate of the solution vector. real ( wp ), intent ( out ) :: Fvec ( m ) !! an output array of length m which contains !! the functions evaluated at the output x. real ( wp ), intent ( out ) :: Fjac ( Ldfjac , n ) !! an output n by n array. the upper triangle of fjac !! contains an upper triangular matrix r such that !!``` !!        t     t           t !!       p *(jac *jac)*p = r *r, !!``` !! where p is a permutation matrix and jac is the final !! calculated jacobian. column j of p is column ipvt(j) !! (see below) of the identity matrix. the lower triangular !! part of fjac contains information generated during !! the computation of r. real ( wp ), intent ( inout ) :: Diag ( n ) !! an array of length n. if mode = 1 (see !! below), diag is internally set. if mode = 2, diag !! must contain positive entries that serve as !! multiplicative scale factors for the variables. real ( wp ), intent ( out ) :: Qtf ( n ) !! an output array of length n which contains !! the first n elements of the vector (q transpose)*fvec. real ( wp ), intent ( inout ) :: Wa1 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa2 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa3 ( n ) !! work array of length n. real ( wp ), intent ( inout ) :: Wa4 ( m ) !! work array of length m. integer :: i , iflag , iter , j , l real ( wp ) :: actred , delta , dirder , fnorm , & fnorm1 , gnorm , par , pnorm , prered , & ratio , sum , temp , temp1 , temp2 , xnorm logical :: sing real ( wp ), parameter :: p1 = 1.0e-1_wp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p25 = 2.5e-1_wp real ( wp ), parameter :: p75 = 7.5e-1_wp real ( wp ), parameter :: p0001 = 1.0e-4_wp Info = 0 iflag = 0 Nfev = 0 Njev = 0 ! check the input parameters for errors. if ( n <= 0 . or . m < n . or . Ldfjac < n . or . Ftol < zero . or . & Xtol < zero . or . Gtol < zero . or . Maxfev <= 0 . or . Factor <= zero ) & goto 200 if ( Mode == 2 ) then do j = 1 , n if ( Diag ( j ) <= zero ) goto 200 end do end if ! evaluate the function at the starting point ! and calculate its norm. iflag = 1 call fcn ( m , n , x , Fvec , Wa3 , iflag ) Nfev = 1 if ( iflag < 0 ) goto 200 fnorm = enorm ( m , Fvec ) ! initialize levenberg-marquardt parameter and iteration counter. par = zero iter = 1 ! beginning of the outer loop. ! if requested, call fcn to enable printing of iterates. 100 if ( Nprint > 0 ) then iflag = 0 if ( mod ( iter - 1 , Nprint ) == 0 ) call fcn ( m , n , x , Fvec , Wa3 , iflag ) if ( iflag < 0 ) goto 200 end if ! compute the qr factorization of the jacobian matrix ! calculated one row at a time, while simultaneously ! forming (q transpose)*fvec and storing the first ! n components in qtf. do j = 1 , n Qtf ( j ) = zero do i = 1 , n Fjac ( i , j ) = zero end do end do iflag = 2 do i = 1 , m call fcn ( m , n , x , Fvec , Wa3 , iflag ) if ( iflag < 0 ) goto 200 temp = Fvec ( i ) call rwupdt ( n , Fjac , Ldfjac , Wa3 , Qtf , temp , Wa1 , Wa2 ) iflag = iflag + 1 end do Njev = Njev + 1 ! if the jacobian is rank deficient, call qrfac to ! reorder its columns and update the components of qtf. sing = . false . do j = 1 , n if ( Fjac ( j , j ) == zero ) sing = . true . Ipvt ( j ) = j Wa2 ( j ) = enorm ( j , Fjac ( 1 , j )) end do if ( sing ) then call qrfac ( n , n , Fjac , Ldfjac , . true ., Ipvt , n , Wa1 , Wa2 , Wa3 ) do j = 1 , n if ( Fjac ( j , j ) /= zero ) then sum = zero do i = j , n sum = sum + Fjac ( i , j ) * Qtf ( i ) end do temp = - sum / Fjac ( j , j ) do i = j , n Qtf ( i ) = Qtf ( i ) + Fjac ( i , j ) * temp end do end if Fjac ( j , j ) = Wa1 ( j ) end do end if ! on the first iteration and if mode is 1, scale according ! to the norms of the columns of the initial jacobian. if ( iter == 1 ) then if ( Mode /= 2 ) then do j = 1 , n Diag ( j ) = Wa2 ( j ) if ( Wa2 ( j ) == zero ) Diag ( j ) = one end do end if ! on the first iteration, calculate the norm of the scaled x ! and initialize the step bound delta. do j = 1 , n Wa3 ( j ) = Diag ( j ) * x ( j ) end do xnorm = enorm ( n , Wa3 ) delta = Factor * xnorm if ( delta == zero ) delta = Factor end if ! compute the norm of the scaled gradient. gnorm = zero if ( fnorm /= zero ) then do j = 1 , n l = Ipvt ( j ) if ( Wa2 ( l ) /= zero ) then sum = zero do i = 1 , j sum = sum + Fjac ( i , j ) * ( Qtf ( i ) / fnorm ) end do gnorm = max ( gnorm , abs ( sum / Wa2 ( l ))) end if end do end if ! test for convergence of the gradient norm. if ( gnorm <= Gtol ) Info = 4 if ( Info == 0 ) then ! rescale if necessary. if ( Mode /= 2 ) then do j = 1 , n Diag ( j ) = max ( Diag ( j ), Wa2 ( j )) end do end if ! beginning of the inner loop. ! determine the levenberg-marquardt parameter. 150 call lmpar ( n , Fjac , Ldfjac , Ipvt , Diag , Qtf , delta , par , Wa1 , Wa2 , Wa3 , Wa4 ) ! store the direction p and x + p. calculate the norm of p. do j = 1 , n Wa1 ( j ) = - Wa1 ( j ) Wa2 ( j ) = x ( j ) + Wa1 ( j ) Wa3 ( j ) = Diag ( j ) * Wa1 ( j ) end do pnorm = enorm ( n , Wa3 ) ! on the first iteration, adjust the initial step bound. if ( iter == 1 ) delta = min ( delta , pnorm ) ! evaluate the function at x + p and calculate its norm. iflag = 1 call fcn ( m , n , Wa2 , Wa4 , Wa3 , iflag ) Nfev = Nfev + 1 if ( iflag >= 0 ) then fnorm1 = enorm ( m , Wa4 ) ! compute the scaled actual reduction. actred = - one if ( p1 * fnorm1 < fnorm ) actred = one - ( fnorm1 / fnorm ) ** 2 ! compute the scaled predicted reduction and ! the scaled directional derivative. do j = 1 , n Wa3 ( j ) = zero l = Ipvt ( j ) temp = Wa1 ( l ) do i = 1 , j Wa3 ( i ) = Wa3 ( i ) + Fjac ( i , j ) * temp end do end do temp1 = enorm ( n , Wa3 ) / fnorm temp2 = ( sqrt ( par ) * pnorm ) / fnorm prered = temp1 ** 2 + temp2 ** 2 / p5 dirder = - ( temp1 ** 2 + temp2 ** 2 ) ! compute the ratio of the actual to the predicted ! reduction. ratio = zero if ( prered /= zero ) ratio = actred / prered ! update the step bound. if ( ratio <= p25 ) then if ( actred >= zero ) temp = p5 if ( actred < zero ) temp = p5 * dirder / ( dirder + p5 * actred ) if ( p1 * fnorm1 >= fnorm . or . temp < p1 ) temp = p1 delta = temp * min ( delta , pnorm / p1 ) par = par / temp elseif ( par == zero . or . ratio >= p75 ) then delta = pnorm / p5 par = p5 * par end if ! test for successful iteration. if ( ratio >= p0001 ) then ! successful iteration. update x, fvec, and their norms. do j = 1 , n x ( j ) = Wa2 ( j ) Wa2 ( j ) = Diag ( j ) * x ( j ) end do do i = 1 , m Fvec ( i ) = Wa4 ( i ) end do xnorm = enorm ( n , Wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! tests for convergence. if ( abs ( actred ) <= Ftol . and . prered <= Ftol . and . & p5 * ratio <= one ) Info = 1 if ( delta <= Xtol * xnorm ) Info = 2 if ( abs ( actred ) <= Ftol . and . prered <= Ftol . and . & p5 * ratio <= one . and . Info == 2 ) Info = 3 if ( Info == 0 ) then ! tests for termination and stringent tolerances. if ( Nfev >= Maxfev ) Info = 5 if ( abs ( actred ) <= epsmch . and . prered <= epsmch . and . & p5 * ratio <= one ) Info = 6 if ( delta <= epsmch * xnorm ) Info = 7 if ( gnorm <= epsmch ) Info = 8 if ( Info == 0 ) then ! end of the inner loop. repeat if iteration unsuccessful. ! end of the outer loop. if ( ratio >= p0001 ) goto 100 goto 150 end if end if end if end if ! termination, either normal or user imposed. 200 if ( iflag < 0 ) Info = iflag iflag = 0 if ( Nprint > 0 ) call fcn ( m , n , x , Fvec , Wa3 , iflag ) end subroutine lmstr !***************************************************************************************** !***************************************************************************************** !> !  the purpose of lmstr1 is to minimize the sum of the squares of !  m nonlinear functions in n variables by a modification of !  the levenberg-marquardt algorithm which uses minimal storage. !  this is done by using the more general least-squares solver !  lmstr. the user must provide a subroutine which calculates !  the functions and the rows of the jacobian. subroutine lmstr1 ( fcn , m , n , x , Fvec , Fjac , Ldfjac , Tol , Info , Ipvt , Wa , Lwa ) implicit none procedure ( fcn_lmstr ) :: fcn !! user-supplied subroutine which !! calculates the functions and the rows of the jacobian. integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of functions. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of variables. n must not exceed m. integer , intent ( in ) :: Ldfjac !! a positive integer input variable not less than n !! which specifies the leading dimension of the array fjac. integer , intent ( out ) :: Info !! an integer output variable. if the user has !! terminated execution, info is set to the (negative) !! value of iflag. see description of fcn. otherwise, !! info is set as follows: !! !!  * ***info = 0***  improper input parameters. !!  * ***info = 1***  algorithm estimates that the relative error !!           in the sum of squares is at most tol. !!  * ***info = 2***  algorithm estimates that the relative error !!           between x and the solution is at most tol. !!  * ***info = 3***  conditions for info = 1 and info = 2 both hold. !!  * ***info = 4***  fvec is orthogonal to the columns of the !!           jacobian to machine precision. !!  * ***info = 5***  number of calls to fcn with iflag = 1 has !!           reached 100*(n+1). !!  * ***info = 6***  tol is too small. no further reduction in !!           the sum of squares is possible. !!  * ***info = 7***  tol is too small. no further improvement in !!           the approximate solution x is possible. integer , intent ( in ) :: Lwa !! a positive integer input variable not less than 5*n+m. integer , intent ( out ) :: Ipvt ( n ) !! an integer output array of length n. ipvt !! defines a permutation matrix p such that jac*p = q*r, !! where jac is the final calculated jacobian, q is !! orthogonal (not stored), and r is upper triangular. !! column j of p is column ipvt(j) of the identity matrix. real ( wp ), intent ( in ) :: Tol !! a nonnegative input variable. termination occurs !! when the algorithm estimates either that the relative !! error in the sum of squares is at most tol or that !! the relative error between x and the solution is at !! most tol. real ( wp ), intent ( inout ) :: x ( n ) !! an array of length n. on input x must contain !! an initial estimate of the solution vector. on output x !! contains the final estimate of the solution vector. real ( wp ), intent ( out ) :: Fvec ( m ) !! an output array of length m which contains !! the functions evaluated at the output x. real ( wp ), intent ( out ) :: Fjac ( Ldfjac , n ) !! an output n by n array. the upper triangle of fjac !! contains an upper triangular matrix r such that !!``` !!        t     t           t !!       p *(jac *jac)*p = r *r, !!``` !! where p is a permutation matrix and jac is the final !! calculated jacobian. column j of p is column ipvt(j) !! (see below) of the identity matrix. the lower triangular !! part of fjac contains information generated during !! the computation of r. real ( wp ), intent ( inout ) :: Wa ( Lwa ) !! a work array of length lwa. integer :: maxfev , mode , nfev , njev , nprint real ( wp ) :: ftol , gtol , xtol real ( wp ), parameter :: factor = 1.0e2_wp Info = 0 ! check the input parameters for errors. if ( n > 0 . and . m >= n . and . Ldfjac >= n . and . Tol >= zero . and . & Lwa >= 5 * n + m ) then ! call lmstr. maxfev = 100 * ( n + 1 ) ftol = Tol xtol = Tol gtol = zero mode = 1 nprint = 0 call lmstr ( fcn , m , n , x , Fvec , Fjac , Ldfjac , ftol , xtol , gtol , maxfev , & Wa ( 1 ), mode , factor , nprint , Info , nfev , njev , Ipvt , Wa ( n + 1 ), & Wa ( 2 * n + 1 ), Wa ( 3 * n + 1 ), Wa ( 4 * n + 1 ), Wa ( 5 * n + 1 )) if ( Info == 8 ) Info = 4 end if end subroutine lmstr1 !***************************************************************************************** !***************************************************************************************** !> !   this subroutine proceeds from the computed qr factorization of !   an m by n matrix a to accumulate the m by m orthogonal matrix !   q from its factored form. subroutine qform ( m , n , q , Ldq , Wa ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of a and the order of q. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of a. integer , intent ( in ) :: Ldq !! a positive integer input variable not less than m !! which specifies the leading dimension of the array q. real ( wp ), intent ( inout ) :: q ( Ldq , m ) !! an m by m array. on input the full lower trapezoid in !! the first min(m,n) columns of q contains the factored form. !! on output q has been accumulated into a square matrix. real ( wp ), intent ( inout ) :: Wa ( m ) !! a work array of length m. integer :: i , j , jm1 , k , l , minmn , np1 real ( wp ) :: sum , temp ! zero out upper triangle of q in the first min(m,n) columns. minmn = min0 ( m , n ) if ( minmn >= 2 ) then do j = 2 , minmn jm1 = j - 1 do i = 1 , jm1 q ( i , j ) = zero end do end do end if ! initialize remaining columns to those of the identity matrix. np1 = n + 1 if ( m >= np1 ) then do j = np1 , m do i = 1 , m q ( i , j ) = zero end do q ( j , j ) = one end do end if ! accumulate q from its factored form. do l = 1 , minmn k = minmn - l + 1 do i = k , m Wa ( i ) = q ( i , k ) q ( i , k ) = zero end do q ( k , k ) = one if ( Wa ( k ) /= zero ) then do j = k , m sum = zero do i = k , m sum = sum + q ( i , j ) * Wa ( i ) end do temp = sum / Wa ( k ) do i = k , m q ( i , j ) = q ( i , j ) - temp * Wa ( i ) end do end do end if end do end subroutine qform !***************************************************************************************** !***************************************************************************************** !> !  this subroutine uses householder transformations with column !  pivoting (optional) to compute a qr factorization of the !  m by n matrix a. that is, qrfac determines an orthogonal !  matrix q, a permutation matrix p, and an upper trapezoidal !  matrix r with diagonal elements of nonincreasing magnitude, !  such that a*p = q*r. the householder transformation for !  column k, k = 1,2,...,min(m,n), is of the form !``` !                        t !        i - (1/u(k))*u*u !``` !  where u has zeros in the first k-1 positions. the form of !  this transformation and the method of pivoting first !  appeared in the corresponding linpack subroutine. subroutine qrfac ( m , n , a , Lda , Pivot , Ipvt , Lipvt , Rdiag , Acnorm , Wa ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of a. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of a. integer , intent ( in ) :: Lda !! a positive integer input variable not less than m !! which specifies the leading dimension of the array a. integer , intent ( in ) :: Lipvt !! a positive integer input variable. if pivot is false, !! then lipvt may be as small as 1. if pivot is true, then !! lipvt must be at least n. integer , intent ( out ) :: Ipvt ( Lipvt ) !! an integer output array of length lipvt. ipvt !! defines the permutation matrix p such that a*p = q*r. !! column j of p is column ipvt(j) of the identity matrix. !! if pivot is false, ipvt is not referenced. logical , intent ( in ) :: Pivot !! a logical input variable. if pivot is set true, !! then column pivoting is enforced. if pivot is set false, !! then no column pivoting is done. real ( wp ), intent ( inout ) :: a ( Lda , n ) !! an m by n array. on input a contains the matrix for !! which the qr factorization is to be computed. on output !! the strict upper trapezoidal part of a contains the strict !! upper trapezoidal part of r, and the lower trapezoidal !! part of a contains a factored form of q (the non-trivial !! elements of the u vectors described above). real ( wp ), intent ( out ) :: Rdiag ( n ) !! an output array of length n which contains the !! diagonal elements of r. real ( wp ), intent ( out ) :: Acnorm ( n ) !! an output array of length n which contains the !! norms of the corresponding columns of the input matrix a. !! if this information is not needed, then acnorm can coincide !! with rdiag. real ( wp ), intent ( inout ) :: Wa ( n ) !! a work array of length n. if pivot is false, then wa !! can coincide with rdiag. integer :: i , j , jp1 , k , kmax , minmn real ( wp ) :: ajnorm , sum , temp real ( wp ), parameter :: p05 = 5.0e-2_wp ! compute the initial column norms and initialize several arrays. do j = 1 , n Acnorm ( j ) = enorm ( m , a ( 1 , j )) Rdiag ( j ) = Acnorm ( j ) Wa ( j ) = Rdiag ( j ) if ( Pivot ) Ipvt ( j ) = j end do ! reduce a to r with householder transformations. minmn = min0 ( m , n ) do j = 1 , minmn if ( Pivot ) then ! bring the column of largest norm into the pivot position. kmax = j do k = j , n if ( Rdiag ( k ) > Rdiag ( kmax )) kmax = k end do if ( kmax /= j ) then do i = 1 , m temp = a ( i , j ) a ( i , j ) = a ( i , kmax ) a ( i , kmax ) = temp end do Rdiag ( kmax ) = Rdiag ( j ) Wa ( kmax ) = Wa ( j ) k = Ipvt ( j ) Ipvt ( j ) = Ipvt ( kmax ) Ipvt ( kmax ) = k end if end if ! compute the householder transformation to reduce the ! j-th column of a to a multiple of the j-th unit vector. ajnorm = enorm ( m - j + 1 , a ( j , j )) if ( ajnorm /= zero ) then if ( a ( j , j ) < zero ) ajnorm = - ajnorm do i = j , m a ( i , j ) = a ( i , j ) / ajnorm end do a ( j , j ) = a ( j , j ) + one ! apply the transformation to the remaining columns ! and update the norms. jp1 = j + 1 if ( n >= jp1 ) then do k = jp1 , n sum = zero do i = j , m sum = sum + a ( i , j ) * a ( i , k ) end do temp = sum / a ( j , j ) do i = j , m a ( i , k ) = a ( i , k ) - temp * a ( i , j ) end do if (. not . (. not . Pivot . or . Rdiag ( k ) == zero )) then temp = a ( j , k ) / Rdiag ( k ) Rdiag ( k ) = Rdiag ( k ) * sqrt ( max ( zero , one - temp ** 2 )) if ( p05 * ( Rdiag ( k ) / Wa ( k )) ** 2 <= epsmch ) then Rdiag ( k ) = enorm ( m - j , a ( jp1 , k )) Wa ( k ) = Rdiag ( k ) end if end if end do end if end if Rdiag ( j ) = - ajnorm end do end subroutine qrfac !***************************************************************************************** !***************************************************************************************** !> !  given an m by n matrix a, an n by n diagonal matrix d, !  and an m-vector b, the problem is to determine an x which !  solves the system !``` !        a*x = b ,     d*x = 0 , !``` !  in the least squares sense. ! !  this subroutine completes the solution of the problem !  if it is provided with the necessary information from the !  qr factorization, with column pivoting, of a. that is, if !  a*p = q*r, where p is a permutation matrix, q has orthogonal !  columns, and r is an upper triangular matrix with diagonal !  elements of nonincreasing magnitude, then qrsolv expects !  the full upper triangle of r, the permutation matrix p, !  and the first n components of (q transpose)*b. the system !  a*x = b, d*x = 0, is then equivalent to !``` !               t       t !        r*z = q *b ,  p *d*p*z = 0 , !``` !  where x = p*z. if this system does not have full rank, !  then a least squares solution is obtained. on output qrsolv !  also provides an upper triangular matrix s such that !``` !         t   t               t !        p *(a *a + d*d)*p = s *s . !``` !  s is computed within qrsolv and may be of separate interest. subroutine qrsolv ( n , r , Ldr , Ipvt , Diag , Qtb , x , Sdiag , Wa ) implicit none integer , intent ( in ) :: n !! a positive integer input variable set to the order of r. integer , intent ( in ) :: Ldr !! a positive integer input variable not less than n !! which specifies the leading dimension of the array r. integer , intent ( in ) :: Ipvt ( n ) !! an integer input array of length n which defines the !! permutation matrix p such that a*p = q*r. column j of p !! is column ipvt(j) of the identity matrix. real ( wp ), intent ( inout ) :: r ( Ldr , n ) !! an n by n array. on input the full upper triangle !! must contain the full upper triangle of the matrix r. !! on output the full upper triangle is unaltered, and the !! strict lower triangle contains the strict upper triangle !! (transposed) of the upper triangular matrix s. real ( wp ), intent ( in ) :: Diag ( n ) !! an input array of length n which must contain the !! diagonal elements of the matrix d. real ( wp ), intent ( in ) :: Qtb ( n ) !! an input array of length n which must contain the first !! n elements of the vector (q transpose)*b. real ( wp ), intent ( out ) :: x ( n ) !! an output array of length n which contains the least !! squares solution of the system a*x = b, d*x = 0. real ( wp ), intent ( out ) :: Sdiag ( n ) !! an output array of length n which contains the !! diagonal elements of the upper triangular matrix s. real ( wp ), intent ( inout ) :: Wa ( n ) !! a work array of length n. integer :: i , j , jp1 , k , kp1 , l , nsing real ( wp ) :: cos , cotan , qtbpj , sin , sum , tan , temp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p25 = 2.5e-1_wp ! copy r and (q transpose)*b to preserve input and initialize s. ! in particular, save the diagonal elements of r in x. do j = 1 , n do i = j , n r ( i , j ) = r ( j , i ) end do x ( j ) = r ( j , j ) Wa ( j ) = Qtb ( j ) end do ! eliminate the diagonal matrix d using a givens rotation. do j = 1 , n ! prepare the row of d to be eliminated, locating the ! diagonal element using p from the qr factorization. l = Ipvt ( j ) if ( Diag ( l ) /= zero ) then do k = j , n Sdiag ( k ) = zero end do Sdiag ( j ) = Diag ( l ) ! the transformations to eliminate the row of d ! modify only a single element of (q transpose)*b ! beyond the first n, which is initially zero. qtbpj = zero do k = j , n ! determine a givens rotation which eliminates the ! appropriate element in the current row of d. if ( Sdiag ( k ) /= zero ) then if ( abs ( r ( k , k )) >= abs ( Sdiag ( k ))) then tan = Sdiag ( k ) / r ( k , k ) cos = p5 / sqrt ( p25 + p25 * tan ** 2 ) sin = cos * tan else cotan = r ( k , k ) / Sdiag ( k ) sin = p5 / sqrt ( p25 + p25 * cotan ** 2 ) cos = sin * cotan end if ! compute the modified diagonal element of r and ! the modified element of ((q transpose)*b,0). r ( k , k ) = cos * r ( k , k ) + sin * Sdiag ( k ) temp = cos * Wa ( k ) + sin * qtbpj qtbpj = - sin * Wa ( k ) + cos * qtbpj Wa ( k ) = temp ! accumulate the tranformation in the row of s. kp1 = k + 1 if ( n >= kp1 ) then do i = kp1 , n temp = cos * r ( i , k ) + sin * Sdiag ( i ) Sdiag ( i ) = - sin * r ( i , k ) + cos * Sdiag ( i ) r ( i , k ) = temp end do end if end if end do end if ! store the diagonal element of s and restore ! the corresponding diagonal element of r. Sdiag ( j ) = r ( j , j ) r ( j , j ) = x ( j ) end do ! solve the triangular system for z. if the system is ! singular, then obtain a least squares solution. nsing = n do j = 1 , n if ( Sdiag ( j ) == zero . and . nsing == n ) nsing = j - 1 if ( nsing < n ) Wa ( j ) = zero end do if ( nsing >= 1 ) then do k = 1 , nsing j = nsing - k + 1 sum = zero jp1 = j + 1 if ( nsing >= jp1 ) then do i = jp1 , nsing sum = sum + r ( i , j ) * Wa ( i ) end do end if Wa ( j ) = ( Wa ( j ) - sum ) / Sdiag ( j ) end do end if ! permute the components of z back to components of x. do j = 1 , n l = Ipvt ( j ) x ( l ) = Wa ( j ) end do end subroutine qrsolv !***************************************************************************************** !***************************************************************************************** !> !  given an m by n matrix a, this subroutine computes a*q where !  q is the product of 2*(n - 1) transformations !``` !        gv(n-1)*...*gv(1)*gw(1)*...*gw(n-1) !``` !  and gv(i), gw(i) are givens rotations in the (i,n) plane which !  eliminate elements in the i-th and n-th planes, respectively. !  q itself is not given, rather the information to recover the !  gv, gw rotations is supplied. subroutine r1mpyq ( m , n , a , Lda , v , w ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of a. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of a. integer , intent ( in ) :: Lda !! a positive integer input variable not less than m !! which specifies the leading dimension of the array a. real ( wp ), intent ( inout ) :: a ( Lda , n ) !! an m by n array. on input a must contain the matrix !! to be postmultiplied by the orthogonal matrix q !! described above. on output a*q has replaced a. real ( wp ), intent ( in ) :: v ( n ) !! an input array of length n. v(i) must contain the !! information necessary to recover the givens rotation gv(i) !! described above. real ( wp ), intent ( in ) :: w ( n ) !! an input array of length n. w(i) must contain the !! information necessary to recover the givens rotation gw(i) !! described above. integer :: i , j , nmj , nm1 real ( wp ) :: cos , sin , temp ! apply the first set of givens rotations to a. nm1 = n - 1 if ( nm1 >= 1 ) then do nmj = 1 , nm1 j = n - nmj if ( abs ( v ( j )) > one ) cos = one / v ( j ) if ( abs ( v ( j )) > one ) sin = sqrt ( one - cos ** 2 ) if ( abs ( v ( j )) <= one ) sin = v ( j ) if ( abs ( v ( j )) <= one ) cos = sqrt ( one - sin ** 2 ) do i = 1 , m temp = cos * a ( i , j ) - sin * a ( i , n ) a ( i , n ) = sin * a ( i , j ) + cos * a ( i , n ) a ( i , j ) = temp end do end do ! apply the second set of givens rotations to a. do j = 1 , nm1 if ( abs ( w ( j )) > one ) cos = one / w ( j ) if ( abs ( w ( j )) > one ) sin = sqrt ( one - cos ** 2 ) if ( abs ( w ( j )) <= one ) sin = w ( j ) if ( abs ( w ( j )) <= one ) cos = sqrt ( one - sin ** 2 ) do i = 1 , m temp = cos * a ( i , j ) + sin * a ( i , n ) a ( i , n ) = - sin * a ( i , j ) + cos * a ( i , n ) a ( i , j ) = temp end do end do end if end subroutine r1mpyq !***************************************************************************************** !***************************************************************************************** !> !  given an m by n lower trapezoidal matrix s, an m-vector u, !  and an n-vector v, the problem is to determine an !  orthogonal matrix q such that !``` !                t !        (s + u*v )*q !``` !  is again lower trapezoidal. ! !  this subroutine determines q as the product of 2*(n - 1) !  transformations !``` !        gv(n-1)*...*gv(1)*gw(1)*...*gw(n-1) !``` !  where gv(i), gw(i) are givens rotations in the (i,n) plane !  which eliminate elements in the i-th and n-th planes, !  respectively. q itself is not accumulated, rather the !  information to recover the gv, gw rotations is returned. subroutine r1updt ( m , n , s , Ls , u , v , w , Sing ) implicit none integer , intent ( in ) :: m !! a positive integer input variable set to the number !! of rows of s. integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of columns of s. n must not exceed m. integer , intent ( in ) :: Ls !! a positive integer input variable not less than !! (n*(2*m-n+1))/2. logical , intent ( out ) :: Sing !! a logical output variable. sing is set true if any !! of the diagonal elements of the output s are zero. otherwise !! sing is set false. real ( wp ), intent ( inout ) :: s ( Ls ) !! an array of length ls. on input s must contain the lower !! trapezoidal matrix s stored by columns. on output s contains !! the lower trapezoidal matrix produced as described above. real ( wp ), intent ( in ) :: u ( m ) !! an input array of length m which must contain the !! vector u. real ( wp ), intent ( inout ) :: v ( n ) !! an array of length n. on input v must contain the vector !! v. on output v(i) contains the information necessary to !! recover the givens rotation gv(i) described above. real ( wp ), intent ( out ) :: w ( m ) !! an output array of length m. w(i) contains information !! necessary to recover the givens rotation gw(i) described !! above. integer :: i , j , jj , l , nmj , nm1 real ( wp ) :: cos , cotan , sin , tan , tau , temp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p25 = 2.5e-1_wp real ( wp ), parameter :: giant = dpmpar ( 3 ) !! the largest magnitude. ! initialize the diagonal element pointer. jj = ( n * ( 2 * m - n + 1 )) / 2 - ( m - n ) ! move the nontrivial part of the last column of s into w. l = jj do i = n , m w ( i ) = s ( l ) l = l + 1 end do ! rotate the vector v into a multiple of the n-th unit vector ! in such a way that a spike is introduced into w. nm1 = n - 1 if ( nm1 >= 1 ) then do nmj = 1 , nm1 j = n - nmj jj = jj - ( m - j + 1 ) w ( j ) = zero if ( v ( j ) /= zero ) then ! determine a givens rotation which eliminates the ! j-th element of v. if ( abs ( v ( n )) >= abs ( v ( j ))) then tan = v ( j ) / v ( n ) cos = p5 / sqrt ( p25 + p25 * tan ** 2 ) sin = cos * tan tau = sin else cotan = v ( n ) / v ( j ) sin = p5 / sqrt ( p25 + p25 * cotan ** 2 ) cos = sin * cotan tau = one if ( abs ( cos ) * giant > one ) tau = one / cos end if ! apply the transformation to v and store the information ! necessary to recover the givens rotation. v ( n ) = sin * v ( j ) + cos * v ( n ) v ( j ) = tau ! apply the transformation to s and extend the spike in w. l = jj do i = j , m temp = cos * s ( l ) - sin * w ( i ) w ( i ) = sin * s ( l ) + cos * w ( i ) s ( l ) = temp l = l + 1 end do end if end do end if ! add the spike from the rank 1 update to w. do i = 1 , m w ( i ) = w ( i ) + v ( n ) * u ( i ) end do ! eliminate the spike. Sing = . false . if ( nm1 >= 1 ) then do j = 1 , nm1 if ( w ( j ) /= zero ) then ! determine a givens rotation which eliminates the ! j-th element of the spike. if ( abs ( s ( jj )) >= abs ( w ( j ))) then tan = w ( j ) / s ( jj ) cos = p5 / sqrt ( p25 + p25 * tan ** 2 ) sin = cos * tan tau = sin else cotan = s ( jj ) / w ( j ) sin = p5 / sqrt ( p25 + p25 * cotan ** 2 ) cos = sin * cotan tau = one if ( abs ( cos ) * giant > one ) tau = one / cos end if ! apply the transformation to s and reduce the spike in w. l = jj do i = j , m temp = cos * s ( l ) + sin * w ( i ) w ( i ) = - sin * s ( l ) + cos * w ( i ) s ( l ) = temp l = l + 1 end do ! store the information necessary to recover the ! givens rotation. w ( j ) = tau end if ! test for zero diagonal elements in the output s. if ( s ( jj ) == zero ) Sing = . true . jj = jj + ( m - j + 1 ) end do end if ! move w back into the last column of the output s. l = jj do i = n , m s ( l ) = w ( i ) l = l + 1 end do if ( s ( jj ) == zero ) Sing = . true . end subroutine r1updt !***************************************************************************************** !***************************************************************************************** !> !  given an n by n upper triangular matrix r, this subroutine !  computes the qr decomposition of the matrix formed when a row !  is added to r. if the row is specified by the vector w, then !  rwupdt determines an orthogonal matrix q such that when the !  n+1 by n matrix composed of r augmented by w is premultiplied !  by (q transpose), the resulting matrix is upper trapezoidal. !  the matrix (q transpose) is the product of n transformations !``` !        g(n)*g(n-1)* ... *g(1) !``` !  where g(i) is a givens rotation in the (i,n+1) plane which !  eliminates elements in the (n+1)-st plane. rwupdt also !  computes the product (q transpose)*c where c is the !  (n+1)-vector (b,alpha). q itself is not accumulated, rather !  the information to recover the g rotations is supplied. subroutine rwupdt ( n , r , Ldr , w , b , Alpha , Cos , Sin ) implicit none integer , intent ( in ) :: n !! a positive integer input variable set to the order of r. integer , intent ( in ) :: Ldr !! a positive integer input variable not less than n !! which specifies the leading dimension of the array r. real ( wp ), intent ( inout ) :: Alpha !! a variable. on input alpha must contain the !! (n+1)-st element of the vector c. on output alpha contains !! the (n+1)-st element of the vector (q transpose)*c. real ( wp ), intent ( inout ) :: r ( Ldr , n ) !! an n by n array. on input the upper triangular part of !! r must contain the matrix to be updated. on output r !! contains the updated triangular matrix. real ( wp ), intent ( in ) :: w ( n ) !! an input array of length n which must contain the row !! vector to be added to r. real ( wp ), intent ( inout ) :: b ( n ) !! an array of length n. on input b must contain the !! first n elements of the vector c. on output b contains !! the first n elements of the vector (q transpose)*c. real ( wp ), intent ( out ) :: Cos ( n ) !! an output array of length n which contains the !! cosines of the transforming givens rotations. real ( wp ), intent ( out ) :: Sin ( n ) !! an output array of length n which contains the !! sines of the transforming givens rotations. integer :: i , j , jm1 real ( wp ) :: cotan , rowj , tan , temp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p25 = 2.5e-1_wp do j = 1 , n rowj = w ( j ) jm1 = j - 1 ! apply the previous transformations to ! r(i,j), i=1,2,...,j-1, and to w(j). if ( jm1 >= 1 ) then do i = 1 , jm1 temp = Cos ( i ) * r ( i , j ) + Sin ( i ) * rowj rowj = - Sin ( i ) * r ( i , j ) + Cos ( i ) * rowj r ( i , j ) = temp end do end if ! determine a givens rotation which eliminates w(j). Cos ( j ) = one Sin ( j ) = zero if ( rowj /= zero ) then if ( abs ( r ( j , j )) >= abs ( rowj )) then tan = rowj / r ( j , j ) Cos ( j ) = p5 / sqrt ( p25 + p25 * tan ** 2 ) Sin ( j ) = Cos ( j ) * tan else cotan = r ( j , j ) / rowj Sin ( j ) = p5 / sqrt ( p25 + p25 * cotan ** 2 ) Cos ( j ) = Sin ( j ) * cotan end if ! apply the current transformation to r(j,j), b(j), and alpha. r ( j , j ) = Cos ( j ) * r ( j , j ) + Sin ( j ) * rowj temp = Cos ( j ) * b ( j ) + Sin ( j ) * Alpha Alpha = - Sin ( j ) * b ( j ) + Cos ( j ) * Alpha b ( j ) = temp end if end do end subroutine rwupdt !***************************************************************************************** !***************************************************************************************** end module minpack_module !*****************************************************************************************","tags":"","loc":"sourcefile/minpack.f90.html"},{"title":"minpack_capi.f90 – minpack","text":"This file depends on sourcefile~~minpack_capi.f90~~EfferentGraph sourcefile~minpack_capi.f90 minpack_capi.f90 sourcefile~minpack.f90 minpack.f90 sourcefile~minpack_capi.f90->sourcefile~minpack.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules minpack_capi Source Code minpack_capi.f90 Source Code module minpack_capi use , intrinsic :: iso_c_binding , only : c_int , c_double , c_funptr , c_ptr , c_f_procpointer use minpack_module implicit none private public :: minpack_hybrd , minpack_hybrd1 , minpack_hybrj , minpack_hybrj1 , & & minpack_lmdif , minpack_lmdif1 , minpack_lmder , minpack_lmder1 , & & minpack_chkder public :: minpack_dpmpar public :: minpack_func , minpack_func2 , minpack_fcn_hybrj , minpack_fcn_lmder , & & minpack_fcn_lmstr abstract interface subroutine minpack_func ( n , x , fvec , iflag , udata ) bind ( c ) import :: c_int , c_double , c_ptr implicit none integer ( c_int ), value :: n real ( c_double ), intent ( in ) :: x ( n ) real ( c_double ), intent ( out ) :: fvec ( n ) integer ( c_int ), intent ( inout ) :: iflag type ( c_ptr ), value :: udata end subroutine minpack_func subroutine minpack_func2 ( m , n , x , fvec , iflag , udata ) bind ( c ) import :: c_int , c_double , c_ptr implicit none integer ( c_int ), value :: m integer ( c_int ), value :: n real ( c_double ), intent ( in ) :: x ( n ) real ( c_double ), intent ( out ) :: fvec ( m ) integer ( c_int ), intent ( inout ) :: iflag type ( c_ptr ), value :: udata end subroutine minpack_func2 subroutine minpack_fcn_hybrj ( n , x , fvec , fjac , ldfjac , iflag , udata ) bind ( c ) import :: c_int , c_double , c_ptr implicit none integer ( c_int ), value :: n real ( c_double ), intent ( in ) :: x ( n ) integer ( c_int ), value :: ldfjac real ( c_double ), intent ( out ) :: fvec ( n ) real ( c_double ), intent ( out ) :: fjac ( ldfjac , n ) integer ( c_int ), intent ( inout ) :: iflag type ( c_ptr ), value :: udata end subroutine minpack_fcn_hybrj subroutine minpack_fcn_lmder ( m , n , x , fvec , fjac , ldfjac , iflag , udata ) bind ( c ) import :: c_int , c_double , c_ptr implicit none integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), value :: ldfjac integer ( c_int ), intent ( inout ) :: iflag real ( c_double ), intent ( in ) :: x ( n ) real ( c_double ), intent ( inout ) :: fvec ( m ) real ( c_double ), intent ( inout ) :: fjac ( ldfjac , n ) type ( c_ptr ), value :: udata end subroutine minpack_fcn_lmder subroutine minpack_fcn_lmstr ( m , n , x , fvec , fjrow , iflag , udata ) bind ( c ) import :: c_int , c_double , c_ptr implicit none integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), intent ( inout ) :: iflag real ( c_double ), intent ( in ) :: x ( n ) real ( c_double ), intent ( inout ) :: fvec ( m ) real ( c_double ), intent ( inout ) :: fjrow ( n ) type ( c_ptr ), value :: udata end subroutine minpack_fcn_lmstr end interface contains function minpack_dpmpar ( i ) result ( par ) bind ( c ) integer ( c_int ), value :: i real ( c_double ) :: par if ( i > 0_c_int . and . i <= 3_c_int ) then par = dpmpar ( i ) end if end function minpack_dpmpar subroutine minpack_hybrd ( fcn , n , x , fvec , xtol , maxfev , ml , mu , epsfcn , diag , mode , & & factor , nprint , info , nfev , fjac , ldfjac , r , lr , qtf , wa1 , wa2 , wa3 , wa4 , & & udata ) & & bind ( c ) procedure ( minpack_func ) :: fcn integer ( c_int ), value :: n integer ( c_int ), value :: maxfev integer ( c_int ), value :: ml integer ( c_int ), value :: mu integer ( c_int ), value :: mode integer ( c_int ), value :: nprint integer ( c_int ), intent ( out ) :: info integer ( c_int ), intent ( out ) :: nfev integer ( c_int ), value :: ldfjac integer ( c_int ), value :: lr real ( c_double ), value :: xtol real ( c_double ), value :: epsfcn real ( c_double ), value :: factor real ( c_double ), intent ( inout ) :: x ( n ) real ( c_double ), intent ( out ) :: fvec ( n ) real ( c_double ), intent ( inout ) :: diag ( n ) real ( c_double ), intent ( out ) :: fjac ( ldfjac , n ) real ( c_double ), intent ( out ) :: r ( lr ) real ( c_double ), intent ( out ) :: qtf ( n ) real ( c_double ), intent ( inout ) :: wa1 ( n ) real ( c_double ), intent ( inout ) :: wa2 ( n ) real ( c_double ), intent ( inout ) :: wa3 ( n ) real ( c_double ), intent ( inout ) :: wa4 ( n ) type ( c_ptr ), value :: udata call hybrd ( wrap_fcn , n , x , fvec , xtol , maxfev , ml , mu , epsfcn , diag , mode , & & factor , nprint , info , nfev , fjac , ldfjac , r , lr , qtf , wa1 , wa2 , wa3 , wa4 ) contains subroutine wrap_fcn ( n , x , fvec , iflag ) integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x ( n ) real ( wp ), intent ( out ) :: fvec ( n ) integer , intent ( inout ) :: iflag call fcn ( n , x , fvec , iflag , udata ) end subroutine wrap_fcn end subroutine minpack_hybrd subroutine minpack_hybrd1 ( fcn , n , x , Fvec , Tol , Info , Wa , Lwa , udata ) & & bind ( c ) procedure ( minpack_func ) :: fcn integer ( c_int ), value :: n integer ( c_int ), intent ( out ) :: info real ( c_double ), value :: tol real ( c_double ), intent ( inout ) :: x ( n ) real ( c_double ), intent ( out ) :: fvec ( n ) integer ( c_int ), value :: Lwa real ( c_double ), intent ( inout ) :: Wa ( Lwa ) type ( c_ptr ), value :: udata call hybrd1 ( wrap_fcn , n , x , fvec , tol , info , Wa , Lwa ) contains subroutine wrap_fcn ( n , x , fvec , iflag ) integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x ( n ) real ( wp ), intent ( out ) :: fvec ( n ) integer , intent ( inout ) :: iflag call fcn ( n , x , fvec , iflag , udata ) end subroutine wrap_fcn end subroutine minpack_hybrd1 subroutine minpack_hybrj ( fcn , n , x , fvec , fjac , ldfjac , xtol , maxfev , diag , mode , & & factor , nprint , info , nfev , njev , r , lr , qtf , wa1 , wa2 , wa3 , wa4 , udata ) & & bind ( c ) procedure ( minpack_fcn_hybrj ) :: fcn integer ( c_int ), value :: n integer ( c_int ), value :: ldfjac integer ( c_int ), value :: maxfev integer ( c_int ), value :: mode integer ( c_int ), value :: nprint integer ( c_int ), intent ( out ) :: info integer ( c_int ), intent ( out ) :: nfev integer ( c_int ), intent ( out ) :: njev integer ( c_int ), value :: lr real ( c_double ), value :: xtol real ( c_double ), value :: factor real ( c_double ), intent ( inout ) :: x ( n ) real ( c_double ), intent ( out ) :: fvec ( n ) real ( c_double ), intent ( out ) :: fjac ( ldfjac , n ) real ( c_double ), intent ( inout ) :: diag ( n ) real ( c_double ), intent ( out ) :: r ( lr ) real ( c_double ), intent ( out ) :: qtf ( n ) real ( c_double ), intent ( inout ) :: wa1 ( n ) real ( c_double ), intent ( inout ) :: wa2 ( n ) real ( c_double ), intent ( inout ) :: wa3 ( n ) real ( c_double ), intent ( inout ) :: wa4 ( n ) type ( c_ptr ), value :: udata call hybrj ( wrap_fcn , n , x , fvec , fjac , ldfjac , xtol , maxfev , diag , mode , & & factor , nprint , info , nfev , njev , r , lr , qtf , wa1 , wa2 , wa3 , wa4 ) contains subroutine wrap_fcn ( n , x , fvec , fjac , ldfjac , iflag ) integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x ( n ) integer , intent ( in ) :: ldfjac real ( wp ), intent ( out ) :: fvec ( n ) real ( wp ), intent ( out ) :: fjac ( ldfjac , n ) integer , intent ( inout ) :: iflag call fcn ( n , x , fvec , fjac , ldfjac , iflag , udata ) end subroutine wrap_fcn end subroutine minpack_hybrj subroutine minpack_hybrj1 ( fcn , n , x , fvec , fjac , ldfjac , tol , info , wa , lwa , udata ) & & bind ( c ) procedure ( minpack_fcn_hybrj ) :: fcn integer ( c_int ), value :: n integer ( c_int ), value :: ldfjac integer ( c_int ), intent ( out ) :: info integer ( c_int ), value :: lwa real ( c_double ), value :: tol real ( c_double ), intent ( inout ) :: x ( n ) real ( c_double ), intent ( out ) :: fvec ( n ) real ( c_double ), intent ( out ) :: fjac ( ldfjac , n ) real ( c_double ), intent ( inout ) :: wa ( lwa ) type ( c_ptr ), value :: udata call hybrj1 ( wrap_fcn , n , x , fvec , fjac , ldfjac , tol , info , wa , lwa ) contains subroutine wrap_fcn ( n , x , fvec , fjac , ldfjac , iflag ) integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x ( n ) integer , intent ( in ) :: ldfjac real ( wp ), intent ( out ) :: fvec ( n ) real ( wp ), intent ( out ) :: fjac ( ldfjac , n ) integer , intent ( inout ) :: iflag call fcn ( n , x , fvec , fjac , ldfjac , iflag , udata ) end subroutine wrap_fcn end subroutine minpack_hybrj1 subroutine minpack_lmdif ( fcn , m , n , x , fvec , ftol , xtol , gtol , maxfev , epsfcn , diag , & & mode , factor , nprint , info , nfev , fjac , ldfjac , ipvt , qtf , wa1 , wa2 , wa3 , wa4 , & & udata ) & & bind ( c ) procedure ( minpack_func2 ) :: fcn integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), value :: maxfev integer ( c_int ), value :: mode integer ( c_int ), value :: nprint integer ( c_int ), intent ( out ) :: info integer ( c_int ), intent ( out ) :: nfev integer ( c_int ), value :: ldfjac integer ( c_int ), intent ( out ) :: ipvt ( n ) real ( c_double ), value :: ftol real ( c_double ), value :: xtol real ( c_double ), value :: gtol real ( c_double ), value :: epsfcn real ( c_double ), value :: factor real ( c_double ), intent ( inout ) :: x ( n ) real ( c_double ), intent ( out ) :: fvec ( m ) real ( c_double ), intent ( inout ) :: diag ( n ) real ( c_double ), intent ( out ) :: fjac ( ldfjac , n ) real ( c_double ), intent ( out ) :: qtf ( n ) real ( c_double ), intent ( inout ) :: wa1 ( n ) real ( c_double ), intent ( inout ) :: wa2 ( n ) real ( c_double ), intent ( inout ) :: wa3 ( n ) real ( c_double ), intent ( inout ) :: wa4 ( m ) type ( c_ptr ), value :: udata call lmdif ( wrap_fcn , m , n , x , fvec , ftol , xtol , gtol , maxfev , epsfcn , diag , & & mode , factor , nprint , info , nfev , fjac , ldfjac , ipvt , qtf , wa1 , wa2 , wa3 , wa4 ) contains subroutine wrap_fcn ( m , n , x , fvec , iflag ) integer , intent ( in ) :: m integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x ( n ) real ( wp ), intent ( out ) :: fvec ( m ) integer , intent ( inout ) :: iflag call fcn ( m , n , x , fvec , iflag , udata ) end subroutine wrap_fcn end subroutine minpack_lmdif subroutine minpack_lmdif1 ( fcn , m , n , x , fvec , tol , info , iwa , wa , lwa , udata ) & & bind ( c ) procedure ( minpack_func2 ) :: fcn integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), intent ( out ) :: info integer ( c_int ), value :: lwa integer ( c_int ), intent ( inout ) :: iwa ( n ) real ( c_double ), value :: tol real ( c_double ), intent ( inout ) :: x ( n ) real ( c_double ), intent ( inout ) :: fvec ( m ) real ( c_double ), intent ( inout ) :: wa ( lwa ) type ( c_ptr ), value :: udata call lmdif1 ( wrap_fcn , m , n , x , fvec , tol , info , iwa , wa , lwa ) contains subroutine wrap_fcn ( m , n , x , fvec , iflag ) integer , intent ( in ) :: m integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x ( n ) real ( wp ), intent ( out ) :: fvec ( m ) integer , intent ( inout ) :: iflag call fcn ( m , n , x , fvec , iflag , udata ) end subroutine wrap_fcn end subroutine minpack_lmdif1 subroutine minpack_lmder ( fcn , m , n , x , fvec , fjac , ldfjac , ftol , xtol , gtol , maxfev , & & diag , mode , factor , nprint , info , nfev , njev , ipvt , qtf , wa1 , wa2 , wa3 , wa4 , & & udata ) & & bind ( c ) procedure ( minpack_fcn_lmder ) :: fcn integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), value :: ldfjac integer ( c_int ), value :: maxfev integer ( c_int ), value :: mode integer ( c_int ), value :: nprint integer ( c_int ), intent ( out ) :: info integer ( c_int ), intent ( out ) :: nfev integer ( c_int ), intent ( out ) :: njev integer ( c_int ), intent ( out ) :: ipvt ( n ) real ( c_double ), value :: ftol real ( c_double ), value :: xtol real ( c_double ), value :: gtol real ( c_double ), value :: factor real ( c_double ), intent ( inout ) :: x ( n ) real ( c_double ), intent ( out ) :: fvec ( m ) real ( c_double ), intent ( out ) :: fjac ( ldfjac , n ) real ( c_double ), intent ( inout ) :: diag ( n ) real ( c_double ), intent ( out ) :: qtf ( n ) real ( c_double ), intent ( inout ) :: wa1 ( n ) real ( c_double ), intent ( inout ) :: wa2 ( n ) real ( c_double ), intent ( inout ) :: wa3 ( n ) real ( c_double ), intent ( inout ) :: wa4 ( m ) type ( c_ptr ), value :: udata call lmder ( wrap_fcn , m , n , x , fvec , fjac , ldfjac , ftol , xtol , gtol , maxfev , & & diag , mode , factor , nprint , info , nfev , njev , ipvt , qtf , wa1 , wa2 , wa3 , wa4 ) contains subroutine wrap_fcn ( m , n , x , fvec , fjac , ldfjac , iflag ) integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: ldfjac integer , intent ( inout ) :: iflag real ( wp ), intent ( in ) :: x ( n ) real ( wp ), intent ( inout ) :: fvec ( m ) real ( wp ), intent ( inout ) :: fjac ( ldfjac , n ) call fcn ( m , n , x , fvec , fjac , ldfjac , iflag , udata ) end subroutine wrap_fcn end subroutine minpack_lmder subroutine minpack_lmder1 ( fcn , m , n , x , Fvec , Fjac , Ldfjac , Tol , Info , Ipvt , Wa , Lwa , & & udata ) & & bind ( c ) procedure ( minpack_fcn_lmder ) :: fcn integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), value :: ldfjac integer ( c_int ), intent ( out ) :: info integer ( c_int ), value :: lwa integer ( c_int ), intent ( out ) :: ipvt ( n ) real ( c_double ), value :: tol real ( c_double ), intent ( inout ) :: x ( n ) real ( c_double ), intent ( out ) :: fvec ( m ) real ( c_double ), intent ( out ) :: fjac ( ldfjac , n ) real ( c_double ), intent ( inout ) :: wa ( lwa ) type ( c_ptr ), value :: udata call lmder1 ( wrap_fcn , m , n , x , Fvec , Fjac , Ldfjac , Tol , Info , Ipvt , Wa , Lwa ) contains subroutine wrap_fcn ( m , n , x , fvec , fjac , ldfjac , iflag ) integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: ldfjac integer , intent ( inout ) :: iflag real ( wp ), intent ( in ) :: x ( n ) real ( wp ), intent ( inout ) :: fvec ( m ) real ( wp ), intent ( inout ) :: fjac ( ldfjac , n ) call fcn ( m , n , x , fvec , fjac , ldfjac , iflag , udata ) end subroutine wrap_fcn end subroutine minpack_lmder1 subroutine minpack_lmstr ( fcn , m , n , x , fvec , fjac , ldfjac , ftol , xtol , gtol , maxfev , & & diag , mode , factor , nprint , info , nfev , njev , ipvt , qtf , wa1 , wa2 , wa3 , wa4 , & & udata ) & & bind ( c ) procedure ( minpack_fcn_lmstr ) :: fcn integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), value :: ldfjac integer ( c_int ), value :: maxfev integer ( c_int ), value :: mode integer ( c_int ), value :: nprint integer ( c_int ), intent ( out ) :: info integer ( c_int ), intent ( out ) :: nfev integer ( c_int ), intent ( out ) :: njev integer ( c_int ), intent ( out ) :: ipvt ( n ) real ( c_double ), value :: ftol real ( c_double ), value :: xtol real ( c_double ), value :: gtol real ( c_double ), value :: factor real ( c_double ), intent ( inout ) :: x ( n ) real ( c_double ), intent ( out ) :: fvec ( m ) real ( c_double ), intent ( out ) :: fjac ( ldfjac , n ) real ( c_double ), intent ( inout ) :: diag ( n ) real ( c_double ), intent ( out ) :: qtf ( n ) real ( c_double ), intent ( inout ) :: wa1 ( n ) real ( c_double ), intent ( inout ) :: wa2 ( n ) real ( c_double ), intent ( inout ) :: wa3 ( n ) real ( c_double ), intent ( inout ) :: wa4 ( m ) type ( c_ptr ), value :: udata call lmstr ( wrap_fcn , m , n , x , fvec , fjac , ldfjac , ftol , xtol , gtol , maxfev , & & diag , mode , factor , nprint , info , nfev , njev , ipvt , qtf , wa1 , wa2 , wa3 , wa4 ) contains subroutine wrap_fcn ( m , n , x , fvec , fjrow , iflag ) integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( inout ) :: iflag real ( wp ), intent ( in ) :: x ( n ) real ( wp ), intent ( inout ) :: fvec ( m ) real ( wp ), intent ( inout ) :: fjrow ( n ) call fcn ( m , n , x , fvec , fjrow , iflag , udata ) end subroutine wrap_fcn end subroutine minpack_lmstr subroutine minpack_lmstr1 ( fcn , m , n , x , fvec , fjac , ldfjac , tol , info , ipvt , wa , lwa , & & udata ) & & bind ( c ) procedure ( minpack_fcn_lmstr ) :: fcn integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), value :: ldfjac integer ( c_int ), intent ( out ) :: info integer ( c_int ), value :: lwa integer ( c_int ), intent ( out ) :: ipvt ( n ) real ( c_double ), value :: tol real ( c_double ), intent ( inout ) :: x ( n ) real ( c_double ), intent ( out ) :: fvec ( m ) real ( c_double ), intent ( out ) :: fjac ( ldfjac , n ) real ( c_double ), intent ( inout ) :: wa ( lwa ) type ( c_ptr ), value :: udata call lmstr1 ( wrap_fcn , m , n , x , fvec , fjac , ldfjac , tol , info , ipvt , wa , lwa ) contains subroutine wrap_fcn ( m , n , x , fvec , fjrow , iflag ) integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( inout ) :: iflag real ( wp ), intent ( in ) :: x ( n ) real ( wp ), intent ( inout ) :: fvec ( m ) real ( wp ), intent ( inout ) :: fjrow ( n ) call fcn ( m , n , x , fvec , fjrow , iflag , udata ) end subroutine wrap_fcn end subroutine minpack_lmstr1 subroutine minpack_chkder ( m , n , x , fvec , fjac , ldfjac , xp , fvecp , mode , err ) & & bind ( c ) integer ( c_int ), value :: m integer ( c_int ), value :: n integer ( c_int ), value :: ldfjac integer ( c_int ), value :: mode real ( c_double ), intent ( in ) :: x ( n ) real ( c_double ), intent ( in ) :: fvec ( m ) real ( c_double ), intent ( in ) :: fjac ( ldfjac , n ) real ( c_double ), intent ( out ) :: xp ( n ) real ( c_double ), intent ( in ) :: fvecp ( m ) real ( c_double ), intent ( out ) :: err ( m ) call chkder ( m , n , x , fvec , fjac , ldfjac , xp , fvecp , mode , err ) end subroutine minpack_chkder end module minpack_capi","tags":"","loc":"sourcefile/minpack_capi.f90.html"},{"title":"func – minpack","text":"abstract interface public subroutine func(n, x, fvec, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the number of variables. real(kind=wp), intent(in) :: x (n) independant variable vector real(kind=wp), intent(out) :: fvec (n) value of function at x integer, intent(inout) :: iflag set to <0 to terminate execution Description user-supplied subroutine for hybrd , hybrd1 , and fdjac1","tags":"","loc":"interface/func.html"},{"title":"func2 – minpack","text":"abstract interface public subroutine func2(m, n, x, fvec, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m the number of functions. integer, intent(in) :: n the number of variables. real(kind=wp), intent(in) :: x (n) independant variable vector real(kind=wp), intent(out) :: fvec (m) value of function at x integer, intent(inout) :: iflag the value of iflag should not be changed unless\nthe user wants to terminate execution of lmdif.\nin this case set iflag to a negative integer. Description user-supplied subroutine for fdjac2 , lmdif , and lmdif1","tags":"","loc":"interface/func2.html"},{"title":"fcn_hybrj – minpack","text":"abstract interface public subroutine fcn_hybrj(n, x, fvec, fjac, ldfjac, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the number of variables. real(kind=wp), intent(in), dimension(n) :: x independant variable vector real(kind=wp), intent(out), dimension(n) :: fvec value of function at x real(kind=wp), intent(out), dimension(ldfjac, n) :: fjac jacobian matrix at x integer, intent(in) :: ldfjac leading dimension of the array fjac. integer, intent(inout) :: iflag if iflag = 1 calculate the functions at x and\nreturn this vector in fvec. do not alter fjac.\nif iflag = 2 calculate the jacobian at x and\nreturn this matrix in fjac. do not alter fvec. the value of iflag should not be changed by fcn unless\nthe user wants to terminate execution of hybrj.\nin this case set iflag to a negative integer. Description user-supplied subroutine for hybrj and hybrj1","tags":"","loc":"interface/fcn_hybrj.html"},{"title":"fcn_lmder – minpack","text":"abstract interface public subroutine fcn_lmder(m, n, x, fvec, fjac, ldfjac, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m the number of functions. integer, intent(in) :: n the number of variables. real(kind=wp), intent(in) :: x (n) independant variable vector real(kind=wp), intent(inout) :: fvec (m) value of function at x real(kind=wp), intent(inout) :: fjac (ldfjac,n) jacobian matrix at x integer, intent(in) :: ldfjac leading dimension of the array fjac. integer, intent(inout) :: iflag if iflag = 1 calculate the functions at x and\nreturn this vector in fvec. do not alter fjac.\nif iflag = 2 calculate the jacobian at x and\nreturn this matrix in fjac. do not alter fvec. the value of iflag should not be changed by fcn unless\nthe user wants to terminate execution of lmder.\nin this case set iflag to a negative integer. Description user-supplied subroutine for lmder and lmder1","tags":"","loc":"interface/fcn_lmder.html"},{"title":"fcn_lmstr – minpack","text":"abstract interface public subroutine fcn_lmstr(m, n, x, fvec, fjrow, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m the number of functions. integer, intent(in) :: n the number of variables. real(kind=wp), intent(in) :: x (n) independent variable vector real(kind=wp), intent(inout) :: fvec (m) value of function at x real(kind=wp), intent(inout) :: fjrow (n) jacobian row integer, intent(inout) :: iflag if iflag = 1 calculate the functions at x and\nreturn this vector in fvec.\nif iflag = i calculate the (i-1)-st row of the\njacobian at x and return this vector in fjrow. the value of iflag should not be changed by fcn unless\nthe user wants to terminate execution of lmstr.\nin this case set iflag to a negative integer.","tags":"","loc":"interface/fcn_lmstr.html"},{"title":"minpack_func – minpack","text":"abstract interface public subroutine minpack_func(n, x, fvec, iflag, udata) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n real(kind=c_double), intent(in) :: x (n) real(kind=c_double), intent(out) :: fvec (n) integer(kind=c_int), intent(inout) :: iflag type(c_ptr), value :: udata","tags":"","loc":"interface/minpack_func.html"},{"title":"minpack_func2 – minpack","text":"abstract interface public subroutine minpack_func2(m, n, x, fvec, iflag, udata) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(in) :: x (n) real(kind=c_double), intent(out) :: fvec (m) integer(kind=c_int), intent(inout) :: iflag type(c_ptr), value :: udata","tags":"","loc":"interface/minpack_func2.html"},{"title":"minpack_fcn_hybrj – minpack","text":"abstract interface public subroutine minpack_fcn_hybrj(n, x, fvec, fjac, ldfjac, iflag, udata) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n real(kind=c_double), intent(in) :: x (n) real(kind=c_double), intent(out) :: fvec (n) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac integer(kind=c_int), intent(inout) :: iflag type(c_ptr), value :: udata","tags":"","loc":"interface/minpack_fcn_hybrj.html"},{"title":"minpack_fcn_lmder – minpack","text":"abstract interface public subroutine minpack_fcn_lmder(m, n, x, fvec, fjac, ldfjac, iflag, udata) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(in) :: x (n) real(kind=c_double), intent(inout) :: fvec (m) real(kind=c_double), intent(inout) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac integer(kind=c_int), intent(inout) :: iflag type(c_ptr), value :: udata","tags":"","loc":"interface/minpack_fcn_lmder.html"},{"title":"minpack_fcn_lmstr – minpack","text":"abstract interface public subroutine minpack_fcn_lmstr(m, n, x, fvec, fjrow, iflag, udata) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(in) :: x (n) real(kind=c_double), intent(inout) :: fvec (m) real(kind=c_double), intent(inout) :: fjrow (n) integer(kind=c_int), intent(inout) :: iflag type(c_ptr), value :: udata","tags":"","loc":"interface/minpack_fcn_lmstr.html"},{"title":"enorm – minpack","text":"public pure function enorm(n, x) given an n-vector x, this function calculates the\neuclidean norm of x. the euclidean norm is computed by accumulating the sum of\nsquares in three different sums. the sums of squares for the\nsmall and large components are scaled so that no overflows\noccur. non-destructive underflows are permitted. underflows\nand overflows do not occur in the computation of the unscaled\nsum of squares for the intermediate components.\nthe definitions of small, intermediate and large components\ndepend on two constants, rdwarf and rgiant. the main\nrestrictions on these constants are that rdwarf 2 not\nunderflow and rgiant 2 not overflow. the constants\ngiven here are suitable for every known computer. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable. real(kind=wp), intent(in) :: x (n) an input array of length n. Return Value real(kind=wp) Called by proc~~enorm~~CalledByGraph proc~enorm enorm proc~hybrj hybrj proc~hybrj->proc~enorm proc~qrfac qrfac proc~hybrj->proc~qrfac proc~dogleg dogleg proc~hybrj->proc~dogleg proc~qrfac->proc~enorm proc~lmpar lmpar proc~lmpar->proc~enorm proc~lmdif lmdif proc~lmdif->proc~enorm proc~lmdif->proc~qrfac proc~lmder lmder proc~lmder->proc~enorm proc~lmder->proc~qrfac proc~hybrd hybrd proc~hybrd->proc~enorm proc~hybrd->proc~qrfac proc~hybrd->proc~dogleg proc~dogleg->proc~enorm proc~lmstr lmstr proc~lmstr->proc~enorm proc~lmstr->proc~qrfac proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~minpack_lmdif minpack_lmdif proc~minpack_lmdif->proc~lmdif proc~lmder1 lmder1 proc~lmder1->proc~lmder proc~minpack_lmstr minpack_lmstr proc~minpack_lmstr->proc~lmstr proc~minpack_hybrj minpack_hybrj proc~minpack_hybrj->proc~hybrj proc~minpack_lmder minpack_lmder proc~minpack_lmder->proc~lmder proc~minpack_hybrd minpack_hybrd proc~minpack_hybrd->proc~hybrd proc~lmstr1 lmstr1 proc~lmstr1->proc~lmstr proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~lmdif1 lmdif1 proc~lmdif1->proc~lmdif proc~minpack_hybrd1 minpack_hybrd1 proc~minpack_hybrd1->proc~hybrd1 proc~minpack_lmstr1 minpack_lmstr1 proc~minpack_lmstr1->proc~lmstr1 proc~minpack_hybrj1 minpack_hybrj1 proc~minpack_hybrj1->proc~hybrj1 proc~minpack_lmder1 minpack_lmder1 proc~minpack_lmder1->proc~lmder1 proc~minpack_lmdif1 minpack_lmdif1 proc~minpack_lmdif1->proc~lmdif1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i agiant s1 s2 s3 xabs x1max x3max rdwarf rgiant Variables Type Visibility Attributes Name Initial integer, public :: i real(kind=wp), public :: agiant real(kind=wp), public :: s1 real(kind=wp), public :: s2 real(kind=wp), public :: s3 real(kind=wp), public :: xabs real(kind=wp), public :: x1max real(kind=wp), public :: x3max real(kind=wp), public, parameter :: rdwarf = 3.834e-20_wp real(kind=wp), public, parameter :: rgiant = 1.304e19_wp","tags":"","loc":"proc/enorm.html"},{"title":"chkder – minpack","text":"public subroutine chkder(m, n, x, Fvec, Fjac, Ldfjac, Xp, Fvecp, Mode, Err) this subroutine checks the gradients of m nonlinear functions\nin n variables, evaluated at a point x, for consistency with\nthe functions themselves. the subroutine does not perform reliably if cancellation or\nrounding errors cause a severe loss of significance in the\nevaluation of a function. therefore, none of the components\nof x should be unusually small (in particular, zero) or any\nother value which may cause loss of significance. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. real(kind=wp), intent(in) :: x (n) input array real(kind=wp), intent(in) :: Fvec (m) an array of length m. on input when mode = 2,\nfvec must contain the functions evaluated at x. real(kind=wp), intent(in) :: Fjac (Ldfjac,n) an m by n array. on input when mode = 2,\nthe rows of fjac must contain the gradients of\nthe respective functions evaluated at x. integer, intent(in) :: Ldfjac a positive integer input parameter not less than m\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(out) :: Xp (n) an array of length n. on output when mode = 1,\nxp is set to a neighboring point of x. real(kind=wp), intent(in) :: Fvecp (m) an array of length m. on input when mode = 2,\nfvecp must contain the functions evaluated at xp. integer, intent(in) :: Mode an integer input variable set to 1 on the first call\nand 2 on the second. other values of mode are equivalent\nto mode = 1. the user must call chkder twice,\nfirst with mode = 1 and then with mode = 2. mode = 1. on input , x must contain the point of evaluation. on output , xp is set to a neighboring point. mode = 2. on input , fvec must contain the functions and the\n   rows of fjac must contain the gradients\n   of the respective functions each evaluated\n   at x, and fvecp must contain the functions\n   evaluated at xp. on output , err contains measures of correctness of\n   the respective gradients. real(kind=wp), intent(out) :: Err (m) an array of length m. on output when mode = 2,\nerr contains measures of correctness of the respective\ngradients. if there is no severe loss of significance,\nthen if err(i) is 1.0 the i-th gradient is correct,\nwhile if err(i) is 0.0 the i-th gradient is incorrect.\nfor values of err between 0.0 and 1.0, the categorization\nis less certain. in general, a value of err(i) greater\nthan 0.5 indicates that the i-th gradient is probably\ncorrect, while a value of err(i) less than 0.5 indicates\nthat the i-th gradient is probably incorrect. Called by proc~~chkder~~CalledByGraph proc~chkder chkder proc~minpack_chkder minpack_chkder proc~minpack_chkder->proc~chkder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j temp eps factor epsf epslog Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=wp), public :: temp real(kind=wp), public, parameter :: eps = sqrt(epsmch) real(kind=wp), public, parameter :: factor = 100.0_wp real(kind=wp), public, parameter :: epsf = factor*epsmch real(kind=wp), public, parameter :: epslog = log10(eps)","tags":"","loc":"proc/chkder.html"},{"title":"dogleg – minpack","text":"public subroutine dogleg(n, r, Lr, Diag, Qtb, Delta, x, Wa1, Wa2) given an m by n matrix a, an n by n nonsingular diagonal\nmatrix d, an m-vector b, and a positive number delta, the\nproblem is to determine the convex combination x of the\ngauss-newton and scaled gradient directions that minimizes\n(a x - b) in the least squares sense, subject to the\nrestriction that the euclidean norm of d x be at most delta. this subroutine completes the solution of the problem\nif it is provided with the necessary information from the\nqr factorization of a. that is, if a = q r, where q has\northogonal columns and r is an upper triangular matrix,\nthen dogleg expects the full upper triangle of r and\nthe first n components of (q transpose) b. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the order of r. real(kind=wp), intent(in) :: r (Lr) an input array of length lr which must contain the upper\ntriangular matrix r stored by rows. integer, intent(in) :: Lr a positive integer input variable not less than (n*(n+1))/2. real(kind=wp), intent(in) :: Diag (n) an input array of length n which must contain the\ndiagonal elements of the matrix d. real(kind=wp), intent(in) :: Qtb (n) an input array of length n which must contain the first\nn elements of the vector (q transpose)*b. real(kind=wp), intent(in) :: Delta a positive input variable which specifies an upper\nbound on the euclidean norm of d*x. real(kind=wp), intent(out) :: x (n) an output array of length n which contains the desired\nconvex combination of the gauss-newton direction and the\nscaled gradient direction. real(kind=wp), intent(inout) :: Wa1 (n) work arrays of length n real(kind=wp), intent(inout) :: Wa2 (n) work arrays of length n Calls proc~~dogleg~~CallsGraph proc~dogleg dogleg proc~enorm enorm proc~dogleg->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dogleg~~CalledByGraph proc~dogleg dogleg proc~hybrd hybrd proc~hybrd->proc~dogleg proc~hybrj hybrj proc~hybrj->proc~dogleg proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~minpack_hybrj minpack_hybrj proc~minpack_hybrj->proc~hybrj proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~minpack_hybrd minpack_hybrd proc~minpack_hybrd->proc~hybrd proc~minpack_hybrj1 minpack_hybrj1 proc~minpack_hybrj1->proc~hybrj1 proc~minpack_hybrd1 minpack_hybrd1 proc~minpack_hybrd1->proc~hybrd1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j jj jp1 k l alpha bnorm gnorm qnorm sgnorm sum temp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: jj integer, public :: jp1 integer, public :: k integer, public :: l real(kind=wp), public :: alpha real(kind=wp), public :: bnorm real(kind=wp), public :: gnorm real(kind=wp), public :: qnorm real(kind=wp), public :: sgnorm real(kind=wp), public :: sum real(kind=wp), public :: temp","tags":"","loc":"proc/dogleg.html"},{"title":"fdjac1 – minpack","text":"public subroutine fdjac1(fcn, n, x, Fvec, Fjac, Ldfjac, Iflag, Ml, Mu, Epsfcn, Wa1, Wa2) this subroutine computes a forward-difference approximation\nto the n by n jacobian matrix associated with a specified\nproblem of n functions in n variables. if the jacobian has\na banded form, then function evaluations are saved by only\napproximating the nonzero terms. Arguments Type Intent Optional Attributes Name procedure( func ) :: fcn the user-supplied subroutine which\ncalculates the functions. integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout) :: x (n) an input array of length n. real(kind=wp), intent(in) :: Fvec (n) an input array of length n which must contain the\nfunctions evaluated at x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output n by n array which contains the\napproximation to the jacobian matrix evaluated at x. integer, intent(in) :: Ldfjac a positive integer input variable not less than n\nwhich specifies the leading dimension of the array fjac. integer, intent(out) :: Iflag an integer variable which can be used to terminate\nthe execution of fdjac1. see description of func . integer, intent(in) :: Ml a nonnegative integer input variable which specifies\nthe number of subdiagonals within the band of the\njacobian matrix. if the jacobian is not banded, set\nml to at least n - 1. integer, intent(in) :: Mu a nonnegative integer input variable which specifies\nthe number of superdiagonals within the band of the\njacobian matrix. if the jacobian is not banded, set\nmu to at least n - 1. real(kind=wp), intent(in) :: Epsfcn an input variable used in determining a suitable\nstep length for the forward-difference approximation. this\napproximation assumes that the relative errors in the\nfunctions are of the order of epsfcn. if epsfcn is less\nthan the machine precision, it is assumed that the relative\nerrors in the functions are of the order of the machine\nprecision. real(kind=wp), intent(inout) :: Wa1 (n) work array of length n. real(kind=wp), intent(inout) :: Wa2 (n) work array of length n. if ml + mu + 1 is at\nleast n, then the jacobian is considered dense, and wa2 is\nnot referenced. Called by proc~~fdjac1~~CalledByGraph proc~fdjac1 fdjac1 proc~hybrd hybrd proc~hybrd->proc~fdjac1 proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~minpack_hybrd minpack_hybrd proc~minpack_hybrd->proc~hybrd proc~minpack_hybrd1 minpack_hybrd1 proc~minpack_hybrd1->proc~hybrd1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j k msum eps h temp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: k integer, public :: msum real(kind=wp), public :: eps real(kind=wp), public :: h real(kind=wp), public :: temp","tags":"","loc":"proc/fdjac1.html"},{"title":"fdjac2 – minpack","text":"public subroutine fdjac2(fcn, m, n, x, Fvec, Fjac, Ldfjac, Iflag, Epsfcn, Wa) this subroutine computes a forward-difference approximation\nto the m by n jacobian matrix associated with a specified\nproblem of m functions in n variables. Arguments Type Intent Optional Attributes Name procedure( func2 ) :: fcn the user-supplied subroutine which\ncalculates the functions. integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an input array of length n. real(kind=wp), intent(in) :: Fvec (m) an input array of length m which must contain the\nfunctions evaluated at x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output m by n array which contains the\napproximation to the jacobian matrix evaluated at x. integer, intent(in) :: Ldfjac a positive integer input variable not less than m\nwhich specifies the leading dimension of the array fjac. integer, intent(out) :: Iflag an integer variable which can be used to terminate\nthe execution of fdjac2. see description of func2 . real(kind=wp), intent(in) :: Epsfcn an input variable used in determining a suitable\nstep length for the forward-difference approximation. this\napproximation assumes that the relative errors in the\nfunctions are of the order of epsfcn. if epsfcn is less\nthan the machine precision, it is assumed that the relative\nerrors in the functions are of the order of the machine\nprecision. real(kind=wp), intent(inout) :: Wa (m) a work array of length m. Called by proc~~fdjac2~~CalledByGraph proc~fdjac2 fdjac2 proc~lmdif lmdif proc~lmdif->proc~fdjac2 proc~lmdif1 lmdif1 proc~lmdif1->proc~lmdif proc~minpack_lmdif minpack_lmdif proc~minpack_lmdif->proc~lmdif proc~minpack_lmdif1 minpack_lmdif1 proc~minpack_lmdif1->proc~lmdif1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j eps h temp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=wp), public :: eps real(kind=wp), public :: h real(kind=wp), public :: temp","tags":"","loc":"proc/fdjac2.html"},{"title":"hybrd – minpack","text":"public subroutine hybrd(fcn, n, x, fvec, xtol, maxfev, ml, mu, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, r, lr, qtf, wa1, wa2, wa3, wa4) the purpose of hybrd is to find a zero of a system of\nn nonlinear functions in n variables by a modification\nof the powell hybrid method. the user must provide a\nsubroutine which calculates the functions. the jacobian is\nthen calculated by a forward-difference approximation. Arguments Type Intent Optional Attributes Name procedure( func ) :: fcn user-supplied subroutine which calculates the functions integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout) :: x (n) array of length n. on input x must contain\nan initial estimate of the solution vector. on output x contains the final estimate of the solution vector. real(kind=wp), intent(out) :: fvec (n) an output array of length n which contains\nthe functions evaluated at the output x . real(kind=wp), intent(in) :: xtol a nonnegative input variable. termination\noccurs when the relative error between two consecutive\niterates is at most xtol . integer, intent(in) :: maxfev a positive integer input variable. termination\noccurs when the number of calls to fcn is at least maxfev by the end of an iteration. integer, intent(in) :: ml a nonnegative integer input variable which specifies\nthe number of subdiagonals within the band of the\njacobian matrix. if the jacobian is not banded, set ml to at least n - 1 . integer, intent(in) :: mu a nonnegative integer input variable which specifies\nthe number of superdiagonals within the band of the\njacobian matrix. if the jacobian is not banded, set mu to at least n - 1 . real(kind=wp), intent(in) :: epsfcn an input variable used in determining a suitable\nstep length for the forward-difference approximation. this\napproximation assumes that the relative errors in the\nfunctions are of the order of epsfcn . if epsfcn is less\nthan the machine precision, it is assumed that the relative\nerrors in the functions are of the order of the machine\nprecision. real(kind=wp), intent(inout) :: diag (n) an array of length n . if mode = 1 (see\nbelow), diag is internally set. if mode = 2 , diag must contain positive entries that serve as\nmultiplicative scale factors for the variables. integer, intent(in) :: mode if mode = 1 , the\nvariables will be scaled internally. if mode = 2 ,\nthe scaling is specified by the input diag . other\nvalues of mode are equivalent to mode = 1 . real(kind=wp), intent(in) :: factor a positive input variable used in determining the\ninitial step bound. this bound is set to the product of factor and the euclidean norm of diag*x if nonzero, or else\nto factor itself. in most cases factor should lie in the\ninterval (.1,100.). 100. is a generally recommended value. integer, intent(in) :: nprint an integer input variable that enables controlled\nprinting of iterates if it is positive. in this case, fcn is called with iflag = 0 at the beginning of the first\niteration and every nprint iterations thereafter and\nimmediately prior to return, with x and fvec available\nfor printing. if nprint is not positive, no special calls\nof fcn with iflag = 0 are made. integer, intent(out) :: info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag . see description of fcn . otherwise, info is set as follows: info = 0 improper input parameters. info = 1 relative error between two consecutive iterates\n   is at most xtol . info = 2 number of calls to fcn has reached or exceeded maxfev . info = 3 xtol is too small. no further improvement in\n   the approximate solution x is possible. info = 4 iteration is not making good progress, as\n   measured by the improvement from the last\n   five jacobian evaluations. info = 5 iteration is not making good progress, as\n   measured by the improvement from the last\n   ten iterations. integer, intent(out) :: nfev output variable set to the number of calls to fcn . real(kind=wp), intent(out) :: fjac (ldfjac,n) array which contains the\northogonal matrix q produced by the QR factorization\nof the final approximate jacobian. integer, intent(in) :: ldfjac a positive integer input variable not less than n which specifies the leading dimension of the array fjac . real(kind=wp), intent(out) :: r (lr) an output array which contains the\nupper triangular matrix produced by the QR factorization\nof the final approximate jacobian, stored rowwise. integer, intent(in) :: lr a positive integer input variable not less than (n*(n+1))/2 . real(kind=wp), intent(out) :: qtf (n) an output array of length n which contains\nthe vector (q transpose)*fvec . real(kind=wp), intent(inout) :: wa1 (n) work array real(kind=wp), intent(inout) :: wa2 (n) work array real(kind=wp), intent(inout) :: wa3 (n) work array real(kind=wp), intent(inout) :: wa4 (n) work array Calls proc~~hybrd~~CallsGraph proc~hybrd hybrd proc~r1mpyq r1mpyq proc~hybrd->proc~r1mpyq proc~qrfac qrfac proc~hybrd->proc~qrfac proc~r1updt r1updt proc~hybrd->proc~r1updt proc~enorm enorm proc~hybrd->proc~enorm proc~dogleg dogleg proc~hybrd->proc~dogleg proc~qform qform proc~hybrd->proc~qform proc~fdjac1 fdjac1 proc~hybrd->proc~fdjac1 proc~qrfac->proc~enorm proc~dogleg->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~hybrd~~CalledByGraph proc~hybrd hybrd proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~minpack_hybrd minpack_hybrd proc~minpack_hybrd->proc~hybrd proc~minpack_hybrd1 minpack_hybrd1 proc~minpack_hybrd1->proc~hybrd1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i iflag iter j jm1 l msum ncfail ncsuc nslow1 nslow2 iwa jeval sing actred delta fnorm fnorm1 pnorm prered ratio sum temp xnorm p1 p5 p001 p0001 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iflag integer, public :: iter integer, public :: j integer, public :: jm1 integer, public :: l integer, public :: msum integer, public :: ncfail integer, public :: ncsuc integer, public :: nslow1 integer, public :: nslow2 integer, public :: iwa (1) logical, public :: jeval logical, public :: sing real(kind=wp), public :: actred real(kind=wp), public :: delta real(kind=wp), public :: fnorm real(kind=wp), public :: fnorm1 real(kind=wp), public :: pnorm real(kind=wp), public :: prered real(kind=wp), public :: ratio real(kind=wp), public :: sum real(kind=wp), public :: temp real(kind=wp), public :: xnorm real(kind=wp), public, parameter :: p1 = 1.0e-1_wp real(kind=wp), public, parameter :: p5 = 5.0e-1_wp real(kind=wp), public, parameter :: p001 = 1.0e-3_wp real(kind=wp), public, parameter :: p0001 = 1.0e-4_wp","tags":"","loc":"proc/hybrd.html"},{"title":"hybrd1 – minpack","text":"public subroutine hybrd1(fcn, n, x, fvec, tol, info, Wa, Lwa) the purpose of hybrd1 is to find a zero of a system of\nn nonlinear functions in n variables by a modification\nof the powell hybrid method. this is done by using the\nmore general nonlinear equation solver hybrd. the user\nmust provide a subroutine which calculates the functions.\nthe jacobian is then calculated by a forward-difference\napproximation. Arguments Type Intent Optional Attributes Name procedure( func ) :: fcn user-supplied subroutine which calculates the functions integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout), dimension(n) :: x an array of length n . on input x must contain\nan initial estimate of the solution vector. on output x contains the final estimate of the solution vector. real(kind=wp), intent(out), dimension(n) :: fvec an output array of length n which contains\nthe functions evaluated at the output x . real(kind=wp), intent(in) :: tol a nonnegative input variable. termination occurs\nwhen the algorithm estimates that the relative error\nbetween x and the solution is at most tol . integer, intent(out) :: info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag . see description of fcn . otherwise, info is set as follows: info = 0 improper input parameters. info = 1 algorithm estimates that the relative error\n between x and the solution is at most tol . info = 2 number of calls to fcn has reached or exceeded 200*(n+1) . info = 3 tol is too small. no further improvement in\n the approximate solution x is possible. info = 4 iteration is not making good progress. real(kind=wp), intent(inout) :: Wa (Lwa) a work array of length lwa. integer, intent(in) :: Lwa a positive integer input variable not less than\n(n (3 n+13))/2. Calls proc~~hybrd1~~CallsGraph proc~hybrd1 hybrd1 proc~hybrd hybrd proc~hybrd1->proc~hybrd proc~r1mpyq r1mpyq proc~hybrd->proc~r1mpyq proc~qrfac qrfac proc~hybrd->proc~qrfac proc~r1updt r1updt proc~hybrd->proc~r1updt proc~enorm enorm proc~hybrd->proc~enorm proc~dogleg dogleg proc~hybrd->proc~dogleg proc~qform qform proc~hybrd->proc~qform proc~fdjac1 fdjac1 proc~hybrd->proc~fdjac1 proc~qrfac->proc~enorm proc~dogleg->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~hybrd1~~CalledByGraph proc~hybrd1 hybrd1 proc~minpack_hybrd1 minpack_hybrd1 proc~minpack_hybrd1->proc~hybrd1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables index j lr maxfev ml mode mu nfev nprint epsfcn xtol factor Variables Type Visibility Attributes Name Initial integer, public :: index integer, public :: j integer, public :: lr integer, public :: maxfev integer, public :: ml integer, public :: mode integer, public :: mu integer, public :: nfev integer, public :: nprint real(kind=wp), public :: epsfcn real(kind=wp), public :: xtol real(kind=wp), public, parameter :: factor = 100.0_wp","tags":"","loc":"proc/hybrd1.html"},{"title":"hybrj – minpack","text":"public subroutine hybrj(fcn, n, x, Fvec, Fjac, Ldfjac, Xtol, Maxfev, Diag, Mode, Factor, Nprint, Info, Nfev, Njev, r, Lr, Qtf, Wa1, Wa2, Wa3, Wa4) the purpose of hybrj is to find a zero of a system of\nn nonlinear functions in n variables by a modification\nof the powell hybrid method. the user must provide a\nsubroutine which calculates the functions and the jacobian. Arguments Type Intent Optional Attributes Name procedure( fcn_hybrj ) :: fcn the user-supplied subroutine which\ncalculates the functions and the jacobian integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (n) an output array of length n which contains\nthe functions evaluated at the output x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output n by n array which contains the\northogonal matrix q produced by the qr factorization\nof the final approximate jacobian. integer, intent(in) :: Ldfjac a positive integer input variable not less than n\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(in) :: Xtol a nonnegative input variable. termination\noccurs when the relative error between two consecutive\niterates is at most xtol. integer, intent(in) :: Maxfev a positive integer input variable. termination\noccurs when the number of calls to fcn with iflag = 1\nhas reached maxfev. real(kind=wp), intent(inout) :: Diag (n) an array of length n. if mode = 1 (see\nbelow), diag is internally set. if mode = 2, diag\nmust contain positive entries that serve as\nmultiplicative scale factors for the variables. integer, intent(in) :: Mode an integer input variable. if mode = 1, the\nvariables will be scaled internally. if mode = 2,\nthe scaling is specified by the input diag. other\nvalues of mode are equivalent to mode = 1. real(kind=wp), intent(in) :: Factor a positive input variable used in determining the\ninitial step bound. this bound is set to the product of\nfactor and the euclidean norm of diag*x if nonzero, or else\nto factor itself. in most cases factor should lie in the\ninterval (.1,100.). 100. is a generally recommended value. integer, intent(in) :: Nprint an integer input variable that enables controlled\nprinting of iterates if it is positive. in this case,\nfcn is called with iflag = 0 at the beginning of the first\niteration and every nprint iterations thereafter and\nimmediately prior to return, with x and fvec available\nfor printing. fvec and fjac should not be altered.\nif nprint is not positive, no special calls of fcn\nwith iflag = 0 are made. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 relative error between two consecutive iterates\n   is at most xtol. info = 2 number of calls to fcn with iflag = 1 has\n   reached maxfev. info = 3 xtol is too small. no further improvement in\n   the approximate solution x is possible. info = 4 iteration is not making good progress, as\n   measured by the improvement from the last\n   five jacobian evaluations. info = 5 iteration is not making good progress, as\n   measured by the improvement from the last\n   ten iterations. integer, intent(out) :: Nfev an integer output variable set to the number of\ncalls to fcn with iflag = 1. integer, intent(out) :: Njev an integer output variable set to the number of\ncalls to fcn with iflag = 2. real(kind=wp), intent(out) :: r (Lr) an output array of length lr which contains the\nupper triangular matrix produced by the qr factorization\nof the final approximate jacobian, stored rowwise. integer, intent(in) :: Lr a positive integer input variable not less than\n(n*(n+1))/2. real(kind=wp), intent(out) :: Qtf (n) an output array of length n which contains\nthe vector (q transpose)*fvec. real(kind=wp), intent(inout) :: Wa1 (n) work array of length n. real(kind=wp), intent(inout) :: Wa2 (n) work array of length n. real(kind=wp), intent(inout) :: Wa3 (n) work array of length n. real(kind=wp), intent(inout) :: Wa4 (n) work array of length n. Calls proc~~hybrj~~CallsGraph proc~hybrj hybrj proc~r1mpyq r1mpyq proc~hybrj->proc~r1mpyq proc~qrfac qrfac proc~hybrj->proc~qrfac proc~r1updt r1updt proc~hybrj->proc~r1updt proc~enorm enorm proc~hybrj->proc~enorm proc~dogleg dogleg proc~hybrj->proc~dogleg proc~qform qform proc~hybrj->proc~qform proc~qrfac->proc~enorm proc~dogleg->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~hybrj~~CalledByGraph proc~hybrj hybrj proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~minpack_hybrj minpack_hybrj proc~minpack_hybrj->proc~hybrj proc~minpack_hybrj1 minpack_hybrj1 proc~minpack_hybrj1->proc~hybrj1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i iflag iter j jm1 l ncfail ncsuc nslow1 nslow2 iwa jeval sing actred delta fnorm fnorm1 pnorm prered ratio sum temp xnorm p1 p5 p001 p0001 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iflag integer, public :: iter integer, public :: j integer, public :: jm1 integer, public :: l integer, public :: ncfail integer, public :: ncsuc integer, public :: nslow1 integer, public :: nslow2 integer, public :: iwa (1) logical, public :: jeval logical, public :: sing real(kind=wp), public :: actred real(kind=wp), public :: delta real(kind=wp), public :: fnorm real(kind=wp), public :: fnorm1 real(kind=wp), public :: pnorm real(kind=wp), public :: prered real(kind=wp), public :: ratio real(kind=wp), public :: sum real(kind=wp), public :: temp real(kind=wp), public :: xnorm real(kind=wp), public, parameter :: p1 = 1.0e-1_wp real(kind=wp), public, parameter :: p5 = 5.0e-1_wp real(kind=wp), public, parameter :: p001 = 1.0e-3_wp real(kind=wp), public, parameter :: p0001 = 1.0e-4_wp","tags":"","loc":"proc/hybrj.html"},{"title":"hybrj1 – minpack","text":"public subroutine hybrj1(fcn, n, x, Fvec, Fjac, Ldfjac, Tol, Info, Wa, Lwa) the purpose of hybrj1 is to find a zero of a system of\nn nonlinear functions in n variables by a modification\nof the powell hybrid method. this is done by using the\nmore general nonlinear equation solver hybrj. the user\nmust provide a subroutine which calculates the functions\nand the jacobian. Arguments Type Intent Optional Attributes Name procedure( fcn_hybrj ) :: fcn the user-supplied subroutine which\ncalculates the functions and the jacobian integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (n) an output array of length n which contains\nthe functions evaluated at the output x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output n by n array which contains the\northogonal matrix q produced by the qr factorization\nof the final approximate jacobian. integer, intent(in) :: Ldfjac a positive integer input variable not less than n\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(in) :: Tol a nonnegative input variable. termination occurs\nwhen the algorithm estimates that the relative error\nbetween x and the solution is at most tol. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 algorithm estimates that the relative error\n   between x and the solution is at most tol. info = 2 number of calls to fcn with iflag = 1 has\n   reached 100*(n+1). info = 3 tol is too small. no further improvement in\n   the approximate solution x is possible. info = 4 iteration is not making good progress. real(kind=wp), intent(inout) :: Wa (Lwa) a work array of length lwa. integer, intent(in) :: Lwa a positive integer input variable not less than\n(n*(n+13))/2. Calls proc~~hybrj1~~CallsGraph proc~hybrj1 hybrj1 proc~hybrj hybrj proc~hybrj1->proc~hybrj proc~r1mpyq r1mpyq proc~hybrj->proc~r1mpyq proc~qrfac qrfac proc~hybrj->proc~qrfac proc~r1updt r1updt proc~hybrj->proc~r1updt proc~enorm enorm proc~hybrj->proc~enorm proc~dogleg dogleg proc~hybrj->proc~dogleg proc~qform qform proc~hybrj->proc~qform proc~qrfac->proc~enorm proc~dogleg->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~hybrj1~~CalledByGraph proc~hybrj1 hybrj1 proc~minpack_hybrj1 minpack_hybrj1 proc~minpack_hybrj1->proc~hybrj1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables j lr maxfev mode nfev njev nprint xtol factor Variables Type Visibility Attributes Name Initial integer, public :: j integer, public :: lr integer, public :: maxfev integer, public :: mode integer, public :: nfev integer, public :: njev integer, public :: nprint real(kind=wp), public :: xtol real(kind=wp), public, parameter :: factor = 100.0_wp","tags":"","loc":"proc/hybrj1.html"},{"title":"lmder – minpack","text":"public subroutine lmder(fcn, m, n, x, Fvec, Fjac, Ldfjac, Ftol, Xtol, Gtol, Maxfev, Diag, Mode, Factor, Nprint, Info, Nfev, Njev, Ipvt, Qtf, Wa1, Wa2, Wa3, Wa4) the purpose of lmder is to minimize the sum of the squares of\nm nonlinear functions in n variables by a modification of\nthe levenberg-marquardt algorithm. the user must provide a\nsubroutine which calculates the functions and the jacobian. Arguments Type Intent Optional Attributes Name procedure( fcn_lmder ) :: fcn the user-supplied subroutine which\ncalculates the functions and the jacobian integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (m) an output array of length m which contains\nthe functions evaluated at the output x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output m by n array. the upper n by n submatrix\n of fjac contains an upper triangular matrix r with\n diagonal elements of nonincreasing magnitude such that t     t           t\n       p *(jac *jac)*p = r *r, where p is a permutation matrix and jac is the final\n calculated jacobian. column j of p is column ipvt(j)\n (see below) of the identity matrix. the lower trapezoidal\n part of fjac contains information generated during\n the computation of r. integer, intent(in) :: Ldfjac a positive integer input variable not less than m\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(in) :: Ftol a nonnegative input variable. termination\noccurs when both the actual and predicted relative\nreductions in the sum of squares are at most ftol.\ntherefore, ftol measures the relative error desired\nin the sum of squares. real(kind=wp), intent(in) :: Xtol a nonnegative input variable. termination\noccurs when the relative error between two consecutive\niterates is at most xtol. therefore, xtol measures the\nrelative error desired in the approximate solution. real(kind=wp), intent(in) :: Gtol a nonnegative input variable. termination\noccurs when the cosine of the angle between fvec and\nany column of the jacobian is at most gtol in absolute\nvalue. therefore, gtol measures the orthogonality\ndesired between the function vector and the columns\nof the jacobian. integer, intent(in) :: Maxfev a positive integer input variable. termination\noccurs when the number of calls to fcn with iflag = 1\nhas reached maxfev. real(kind=wp), intent(inout) :: Diag (n) an array of length n. if mode = 1 (see\nbelow), diag is internally set. if mode = 2, diag\nmust contain positive entries that serve as\nmultiplicative scale factors for the variables. integer, intent(in) :: Mode an integer input variable. if mode = 1, the\nvariables will be scaled internally. if mode = 2,\nthe scaling is specified by the input diag. other\nvalues of mode are equivalent to mode = 1. real(kind=wp), intent(in) :: Factor a positive input variable used in determining the\ninitial step bound. this bound is set to the product of\nfactor and the euclidean norm of diag*x if nonzero, or else\nto factor itself. in most cases factor should lie in the\ninterval (.1,100.).100. is a generally recommended value. integer, intent(in) :: Nprint an integer input variable that enables controlled\nprinting of iterates if it is positive. in this case,\nfcn is called with iflag = 0 at the beginning of the first\niteration and every nprint iterations thereafter and\nimmediately prior to return, with x, fvec, and fjac\navailable for printing. fvec and fjac should not be\naltered. if nprint is not positive, no special calls\nof fcn with iflag = 0 are made. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 both actual and predicted relative reductions\n   in the sum of squares are at most ftol. info = 2 relative error between two consecutive iterates\n   is at most xtol. info = 3 conditions for info = 1 and info = 2 both hold. info = 4 the cosine of the angle between fvec and any\n   column of the jacobian is at most gtol in\n   absolute value. info = 5 number of calls to fcn with iflag = 1 has\n   reached maxfev. info = 6 ftol is too small. no further reduction in\n   the sum of squares is possible. info = 7 xtol is too small. no further improvement in\n   the approximate solution x is possible. info = 8 gtol is too small. fvec is orthogonal to the\n   columns of the jacobian to machine precision. integer, intent(out) :: Nfev an integer output variable set to the number of\ncalls to fcn with iflag = 1. integer, intent(out) :: Njev an integer output variable set to the number of\ncalls to fcn with iflag = 2. integer, intent(out) :: Ipvt (n) an integer output array of length n. ipvt\ndefines a permutation matrix p such that jac p = q r,\nwhere jac is the final calculated jacobian, q is\northogonal (not stored), and r is upper triangular\nwith diagonal elements of nonincreasing magnitude.\ncolumn j of p is column ipvt(j) of the identity matrix. real(kind=wp), intent(out) :: Qtf (n) an output array of length n which contains\nthe first n elements of the vector (q transpose)*fvec. real(kind=wp), intent(inout) :: Wa1 (n) work array of length n. real(kind=wp), intent(inout) :: Wa2 (n) work array of length n. real(kind=wp), intent(inout) :: Wa3 (n) work array of length n. real(kind=wp), intent(inout) :: Wa4 (m) work array of length n. Calls proc~~lmder~~CallsGraph proc~lmder lmder proc~qrfac qrfac proc~lmder->proc~qrfac proc~enorm enorm proc~lmder->proc~enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lmder~~CalledByGraph proc~lmder lmder proc~minpack_lmder minpack_lmder proc~minpack_lmder->proc~lmder proc~lmder1 lmder1 proc~lmder1->proc~lmder proc~minpack_lmder1 minpack_lmder1 proc~minpack_lmder1->proc~lmder1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i iflag iter j l actred delta dirder fnorm fnorm1 gnorm par pnorm prered ratio sum temp temp1 temp2 xnorm p1 p5 p25 p75 p0001 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iflag integer, public :: iter integer, public :: j integer, public :: l real(kind=wp), public :: actred real(kind=wp), public :: delta real(kind=wp), public :: dirder real(kind=wp), public :: fnorm real(kind=wp), public :: fnorm1 real(kind=wp), public :: gnorm real(kind=wp), public :: par real(kind=wp), public :: pnorm real(kind=wp), public :: prered real(kind=wp), public :: ratio real(kind=wp), public :: sum real(kind=wp), public :: temp real(kind=wp), public :: temp1 real(kind=wp), public :: temp2 real(kind=wp), public :: xnorm real(kind=wp), public, parameter :: p1 = 1.0e-1_wp real(kind=wp), public, parameter :: p5 = 5.0e-1_wp real(kind=wp), public, parameter :: p25 = 2.5e-1_wp real(kind=wp), public, parameter :: p75 = 7.5e-1_wp real(kind=wp), public, parameter :: p0001 = 1.0e-4_wp","tags":"","loc":"proc/lmder.html"},{"title":"lmder1 – minpack","text":"public subroutine lmder1(fcn, m, n, x, Fvec, Fjac, Ldfjac, Tol, Info, Ipvt, Wa, Lwa) the purpose of lmder1 is to minimize the sum of the squares of\nm nonlinear functions in n variables by a modification of the\nlevenberg-marquardt algorithm. this is done by using the more\ngeneral least-squares solver lmder. the user must provide a\nsubroutine which calculates the functions and the jacobian. Arguments Type Intent Optional Attributes Name procedure( fcn_lmder ) :: fcn user-supplied subroutine which\ncalculates the functions and the jacobian. integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (m) an output array of length m which contains\nthe functions evaluated at the output x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output m by n array. the upper n by n submatrix\n of fjac contains an upper triangular matrix r with\n diagonal elements of nonincreasing magnitude such that t     t           t\n       p *(jac *jac)*p = r *r, where p is a permutation matrix and jac is the final\n calculated jacobian. column j of p is column ipvt(j)\n (see below) of the identity matrix. the lower trapezoidal\n part of fjac contains information generated during\n the computation of r. integer, intent(in) :: Ldfjac a positive integer input variable not less than m\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(in) :: Tol a nonnegative input variable. termination occurs\nwhen the algorithm estimates either that the relative\nerror in the sum of squares is at most tol or that\nthe relative error between x and the solution is at\nmost tol. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows. info = 0 improper input parameters. info = 1 algorithm estimates that the relative error\n   in the sum of squares is at most tol. info = 2 algorithm estimates that the relative error\n   between x and the solution is at most tol. info = 3 conditions for info = 1 and info = 2 both hold. info = 4 fvec is orthogonal to the columns of the\n   jacobian to machine precision. info = 5 number of calls to fcn with iflag = 1 has\n   reached 100*(n+1). info = 6 tol is too small. no further reduction in\n   the sum of squares is possible. info = 7 tol is too small. no further improvement in\n   the approximate solution x is possible. integer, intent(out) :: Ipvt (n) an integer output array of length n. ipvt\ndefines a permutation matrix p such that jac p = q r,\nwhere jac is the final calculated jacobian, q is\northogonal (not stored), and r is upper triangular\nwith diagonal elements of nonincreasing magnitude.\ncolumn j of p is column ipvt(j) of the identity matrix. real(kind=wp), intent(inout) :: Wa (Lwa) a work array of length lwa. integer, intent(in) :: Lwa a positive integer input variable not less than 5*n+m. Calls proc~~lmder1~~CallsGraph proc~lmder1 lmder1 proc~lmder lmder proc~lmder1->proc~lmder proc~qrfac qrfac proc~lmder->proc~qrfac proc~enorm enorm proc~lmder->proc~enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lmder1~~CalledByGraph proc~lmder1 lmder1 proc~minpack_lmder1 minpack_lmder1 proc~minpack_lmder1->proc~lmder1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables maxfev mode nfev njev nprint ftol gtol xtol factor Variables Type Visibility Attributes Name Initial integer, public :: maxfev integer, public :: mode integer, public :: nfev integer, public :: njev integer, public :: nprint real(kind=wp), public :: ftol real(kind=wp), public :: gtol real(kind=wp), public :: xtol real(kind=wp), public, parameter :: factor = 100.0_wp","tags":"","loc":"proc/lmder1.html"},{"title":"lmdif – minpack","text":"public subroutine lmdif(fcn, m, n, x, Fvec, Ftol, Xtol, Gtol, Maxfev, Epsfcn, Diag, Mode, Factor, Nprint, Info, Nfev, Fjac, Ldfjac, Ipvt, Qtf, Wa1, Wa2, Wa3, Wa4) the purpose of lmdif is to minimize the sum of the squares of\nm nonlinear functions in n variables by a modification of\nthe levenberg-marquardt algorithm. the user must provide a\nsubroutine which calculates the functions. the jacobian is\nthen calculated by a forward-difference approximation. Arguments Type Intent Optional Attributes Name procedure( func2 ) :: fcn the user-supplied subroutine which\ncalculates the functions. integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (m) an output array of length m which contains\nthe functions evaluated at the output x. real(kind=wp), intent(in) :: Ftol a nonnegative input variable. termination\noccurs when both the actual and predicted relative\nreductions in the sum of squares are at most ftol.\ntherefore, ftol measures the relative error desired\nin the sum of squares. real(kind=wp), intent(in) :: Xtol a nonnegative input variable. termination\noccurs when the relative error between two consecutive\niterates is at most xtol. therefore, xtol measures the\nrelative error desired in the approximate solution. real(kind=wp), intent(in) :: Gtol a nonnegative input variable. termination\noccurs when the cosine of the angle between fvec and\nany column of the jacobian is at most gtol in absolute\nvalue. therefore, gtol measures the orthogonality\ndesired between the function vector and the columns\nof the jacobian. integer, intent(in) :: Maxfev a positive integer input variable. termination\noccurs when the number of calls to fcn is at least\nmaxfev by the end of an iteration. real(kind=wp), intent(in) :: Epsfcn an input variable used in determining a suitable\nstep length for the forward-difference approximation. this\napproximation assumes that the relative errors in the\nfunctions are of the order of epsfcn. if epsfcn is less\nthan the machine precision, it is assumed that the relative\nerrors in the functions are of the order of the machine\nprecision. real(kind=wp), intent(inout) :: Diag (n) an array of length n. if mode = 1 (see\nbelow), diag is internally set. if mode = 2, diag\nmust contain positive entries that serve as\nmultiplicative scale factors for the variables. integer, intent(in) :: Mode an integer input variable. if mode = 1, the\nvariables will be scaled internally. if mode = 2,\nthe scaling is specified by the input diag. other\nvalues of mode are equivalent to mode = 1. real(kind=wp), intent(in) :: Factor a positive input variable used in determining the\ninitial step bound. this bound is set to the product of\nfactor and the euclidean norm of diag*x if nonzero, or else\nto factor itself. in most cases factor should lie in the\ninterval (.1,100.). 100. is a generally recommended value. integer, intent(in) :: Nprint an integer input variable that enables controlled\nprinting of iterates if it is positive. in this case,\nfcn is called with iflag = 0 at the beginning of the first\niteration and every nprint iterations thereafter and\nimmediately prior to return, with x and fvec available\nfor printing. if nprint is not positive, no special calls\nof fcn with iflag = 0 are made. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 both actual and predicted relative reductions\n   in the sum of squares are at most ftol. info = 2 relative error between two consecutive iterates\n   is at most xtol. info = 3 conditions for info = 1 and info = 2 both hold. info = 4 the cosine of the angle between fvec and any\n   column of the jacobian is at most gtol in\n   absolute value. info = 5 number of calls to fcn has reached or\n   exceeded maxfev. info = 6 ftol is too small. no further reduction in\n   the sum of squares is possible. info = 7 xtol is too small. no further improvement in\n   the approximate solution x is possible. info = 8 gtol is too small. fvec is orthogonal to the\n   columns of the jacobian to machine precision. integer, intent(out) :: Nfev an integer output variable set to the number of\ncalls to fcn. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output m by n array. the upper n by n submatrix\n of fjac contains an upper triangular matrix r with\n diagonal elements of nonincreasing magnitude such that t     t           t\n       p *(jac *jac)*p = r *r, where p is a permutation matrix and jac is the final\n calculated jacobian. column j of p is column ipvt(j)\n (see below) of the identity matrix. the lower trapezoidal\n part of fjac contains information generated during\n the computation of r. integer, intent(in) :: Ldfjac a positive integer input variable not less than m\nwhich specifies the leading dimension of the array fjac. integer, intent(out) :: Ipvt (n) an integer output array of length n. ipvt\ndefines a permutation matrix p such that jac p = q r,\nwhere jac is the final calculated jacobian, q is\northogonal (not stored), and r is upper triangular\nwith diagonal elements of nonincreasing magnitude.\ncolumn j of p is column ipvt(j) of the identity matrix. real(kind=wp), intent(out) :: Qtf (n) an output array of length n which contains\nthe first n elements of the vector (q transpose)*fvec. real(kind=wp), intent(inout) :: Wa1 (n) work array of length n. real(kind=wp), intent(inout) :: Wa2 (n) work array of length n. real(kind=wp), intent(inout) :: Wa3 (n) work array of length n. real(kind=wp), intent(inout) :: Wa4 (m) work array of length n. Calls proc~~lmdif~~CallsGraph proc~lmdif lmdif proc~fdjac2 fdjac2 proc~lmdif->proc~fdjac2 proc~qrfac qrfac proc~lmdif->proc~qrfac proc~enorm enorm proc~lmdif->proc~enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lmdif~~CalledByGraph proc~lmdif lmdif proc~lmdif1 lmdif1 proc~lmdif1->proc~lmdif proc~minpack_lmdif minpack_lmdif proc~minpack_lmdif->proc~lmdif proc~minpack_lmdif1 minpack_lmdif1 proc~minpack_lmdif1->proc~lmdif1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i iflag iter j l actred delta dirder fnorm fnorm1 gnorm par pnorm prered ratio sum temp temp1 temp2 xnorm p1 p5 p25 p75 p0001 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iflag integer, public :: iter integer, public :: j integer, public :: l real(kind=wp), public :: actred real(kind=wp), public :: delta real(kind=wp), public :: dirder real(kind=wp), public :: fnorm real(kind=wp), public :: fnorm1 real(kind=wp), public :: gnorm real(kind=wp), public :: par real(kind=wp), public :: pnorm real(kind=wp), public :: prered real(kind=wp), public :: ratio real(kind=wp), public :: sum real(kind=wp), public :: temp real(kind=wp), public :: temp1 real(kind=wp), public :: temp2 real(kind=wp), public :: xnorm real(kind=wp), public, parameter :: p1 = 1.0e-1_wp real(kind=wp), public, parameter :: p5 = 5.0e-1_wp real(kind=wp), public, parameter :: p25 = 2.5e-1_wp real(kind=wp), public, parameter :: p75 = 7.5e-1_wp real(kind=wp), public, parameter :: p0001 = 1.0e-4_wp","tags":"","loc":"proc/lmdif.html"},{"title":"lmdif1 – minpack","text":"public subroutine lmdif1(fcn, m, n, x, Fvec, Tol, Info, Iwa, Wa, Lwa) the purpose of lmdif1 is to minimize the sum of the squares of\nm nonlinear functions in n variables by a modification of the\nlevenberg-marquardt algorithm. this is done by using the more\ngeneral least-squares solver lmdif. the user must provide a\nsubroutine which calculates the functions. the jacobian is\nthen calculated by a forward-difference approximation. Arguments Type Intent Optional Attributes Name procedure( func2 ) :: fcn the user-supplied subroutine which\ncalculates the functions. integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (m) an output array of length m which contains\nthe functions evaluated at the output x. real(kind=wp), intent(in) :: Tol a nonnegative input variable. termination occurs\nwhen the algorithm estimates either that the relative\nerror in the sum of squares is at most tol or that\nthe relative error between x and the solution is at\nmost tol. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 algorithm estimates that the relative error\n   in the sum of squares is at most tol. info = 2 algorithm estimates that the relative error\n   between x and the solution is at most tol. info = 3 conditions for info = 1 and info = 2 both hold. info = 4 fvec is orthogonal to the columns of the\n   jacobian to machine precision. info = 5 number of calls to fcn has reached or\n   exceeded 200*(n+1). info = 6 tol is too small. no further reduction in\n   the sum of squares is possible. info = 7 tol is too small. no further improvement in\n   the approximate solution x is possible. integer, intent(inout) :: Iwa (n) an integer work array of length n. real(kind=wp), intent(inout) :: Wa (Lwa) a work array of length lwa. integer, intent(in) :: Lwa a positive integer input variable not less than\nm n+5 n+m. Calls proc~~lmdif1~~CallsGraph proc~lmdif1 lmdif1 proc~lmdif lmdif proc~lmdif1->proc~lmdif proc~fdjac2 fdjac2 proc~lmdif->proc~fdjac2 proc~qrfac qrfac proc~lmdif->proc~qrfac proc~enorm enorm proc~lmdif->proc~enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lmdif1~~CalledByGraph proc~lmdif1 lmdif1 proc~minpack_lmdif1 minpack_lmdif1 proc~minpack_lmdif1->proc~lmdif1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables maxfev mode mp5n nfev nprint epsfcn ftol gtol xtol factor Variables Type Visibility Attributes Name Initial integer, public :: maxfev integer, public :: mode integer, public :: mp5n integer, public :: nfev integer, public :: nprint real(kind=wp), public :: epsfcn real(kind=wp), public :: ftol real(kind=wp), public :: gtol real(kind=wp), public :: xtol real(kind=wp), public, parameter :: factor = 1.0e2_wp","tags":"","loc":"proc/lmdif1.html"},{"title":"lmpar – minpack","text":"public subroutine lmpar(n, r, Ldr, Ipvt, Diag, Qtb, Delta, Par, x, Sdiag, Wa1, Wa2) given an m by n matrix a, an n by n nonsingular diagonal\n  matrix d, an m-vector b, and a positive number delta,\n  the problem is to determine a value for the parameter\n  par such that if x solves the system a*x = b ,     sqrt(par)*d*x = 0 , in the least squares sense, and dxnorm is the euclidean\n  norm of d*x, then either par is zero and (dxnorm-delta) <= 0.1*delta , or par is positive and abs(dxnorm-delta) <= 0.1*delta . this subroutine completes the solution of the problem\n  if it is provided with the necessary information from the\n  qr factorization, with column pivoting, of a. that is, if\n  a p = q r, where p is a permutation matrix, q has orthogonal\n  columns, and r is an upper triangular matrix with diagonal\n  elements of nonincreasing magnitude, then lmpar expects\n  the full upper triangle of r, the permutation matrix p,\n  and the first n components of (q transpose)*b. on output\n  lmpar also provides an upper triangular matrix s such that t   t                   t\n        p *(a *a + par*d*d)*p = s *s . s is employed within lmpar and may be of separate interest. only a few iterations are generally needed for convergence\n  of the algorithm. if, however, the limit of 10 iterations\n  is reached, then the output par will contain the best\n  value obtained so far. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the order of r. real(kind=wp), intent(inout) :: r (Ldr,n) an n by n array. on input the full upper triangle\nmust contain the full upper triangle of the matrix r.\non output the full upper triangle is unaltered, and the\nstrict lower triangle contains the strict upper triangle\n(transposed) of the upper triangular matrix s. integer, intent(in) :: Ldr a positive integer input variable not less than n\nwhich specifies the leading dimension of the array r. integer, intent(in) :: Ipvt (n) an integer input array of length n which defines the\npermutation matrix p such that a p = q r. column j of p\nis column ipvt(j) of the identity matrix. real(kind=wp), intent(in) :: Diag (n) an input array of length n which must contain the\ndiagonal elements of the matrix d. real(kind=wp), intent(in) :: Qtb (n) an input array of length n which must contain the first\nn elements of the vector (q transpose)*b. real(kind=wp) :: Delta a positive input variable which specifies an upper\nbound on the euclidean norm of d*x. real(kind=wp), intent(inout) :: Par a nonnegative variable. on input par contains an\ninitial estimate of the levenberg-marquardt parameter.\non output par contains the final estimate. real(kind=wp), intent(out) :: x (n) an output array of length n which contains the least\nsquares solution of the system a x = b, sqrt(par) d*x = 0,\nfor the output par. real(kind=wp), intent(out) :: Sdiag (n) an output array of length n which contains the\ndiagonal elements of the upper triangular matrix s. real(kind=wp), intent(inout) :: Wa1 (n) work array of length n. real(kind=wp), intent(inout) :: Wa2 (n) work array of length n. Calls proc~~lmpar~~CallsGraph proc~lmpar lmpar proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~enorm enorm proc~lmpar->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i iter j jm1 jp1 k l nsing dxnorm fp gnorm parc parl paru sum temp p1 p001 dwarf Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iter integer, public :: j integer, public :: jm1 integer, public :: jp1 integer, public :: k integer, public :: l integer, public :: nsing real(kind=wp), public :: dxnorm real(kind=wp), public :: fp real(kind=wp), public :: gnorm real(kind=wp), public :: parc real(kind=wp), public :: parl real(kind=wp), public :: paru real(kind=wp), public :: sum real(kind=wp), public :: temp real(kind=wp), public, parameter :: p1 = 1.0e-1_wp real(kind=wp), public, parameter :: p001 = 1.0e-3_wp real(kind=wp), public, parameter :: dwarf = dpmpar(2) the smallest positive magnitude","tags":"","loc":"proc/lmpar.html"},{"title":"lmstr – minpack","text":"public subroutine lmstr(fcn, m, n, x, Fvec, Fjac, Ldfjac, Ftol, Xtol, Gtol, Maxfev, Diag, Mode, Factor, Nprint, Info, Nfev, Njev, Ipvt, Qtf, Wa1, Wa2, Wa3, Wa4) the purpose of lmstr is to minimize the sum of the squares of\nm nonlinear functions in n variables by a modification of\nthe levenberg-marquardt algorithm which uses minimal storage.\nthe user must provide a subroutine which calculates the\nfunctions and the rows of the jacobian. Arguments Type Intent Optional Attributes Name procedure( fcn_lmstr ) :: fcn user-supplied subroutine which\ncalculates the functions and the rows of the jacobian. integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (m) an output array of length m which contains\nthe functions evaluated at the output x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output n by n array. the upper triangle of fjac\n contains an upper triangular matrix r such that t     t           t\n       p *(jac *jac)*p = r *r, where p is a permutation matrix and jac is the final\n calculated jacobian. column j of p is column ipvt(j)\n (see below) of the identity matrix. the lower triangular\n part of fjac contains information generated during\n the computation of r. integer, intent(in) :: Ldfjac a positive integer input variable not less than n\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(in) :: Ftol a nonnegative input variable. termination\noccurs when both the actual and predicted relative\nreductions in the sum of squares are at most ftol.\ntherefore, ftol measures the relative error desired\nin the sum of squares. real(kind=wp), intent(in) :: Xtol a nonnegative input variable. termination\noccurs when the relative error between two consecutive\niterates is at most xtol. therefore, xtol measures the\nrelative error desired in the approximate solution. real(kind=wp), intent(in) :: Gtol a nonnegative input variable. termination\noccurs when the cosine of the angle between fvec and\nany column of the jacobian is at most gtol in absolute\nvalue. therefore, gtol measures the orthogonality\ndesired between the function vector and the columns\nof the jacobian. integer, intent(in) :: Maxfev a positive integer input variable. termination\noccurs when the number of calls to fcn with iflag = 1\nhas reached maxfev. real(kind=wp), intent(inout) :: Diag (n) an array of length n. if mode = 1 (see\nbelow), diag is internally set. if mode = 2, diag\nmust contain positive entries that serve as\nmultiplicative scale factors for the variables. integer, intent(in) :: Mode an integer input variable. if mode = 1, the\nvariables will be scaled internally. if mode = 2,\nthe scaling is specified by the input diag. other\nvalues of mode are equivalent to mode = 1. real(kind=wp), intent(in) :: Factor a positive input variable used in determining the\ninitial step bound. this bound is set to the product of\nfactor and the euclidean norm of diag*x if nonzero, or else\nto factor itself. in most cases factor should lie in the\ninterval (.1,100.). 100. is a generally recommended value. integer, intent(in) :: Nprint an integer input variable that enables controlled\nprinting of iterates if it is positive. in this case,\nfcn is called with iflag = 0 at the beginning of the first\niteration and every nprint iterations thereafter and\nimmediately prior to return, with x and fvec available\nfor printing. if nprint is not positive, no special calls\nof fcn with iflag = 0 are made. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 both actual and predicted relative reductions\n   in the sum of squares are at most ftol. info = 2 relative error between two consecutive iterates\n   is at most xtol. info = 3 conditions for info = 1 and info = 2 both hold. info = 4 the cosine of the angle between fvec and any\n   column of the jacobian is at most gtol in\n   absolute value. info = 5 number of calls to fcn with iflag = 1 has\n   reached maxfev. info = 6 ftol is too small. no further reduction in\n   the sum of squares is possible. info = 7 xtol is too small. no further improvement in\n   the approximate solution x is possible. info = 8 gtol is too small. fvec is orthogonal to the\n   columns of the jacobian to machine precision. integer, intent(out) :: Nfev an integer output variable set to the number of\ncalls to fcn with iflag = 1. integer, intent(out) :: Njev an integer output variable set to the number of\ncalls to fcn with iflag = 2. integer, intent(out) :: Ipvt (n) an integer output array of length n. ipvt\ndefines a permutation matrix p such that jac p = q r,\nwhere jac is the final calculated jacobian, q is\northogonal (not stored), and r is upper triangular.\ncolumn j of p is column ipvt(j) of the identity matrix. real(kind=wp), intent(out) :: Qtf (n) an output array of length n which contains\nthe first n elements of the vector (q transpose)*fvec. real(kind=wp), intent(inout) :: Wa1 (n) work array of length n. real(kind=wp), intent(inout) :: Wa2 (n) work array of length n. real(kind=wp), intent(inout) :: Wa3 (n) work array of length n. real(kind=wp), intent(inout) :: Wa4 (m) work array of length m. Calls proc~~lmstr~~CallsGraph proc~lmstr lmstr proc~rwupdt rwupdt proc~lmstr->proc~rwupdt proc~qrfac qrfac proc~lmstr->proc~qrfac proc~enorm enorm proc~lmstr->proc~enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lmstr~~CalledByGraph proc~lmstr lmstr proc~lmstr1 lmstr1 proc~lmstr1->proc~lmstr proc~minpack_lmstr minpack_lmstr proc~minpack_lmstr->proc~lmstr proc~minpack_lmstr1 minpack_lmstr1 proc~minpack_lmstr1->proc~lmstr1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i iflag iter j l actred delta dirder fnorm fnorm1 gnorm par pnorm prered ratio sum temp temp1 temp2 xnorm sing p1 p5 p25 p75 p0001 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: iflag integer, public :: iter integer, public :: j integer, public :: l real(kind=wp), public :: actred real(kind=wp), public :: delta real(kind=wp), public :: dirder real(kind=wp), public :: fnorm real(kind=wp), public :: fnorm1 real(kind=wp), public :: gnorm real(kind=wp), public :: par real(kind=wp), public :: pnorm real(kind=wp), public :: prered real(kind=wp), public :: ratio real(kind=wp), public :: sum real(kind=wp), public :: temp real(kind=wp), public :: temp1 real(kind=wp), public :: temp2 real(kind=wp), public :: xnorm logical, public :: sing real(kind=wp), public, parameter :: p1 = 1.0e-1_wp real(kind=wp), public, parameter :: p5 = 5.0e-1_wp real(kind=wp), public, parameter :: p25 = 2.5e-1_wp real(kind=wp), public, parameter :: p75 = 7.5e-1_wp real(kind=wp), public, parameter :: p0001 = 1.0e-4_wp","tags":"","loc":"proc/lmstr.html"},{"title":"lmstr1 – minpack","text":"public subroutine lmstr1(fcn, m, n, x, Fvec, Fjac, Ldfjac, Tol, Info, Ipvt, Wa, Lwa) the purpose of lmstr1 is to minimize the sum of the squares of\nm nonlinear functions in n variables by a modification of\nthe levenberg-marquardt algorithm which uses minimal storage.\nthis is done by using the more general least-squares solver\nlmstr. the user must provide a subroutine which calculates\nthe functions and the rows of the jacobian. Arguments Type Intent Optional Attributes Name procedure( fcn_lmstr ) :: fcn user-supplied subroutine which\ncalculates the functions and the rows of the jacobian. integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (m) an output array of length m which contains\nthe functions evaluated at the output x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output n by n array. the upper triangle of fjac\n contains an upper triangular matrix r such that t     t           t\n       p *(jac *jac)*p = r *r, where p is a permutation matrix and jac is the final\n calculated jacobian. column j of p is column ipvt(j)\n (see below) of the identity matrix. the lower triangular\n part of fjac contains information generated during\n the computation of r. integer, intent(in) :: Ldfjac a positive integer input variable not less than n\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(in) :: Tol a nonnegative input variable. termination occurs\nwhen the algorithm estimates either that the relative\nerror in the sum of squares is at most tol or that\nthe relative error between x and the solution is at\nmost tol. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 algorithm estimates that the relative error\n          in the sum of squares is at most tol. info = 2 algorithm estimates that the relative error\n          between x and the solution is at most tol. info = 3 conditions for info = 1 and info = 2 both hold. info = 4 fvec is orthogonal to the columns of the\n          jacobian to machine precision. info = 5 number of calls to fcn with iflag = 1 has\n          reached 100*(n+1). info = 6 tol is too small. no further reduction in\n          the sum of squares is possible. info = 7 tol is too small. no further improvement in\n          the approximate solution x is possible. integer, intent(out) :: Ipvt (n) an integer output array of length n. ipvt\ndefines a permutation matrix p such that jac p = q r,\nwhere jac is the final calculated jacobian, q is\northogonal (not stored), and r is upper triangular.\ncolumn j of p is column ipvt(j) of the identity matrix. real(kind=wp), intent(inout) :: Wa (Lwa) a work array of length lwa. integer, intent(in) :: Lwa a positive integer input variable not less than 5*n+m. Calls proc~~lmstr1~~CallsGraph proc~lmstr1 lmstr1 proc~lmstr lmstr proc~lmstr1->proc~lmstr proc~rwupdt rwupdt proc~lmstr->proc~rwupdt proc~qrfac qrfac proc~lmstr->proc~qrfac proc~enorm enorm proc~lmstr->proc~enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lmstr1~~CalledByGraph proc~lmstr1 lmstr1 proc~minpack_lmstr1 minpack_lmstr1 proc~minpack_lmstr1->proc~lmstr1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables maxfev mode nfev njev nprint ftol gtol xtol factor Variables Type Visibility Attributes Name Initial integer, public :: maxfev integer, public :: mode integer, public :: nfev integer, public :: njev integer, public :: nprint real(kind=wp), public :: ftol real(kind=wp), public :: gtol real(kind=wp), public :: xtol real(kind=wp), public, parameter :: factor = 1.0e2_wp","tags":"","loc":"proc/lmstr1.html"},{"title":"qform – minpack","text":"public subroutine qform(m, n, q, Ldq, Wa) this subroutine proceeds from the computed qr factorization of\nan m by n matrix a to accumulate the m by m orthogonal matrix\nq from its factored form. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a and the order of q. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a. real(kind=wp), intent(inout) :: q (Ldq,m) an m by m array. on input the full lower trapezoid in\nthe first min(m,n) columns of q contains the factored form.\non output q has been accumulated into a square matrix. integer, intent(in) :: Ldq a positive integer input variable not less than m\nwhich specifies the leading dimension of the array q. real(kind=wp), intent(inout) :: Wa (m) a work array of length m. Called by proc~~qform~~CalledByGraph proc~qform qform proc~hybrd hybrd proc~hybrd->proc~qform proc~hybrj hybrj proc~hybrj->proc~qform proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~minpack_hybrj minpack_hybrj proc~minpack_hybrj->proc~hybrj proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~minpack_hybrd minpack_hybrd proc~minpack_hybrd->proc~hybrd proc~minpack_hybrj1 minpack_hybrj1 proc~minpack_hybrj1->proc~hybrj1 proc~minpack_hybrd1 minpack_hybrd1 proc~minpack_hybrd1->proc~hybrd1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j jm1 k l minmn np1 sum temp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: jm1 integer, public :: k integer, public :: l integer, public :: minmn integer, public :: np1 real(kind=wp), public :: sum real(kind=wp), public :: temp","tags":"","loc":"proc/qform.html"},{"title":"qrfac – minpack","text":"public subroutine qrfac(m, n, a, Lda, Pivot, Ipvt, Lipvt, Rdiag, Acnorm, Wa) this subroutine uses householder transformations with column\n  pivoting (optional) to compute a qr factorization of the\n  m by n matrix a. that is, qrfac determines an orthogonal\n  matrix q, a permutation matrix p, and an upper trapezoidal\n  matrix r with diagonal elements of nonincreasing magnitude,\n  such that a p = q r. the householder transformation for\n  column k, k = 1,2,...,min(m,n), is of the form t\n        i - (1/u(k))*u*u where u has zeros in the first k-1 positions. the form of\n  this transformation and the method of pivoting first\n  appeared in the corresponding linpack subroutine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a. real(kind=wp), intent(inout) :: a (Lda,n) an m by n array. on input a contains the matrix for\nwhich the qr factorization is to be computed. on output\nthe strict upper trapezoidal part of a contains the strict\nupper trapezoidal part of r, and the lower trapezoidal\npart of a contains a factored form of q (the non-trivial\nelements of the u vectors described above). integer, intent(in) :: Lda a positive integer input variable not less than m\nwhich specifies the leading dimension of the array a. logical, intent(in) :: Pivot a logical input variable. if pivot is set true,\nthen column pivoting is enforced. if pivot is set false,\nthen no column pivoting is done. integer, intent(out) :: Ipvt (Lipvt) an integer output array of length lipvt. ipvt\ndefines the permutation matrix p such that a p = q r.\ncolumn j of p is column ipvt(j) of the identity matrix.\nif pivot is false, ipvt is not referenced. integer, intent(in) :: Lipvt a positive integer input variable. if pivot is false,\nthen lipvt may be as small as 1. if pivot is true, then\nlipvt must be at least n. real(kind=wp), intent(out) :: Rdiag (n) an output array of length n which contains the\ndiagonal elements of r. real(kind=wp), intent(out) :: Acnorm (n) an output array of length n which contains the\nnorms of the corresponding columns of the input matrix a.\nif this information is not needed, then acnorm can coincide\nwith rdiag. real(kind=wp), intent(inout) :: Wa (n) a work array of length n. if pivot is false, then wa\ncan coincide with rdiag. Calls proc~~qrfac~~CallsGraph proc~qrfac qrfac proc~enorm enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~qrfac~~CalledByGraph proc~qrfac qrfac proc~hybrj hybrj proc~hybrj->proc~qrfac proc~lmdif lmdif proc~lmdif->proc~qrfac proc~lmder lmder proc~lmder->proc~qrfac proc~hybrd hybrd proc~hybrd->proc~qrfac proc~lmstr lmstr proc~lmstr->proc~qrfac proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~minpack_lmdif minpack_lmdif proc~minpack_lmdif->proc~lmdif proc~lmder1 lmder1 proc~lmder1->proc~lmder proc~minpack_lmstr minpack_lmstr proc~minpack_lmstr->proc~lmstr proc~minpack_hybrj minpack_hybrj proc~minpack_hybrj->proc~hybrj proc~minpack_lmder minpack_lmder proc~minpack_lmder->proc~lmder proc~minpack_hybrd minpack_hybrd proc~minpack_hybrd->proc~hybrd proc~lmstr1 lmstr1 proc~lmstr1->proc~lmstr proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~lmdif1 lmdif1 proc~lmdif1->proc~lmdif proc~minpack_hybrd1 minpack_hybrd1 proc~minpack_hybrd1->proc~hybrd1 proc~minpack_lmstr1 minpack_lmstr1 proc~minpack_lmstr1->proc~lmstr1 proc~minpack_hybrj1 minpack_hybrj1 proc~minpack_hybrj1->proc~hybrj1 proc~minpack_lmder1 minpack_lmder1 proc~minpack_lmder1->proc~lmder1 proc~minpack_lmdif1 minpack_lmdif1 proc~minpack_lmdif1->proc~lmdif1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j jp1 k kmax minmn ajnorm sum temp p05 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: jp1 integer, public :: k integer, public :: kmax integer, public :: minmn real(kind=wp), public :: ajnorm real(kind=wp), public :: sum real(kind=wp), public :: temp real(kind=wp), public, parameter :: p05 = 5.0e-2_wp","tags":"","loc":"proc/qrfac.html"},{"title":"qrsolv – minpack","text":"public subroutine qrsolv(n, r, Ldr, Ipvt, Diag, Qtb, x, Sdiag, Wa) given an m by n matrix a, an n by n diagonal matrix d,\n  and an m-vector b, the problem is to determine an x which\n  solves the system a*x = b ,     d*x = 0 , in the least squares sense. this subroutine completes the solution of the problem\n  if it is provided with the necessary information from the\n  qr factorization, with column pivoting, of a. that is, if\n  a p = q r, where p is a permutation matrix, q has orthogonal\n  columns, and r is an upper triangular matrix with diagonal\n  elements of nonincreasing magnitude, then qrsolv expects\n  the full upper triangle of r, the permutation matrix p,\n  and the first n components of (q transpose) b. the system\n  a x = b, d*x = 0, is then equivalent to t       t\n        r*z = q *b ,  p *d*p*z = 0 , where x = p*z. if this system does not have full rank,\n  then a least squares solution is obtained. on output qrsolv\n  also provides an upper triangular matrix s such that t   t               t\n        p *(a *a + d*d)*p = s *s . s is computed within qrsolv and may be of separate interest. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the order of r. real(kind=wp), intent(inout) :: r (Ldr,n) an n by n array. on input the full upper triangle\nmust contain the full upper triangle of the matrix r.\non output the full upper triangle is unaltered, and the\nstrict lower triangle contains the strict upper triangle\n(transposed) of the upper triangular matrix s. integer, intent(in) :: Ldr a positive integer input variable not less than n\nwhich specifies the leading dimension of the array r. integer, intent(in) :: Ipvt (n) an integer input array of length n which defines the\npermutation matrix p such that a p = q r. column j of p\nis column ipvt(j) of the identity matrix. real(kind=wp), intent(in) :: Diag (n) an input array of length n which must contain the\ndiagonal elements of the matrix d. real(kind=wp), intent(in) :: Qtb (n) an input array of length n which must contain the first\nn elements of the vector (q transpose)*b. real(kind=wp), intent(out) :: x (n) an output array of length n which contains the least\nsquares solution of the system a x = b, d x = 0. real(kind=wp), intent(out) :: Sdiag (n) an output array of length n which contains the\ndiagonal elements of the upper triangular matrix s. real(kind=wp), intent(inout) :: Wa (n) a work array of length n. Called by proc~~qrsolv~~CalledByGraph proc~qrsolv qrsolv proc~lmpar lmpar proc~lmpar->proc~qrsolv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j jp1 k kp1 l nsing cos cotan qtbpj sin sum tan temp p5 p25 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: jp1 integer, public :: k integer, public :: kp1 integer, public :: l integer, public :: nsing real(kind=wp), public :: cos real(kind=wp), public :: cotan real(kind=wp), public :: qtbpj real(kind=wp), public :: sin real(kind=wp), public :: sum real(kind=wp), public :: tan real(kind=wp), public :: temp real(kind=wp), public, parameter :: p5 = 5.0e-1_wp real(kind=wp), public, parameter :: p25 = 2.5e-1_wp","tags":"","loc":"proc/qrsolv.html"},{"title":"r1mpyq – minpack","text":"public subroutine r1mpyq(m, n, a, Lda, v, w) given an m by n matrix a, this subroutine computes a q where\n  q is the product of 2 (n - 1) transformations gv(n-1)*...*gv(1)*gw(1)*...*gw(n-1) and gv(i), gw(i) are givens rotations in the (i,n) plane which\n  eliminate elements in the i-th and n-th planes, respectively.\n  q itself is not given, rather the information to recover the\n  gv, gw rotations is supplied. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a. real(kind=wp), intent(inout) :: a (Lda,n) an m by n array. on input a must contain the matrix\nto be postmultiplied by the orthogonal matrix q\ndescribed above. on output a*q has replaced a. integer, intent(in) :: Lda a positive integer input variable not less than m\nwhich specifies the leading dimension of the array a. real(kind=wp), intent(in) :: v (n) an input array of length n. v(i) must contain the\ninformation necessary to recover the givens rotation gv(i)\ndescribed above. real(kind=wp), intent(in) :: w (n) an input array of length n. w(i) must contain the\ninformation necessary to recover the givens rotation gw(i)\ndescribed above. Called by proc~~r1mpyq~~CalledByGraph proc~r1mpyq r1mpyq proc~hybrd hybrd proc~hybrd->proc~r1mpyq proc~hybrj hybrj proc~hybrj->proc~r1mpyq proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~minpack_hybrj minpack_hybrj proc~minpack_hybrj->proc~hybrj proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~minpack_hybrd minpack_hybrd proc~minpack_hybrd->proc~hybrd proc~minpack_hybrj1 minpack_hybrj1 proc~minpack_hybrj1->proc~hybrj1 proc~minpack_hybrd1 minpack_hybrd1 proc~minpack_hybrd1->proc~hybrd1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j nmj nm1 cos sin temp Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: nmj integer, public :: nm1 real(kind=wp), public :: cos real(kind=wp), public :: sin real(kind=wp), public :: temp","tags":"","loc":"proc/r1mpyq.html"},{"title":"r1updt – minpack","text":"public subroutine r1updt(m, n, s, Ls, u, v, w, Sing) given an m by n lower trapezoidal matrix s, an m-vector u,\n  and an n-vector v, the problem is to determine an\n  orthogonal matrix q such that t\n        (s + u*v )*q is again lower trapezoidal. this subroutine determines q as the product of 2*(n - 1)\n  transformations gv(n-1)*...*gv(1)*gw(1)*...*gw(n-1) where gv(i), gw(i) are givens rotations in the (i,n) plane\n  which eliminate elements in the i-th and n-th planes,\n  respectively. q itself is not accumulated, rather the\n  information to recover the gv, gw rotations is returned. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of s. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of s. n must not exceed m. real(kind=wp), intent(inout) :: s (Ls) an array of length ls. on input s must contain the lower\ntrapezoidal matrix s stored by columns. on output s contains\nthe lower trapezoidal matrix produced as described above. integer, intent(in) :: Ls a positive integer input variable not less than\n(n (2 m-n+1))/2. real(kind=wp), intent(in) :: u (m) an input array of length m which must contain the\nvector u. real(kind=wp), intent(inout) :: v (n) an array of length n. on input v must contain the vector\nv. on output v(i) contains the information necessary to\nrecover the givens rotation gv(i) described above. real(kind=wp), intent(out) :: w (m) an output array of length m. w(i) contains information\nnecessary to recover the givens rotation gw(i) described\nabove. logical, intent(out) :: Sing a logical output variable. sing is set true if any\nof the diagonal elements of the output s are zero. otherwise\nsing is set false. Called by proc~~r1updt~~CalledByGraph proc~r1updt r1updt proc~hybrd hybrd proc~hybrd->proc~r1updt proc~hybrj hybrj proc~hybrj->proc~r1updt proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~minpack_hybrj minpack_hybrj proc~minpack_hybrj->proc~hybrj proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~minpack_hybrd minpack_hybrd proc~minpack_hybrd->proc~hybrd proc~minpack_hybrj1 minpack_hybrj1 proc~minpack_hybrj1->proc~hybrj1 proc~minpack_hybrd1 minpack_hybrd1 proc~minpack_hybrd1->proc~hybrd1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j jj l nmj nm1 cos cotan sin tan tau temp p5 p25 giant Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: jj integer, public :: l integer, public :: nmj integer, public :: nm1 real(kind=wp), public :: cos real(kind=wp), public :: cotan real(kind=wp), public :: sin real(kind=wp), public :: tan real(kind=wp), public :: tau real(kind=wp), public :: temp real(kind=wp), public, parameter :: p5 = 5.0e-1_wp real(kind=wp), public, parameter :: p25 = 2.5e-1_wp real(kind=wp), public, parameter :: giant = dpmpar(3) the largest magnitude.","tags":"","loc":"proc/r1updt.html"},{"title":"rwupdt – minpack","text":"public subroutine rwupdt(n, r, Ldr, w, b, Alpha, Cos, Sin) given an n by n upper triangular matrix r, this subroutine\n  computes the qr decomposition of the matrix formed when a row\n  is added to r. if the row is specified by the vector w, then\n  rwupdt determines an orthogonal matrix q such that when the\n  n+1 by n matrix composed of r augmented by w is premultiplied\n  by (q transpose), the resulting matrix is upper trapezoidal.\n  the matrix (q transpose) is the product of n transformations g(n)*g(n-1)* ... *g(1) where g(i) is a givens rotation in the (i,n+1) plane which\n  eliminates elements in the (n+1)-st plane. rwupdt also\n  computes the product (q transpose)*c where c is the\n  (n+1)-vector (b,alpha). q itself is not accumulated, rather\n  the information to recover the g rotations is supplied. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the order of r. real(kind=wp), intent(inout) :: r (Ldr,n) an n by n array. on input the upper triangular part of\nr must contain the matrix to be updated. on output r\ncontains the updated triangular matrix. integer, intent(in) :: Ldr a positive integer input variable not less than n\nwhich specifies the leading dimension of the array r. real(kind=wp), intent(in) :: w (n) an input array of length n which must contain the row\nvector to be added to r. real(kind=wp), intent(inout) :: b (n) an array of length n. on input b must contain the\nfirst n elements of the vector c. on output b contains\nthe first n elements of the vector (q transpose)*c. real(kind=wp), intent(inout) :: Alpha a variable. on input alpha must contain the\n(n+1)-st element of the vector c. on output alpha contains\nthe (n+1)-st element of the vector (q transpose)*c. real(kind=wp), intent(out) :: Cos (n) an output array of length n which contains the\ncosines of the transforming givens rotations. real(kind=wp), intent(out) :: Sin (n) an output array of length n which contains the\nsines of the transforming givens rotations. Called by proc~~rwupdt~~CalledByGraph proc~rwupdt rwupdt proc~lmstr lmstr proc~lmstr->proc~rwupdt proc~lmstr1 lmstr1 proc~lmstr1->proc~lmstr proc~minpack_lmstr minpack_lmstr proc~minpack_lmstr->proc~lmstr proc~minpack_lmstr1 minpack_lmstr1 proc~minpack_lmstr1->proc~lmstr1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j jm1 cotan rowj tan temp p5 p25 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j integer, public :: jm1 real(kind=wp), public :: cotan real(kind=wp), public :: rowj real(kind=wp), public :: tan real(kind=wp), public :: temp real(kind=wp), public, parameter :: p5 = 5.0e-1_wp real(kind=wp), public, parameter :: p25 = 2.5e-1_wp","tags":"","loc":"proc/rwupdt.html"},{"title":"minpack_dpmpar – minpack","text":"public function minpack_dpmpar(i) result(par) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: i Return Value real(kind=c_double) Contents None","tags":"","loc":"proc/minpack_dpmpar.html"},{"title":"minpack_hybrd – minpack","text":"public subroutine minpack_hybrd(fcn, n, x, fvec, xtol, maxfev, ml, mu, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, r, lr, qtf, wa1, wa2, wa3, wa4, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_func ) :: fcn integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (n) real(kind=c_double), value :: xtol integer(kind=c_int), value :: maxfev integer(kind=c_int), value :: ml integer(kind=c_int), value :: mu real(kind=c_double), value :: epsfcn real(kind=c_double), intent(inout) :: diag (n) integer(kind=c_int), value :: mode real(kind=c_double), value :: factor integer(kind=c_int), value :: nprint integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: nfev real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), intent(out) :: r (lr) integer(kind=c_int), value :: lr real(kind=c_double), intent(out) :: qtf (n) real(kind=c_double), intent(inout) :: wa1 (n) real(kind=c_double), intent(inout) :: wa2 (n) real(kind=c_double), intent(inout) :: wa3 (n) real(kind=c_double), intent(inout) :: wa4 (n) type(c_ptr), value :: udata Calls proc~~minpack_hybrd~~CallsGraph proc~minpack_hybrd minpack_hybrd proc~hybrd hybrd proc~minpack_hybrd->proc~hybrd proc~r1mpyq r1mpyq proc~hybrd->proc~r1mpyq proc~qrfac qrfac proc~hybrd->proc~qrfac proc~r1updt r1updt proc~hybrd->proc~r1updt proc~enorm enorm proc~hybrd->proc~enorm proc~dogleg dogleg proc~hybrd->proc~dogleg proc~qform qform proc~hybrd->proc~qform proc~fdjac1 fdjac1 proc~hybrd->proc~fdjac1 proc~qrfac->proc~enorm proc~dogleg->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines wrap_fcn Subroutines subroutine wrap_fcn(n, x, fvec, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(out) :: fvec (n) integer, intent(inout) :: iflag","tags":"","loc":"proc/minpack_hybrd.html"},{"title":"minpack_hybrd1 – minpack","text":"public subroutine minpack_hybrd1(fcn, n, x, fvec, tol, info, Wa, Lwa, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_func ) :: fcn integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (n) real(kind=c_double), value :: tol integer(kind=c_int), intent(out) :: info real(kind=c_double), intent(inout) :: Wa (Lwa) integer(kind=c_int), value :: Lwa type(c_ptr), value :: udata Calls proc~~minpack_hybrd1~~CallsGraph proc~minpack_hybrd1 minpack_hybrd1 proc~hybrd1 hybrd1 proc~minpack_hybrd1->proc~hybrd1 proc~hybrd hybrd proc~hybrd1->proc~hybrd proc~r1mpyq r1mpyq proc~hybrd->proc~r1mpyq proc~qrfac qrfac proc~hybrd->proc~qrfac proc~r1updt r1updt proc~hybrd->proc~r1updt proc~enorm enorm proc~hybrd->proc~enorm proc~dogleg dogleg proc~hybrd->proc~dogleg proc~qform qform proc~hybrd->proc~qform proc~fdjac1 fdjac1 proc~hybrd->proc~fdjac1 proc~qrfac->proc~enorm proc~dogleg->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines wrap_fcn Subroutines subroutine wrap_fcn(n, x, fvec, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(out) :: fvec (n) integer, intent(inout) :: iflag","tags":"","loc":"proc/minpack_hybrd1.html"},{"title":"minpack_hybrj – minpack","text":"public subroutine minpack_hybrj(fcn, n, x, fvec, fjac, ldfjac, xtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, r, lr, qtf, wa1, wa2, wa3, wa4, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_fcn_hybrj ) :: fcn integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (n) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), value :: xtol integer(kind=c_int), value :: maxfev real(kind=c_double), intent(inout) :: diag (n) integer(kind=c_int), value :: mode real(kind=c_double), value :: factor integer(kind=c_int), value :: nprint integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: nfev integer(kind=c_int), intent(out) :: njev real(kind=c_double), intent(out) :: r (lr) integer(kind=c_int), value :: lr real(kind=c_double), intent(out) :: qtf (n) real(kind=c_double), intent(inout) :: wa1 (n) real(kind=c_double), intent(inout) :: wa2 (n) real(kind=c_double), intent(inout) :: wa3 (n) real(kind=c_double), intent(inout) :: wa4 (n) type(c_ptr), value :: udata Calls proc~~minpack_hybrj~~CallsGraph proc~minpack_hybrj minpack_hybrj proc~hybrj hybrj proc~minpack_hybrj->proc~hybrj proc~r1mpyq r1mpyq proc~hybrj->proc~r1mpyq proc~qrfac qrfac proc~hybrj->proc~qrfac proc~r1updt r1updt proc~hybrj->proc~r1updt proc~enorm enorm proc~hybrj->proc~enorm proc~dogleg dogleg proc~hybrj->proc~dogleg proc~qform qform proc~hybrj->proc~qform proc~qrfac->proc~enorm proc~dogleg->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines wrap_fcn Subroutines subroutine wrap_fcn(n, x, fvec, fjac, ldfjac, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(out) :: fvec (n) real(kind=wp), intent(out) :: fjac (ldfjac,n) integer, intent(in) :: ldfjac integer, intent(inout) :: iflag","tags":"","loc":"proc/minpack_hybrj.html"},{"title":"minpack_hybrj1 – minpack","text":"public subroutine minpack_hybrj1(fcn, n, x, fvec, fjac, ldfjac, tol, info, wa, lwa, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_fcn_hybrj ) :: fcn integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (n) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), value :: tol integer(kind=c_int), intent(out) :: info real(kind=c_double), intent(inout) :: wa (lwa) integer(kind=c_int), value :: lwa type(c_ptr), value :: udata Calls proc~~minpack_hybrj1~~CallsGraph proc~minpack_hybrj1 minpack_hybrj1 proc~hybrj1 hybrj1 proc~minpack_hybrj1->proc~hybrj1 proc~hybrj hybrj proc~hybrj1->proc~hybrj proc~r1mpyq r1mpyq proc~hybrj->proc~r1mpyq proc~qrfac qrfac proc~hybrj->proc~qrfac proc~r1updt r1updt proc~hybrj->proc~r1updt proc~enorm enorm proc~hybrj->proc~enorm proc~dogleg dogleg proc~hybrj->proc~dogleg proc~qform qform proc~hybrj->proc~qform proc~qrfac->proc~enorm proc~dogleg->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines wrap_fcn Subroutines subroutine wrap_fcn(n, x, fvec, fjac, ldfjac, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(out) :: fvec (n) real(kind=wp), intent(out) :: fjac (ldfjac,n) integer, intent(in) :: ldfjac integer, intent(inout) :: iflag","tags":"","loc":"proc/minpack_hybrj1.html"},{"title":"minpack_lmdif – minpack","text":"public subroutine minpack_lmdif(fcn, m, n, x, fvec, ftol, xtol, gtol, maxfev, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, ipvt, qtf, wa1, wa2, wa3, wa4, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_func2 ) :: fcn integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (m) real(kind=c_double), value :: ftol real(kind=c_double), value :: xtol real(kind=c_double), value :: gtol integer(kind=c_int), value :: maxfev real(kind=c_double), value :: epsfcn real(kind=c_double), intent(inout) :: diag (n) integer(kind=c_int), value :: mode real(kind=c_double), value :: factor integer(kind=c_int), value :: nprint integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: nfev real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac integer(kind=c_int), intent(out) :: ipvt (n) real(kind=c_double), intent(out) :: qtf (n) real(kind=c_double), intent(inout) :: wa1 (n) real(kind=c_double), intent(inout) :: wa2 (n) real(kind=c_double), intent(inout) :: wa3 (n) real(kind=c_double), intent(inout) :: wa4 (m) type(c_ptr), value :: udata Calls proc~~minpack_lmdif~~CallsGraph proc~minpack_lmdif minpack_lmdif proc~lmdif lmdif proc~minpack_lmdif->proc~lmdif proc~fdjac2 fdjac2 proc~lmdif->proc~fdjac2 proc~qrfac qrfac proc~lmdif->proc~qrfac proc~enorm enorm proc~lmdif->proc~enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines wrap_fcn Subroutines subroutine wrap_fcn(m, n, x, fvec, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(out) :: fvec (m) integer, intent(inout) :: iflag","tags":"","loc":"proc/minpack_lmdif.html"},{"title":"minpack_lmdif1 – minpack","text":"public subroutine minpack_lmdif1(fcn, m, n, x, fvec, tol, info, iwa, wa, lwa, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_func2 ) :: fcn integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(inout) :: fvec (m) real(kind=c_double), value :: tol integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(inout) :: iwa (n) real(kind=c_double), intent(inout) :: wa (lwa) integer(kind=c_int), value :: lwa type(c_ptr), value :: udata Calls proc~~minpack_lmdif1~~CallsGraph proc~minpack_lmdif1 minpack_lmdif1 proc~lmdif1 lmdif1 proc~minpack_lmdif1->proc~lmdif1 proc~lmdif lmdif proc~lmdif1->proc~lmdif proc~fdjac2 fdjac2 proc~lmdif->proc~fdjac2 proc~qrfac qrfac proc~lmdif->proc~qrfac proc~enorm enorm proc~lmdif->proc~enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines wrap_fcn Subroutines subroutine wrap_fcn(m, n, x, fvec, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(out) :: fvec (m) integer, intent(inout) :: iflag","tags":"","loc":"proc/minpack_lmdif1.html"},{"title":"minpack_lmder – minpack","text":"public subroutine minpack_lmder(fcn, m, n, x, fvec, fjac, ldfjac, ftol, xtol, gtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, ipvt, qtf, wa1, wa2, wa3, wa4, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_fcn_lmder ) :: fcn integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (m) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), value :: ftol real(kind=c_double), value :: xtol real(kind=c_double), value :: gtol integer(kind=c_int), value :: maxfev real(kind=c_double), intent(inout) :: diag (n) integer(kind=c_int), value :: mode real(kind=c_double), value :: factor integer(kind=c_int), value :: nprint integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: nfev integer(kind=c_int), intent(out) :: njev integer(kind=c_int), intent(out) :: ipvt (n) real(kind=c_double), intent(out) :: qtf (n) real(kind=c_double), intent(inout) :: wa1 (n) real(kind=c_double), intent(inout) :: wa2 (n) real(kind=c_double), intent(inout) :: wa3 (n) real(kind=c_double), intent(inout) :: wa4 (m) type(c_ptr), value :: udata Calls proc~~minpack_lmder~~CallsGraph proc~minpack_lmder minpack_lmder proc~lmder lmder proc~minpack_lmder->proc~lmder proc~qrfac qrfac proc~lmder->proc~qrfac proc~enorm enorm proc~lmder->proc~enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines wrap_fcn Subroutines subroutine wrap_fcn(m, n, x, fvec, fjac, ldfjac, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(inout) :: fvec (m) real(kind=wp), intent(inout) :: fjac (ldfjac,n) integer, intent(in) :: ldfjac integer, intent(inout) :: iflag","tags":"","loc":"proc/minpack_lmder.html"},{"title":"minpack_lmder1 – minpack","text":"public subroutine minpack_lmder1(fcn, m, n, x, fvec, fjac, ldfjac, tol, info, ipvt, wa, lwa, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_fcn_lmder ) :: fcn integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (m) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), value :: tol integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: ipvt (n) real(kind=c_double), intent(inout) :: wa (lwa) integer(kind=c_int), value :: lwa type(c_ptr), value :: udata Calls proc~~minpack_lmder1~~CallsGraph proc~minpack_lmder1 minpack_lmder1 proc~lmder1 lmder1 proc~minpack_lmder1->proc~lmder1 proc~lmder lmder proc~lmder1->proc~lmder proc~qrfac qrfac proc~lmder->proc~qrfac proc~enorm enorm proc~lmder->proc~enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines wrap_fcn Subroutines subroutine wrap_fcn(m, n, x, fvec, fjac, ldfjac, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(inout) :: fvec (m) real(kind=wp), intent(inout) :: fjac (ldfjac,n) integer, intent(in) :: ldfjac integer, intent(inout) :: iflag","tags":"","loc":"proc/minpack_lmder1.html"},{"title":"minpack_lmstr – minpack","text":"private subroutine minpack_lmstr(fcn, m, n, x, fvec, fjac, ldfjac, ftol, xtol, gtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, ipvt, qtf, wa1, wa2, wa3, wa4, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_fcn_lmstr ) :: fcn integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (m) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), value :: ftol real(kind=c_double), value :: xtol real(kind=c_double), value :: gtol integer(kind=c_int), value :: maxfev real(kind=c_double), intent(inout) :: diag (n) integer(kind=c_int), value :: mode real(kind=c_double), value :: factor integer(kind=c_int), value :: nprint integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: nfev integer(kind=c_int), intent(out) :: njev integer(kind=c_int), intent(out) :: ipvt (n) real(kind=c_double), intent(out) :: qtf (n) real(kind=c_double), intent(inout) :: wa1 (n) real(kind=c_double), intent(inout) :: wa2 (n) real(kind=c_double), intent(inout) :: wa3 (n) real(kind=c_double), intent(inout) :: wa4 (m) type(c_ptr), value :: udata Calls proc~~minpack_lmstr~~CallsGraph proc~minpack_lmstr minpack_lmstr proc~lmstr lmstr proc~minpack_lmstr->proc~lmstr proc~rwupdt rwupdt proc~lmstr->proc~rwupdt proc~qrfac qrfac proc~lmstr->proc~qrfac proc~enorm enorm proc~lmstr->proc~enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines wrap_fcn Subroutines subroutine wrap_fcn(m, n, x, fvec, fjrow, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(inout) :: fvec (m) real(kind=wp), intent(inout) :: fjrow (n) integer, intent(inout) :: iflag","tags":"","loc":"proc/minpack_lmstr.html"},{"title":"minpack_lmstr1 – minpack","text":"private subroutine minpack_lmstr1(fcn, m, n, x, fvec, fjac, ldfjac, tol, info, ipvt, wa, lwa, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_fcn_lmstr ) :: fcn integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (m) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), value :: tol integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: ipvt (n) real(kind=c_double), intent(inout) :: wa (lwa) integer(kind=c_int), value :: lwa type(c_ptr), value :: udata Calls proc~~minpack_lmstr1~~CallsGraph proc~minpack_lmstr1 minpack_lmstr1 proc~lmstr1 lmstr1 proc~minpack_lmstr1->proc~lmstr1 proc~lmstr lmstr proc~lmstr1->proc~lmstr proc~rwupdt rwupdt proc~lmstr->proc~rwupdt proc~qrfac qrfac proc~lmstr->proc~qrfac proc~enorm enorm proc~lmstr->proc~enorm proc~qrfac->proc~enorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines wrap_fcn Subroutines subroutine wrap_fcn(m, n, x, fvec, fjrow, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in) :: x (n) real(kind=wp), intent(inout) :: fvec (m) real(kind=wp), intent(inout) :: fjrow (n) integer, intent(inout) :: iflag","tags":"","loc":"proc/minpack_lmstr1.html"},{"title":"minpack_chkder – minpack","text":"public subroutine minpack_chkder(m, n, x, fvec, fjac, ldfjac, xp, fvecp, mode, err) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(in) :: x (n) real(kind=c_double), intent(in) :: fvec (m) real(kind=c_double), intent(in) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), intent(out) :: xp (n) real(kind=c_double), intent(in) :: fvecp (m) integer(kind=c_int), value :: mode real(kind=c_double), intent(out) :: err (m) Calls proc~~minpack_chkder~~CallsGraph proc~minpack_chkder minpack_chkder proc~chkder chkder proc~minpack_chkder->proc~chkder Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/minpack_chkder.html"},{"title":"minpack_module – minpack","text":"Modernized Minpack Authors argonne national laboratory. minpack project. march 1980.\n    burton s. garbow, kenneth e. hillstrom, jorge j. more. Jacob Williams, Sept 2021, updated to modern standards. Uses iso_fortran_env module~~minpack_module~~UsesGraph module~minpack_module minpack_module iso_fortran_env iso_fortran_env module~minpack_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~minpack_module~~UsedByGraph module~minpack_module minpack_module module~minpack_capi minpack_capi module~minpack_capi->module~minpack_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables dpmpar epsmch one zero Abstract Interfaces func func2 fcn_hybrj fcn_lmder fcn_lmstr Functions enorm Subroutines chkder dogleg fdjac1 fdjac2 hybrd hybrd1 hybrj hybrj1 lmder lmder1 lmdif lmdif1 lmpar lmstr lmstr1 qform qrfac qrsolv r1mpyq r1updt rwupdt Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter, dimension(3) :: dpmpar = [epsilon(1.0_wp), tiny(1.0_wp), huge(1.0_wp)] machine constants real(kind=wp), private, parameter :: epsmch = dpmpar(1) the machine precision real(kind=wp), private, parameter :: one = 1.0_wp real(kind=wp), private, parameter :: zero = 0.0_wp Abstract Interfaces abstract interface public subroutine func(n, x, fvec, iflag) user-supplied subroutine for hybrd , hybrd1 , and fdjac1 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the number of variables. real(kind=wp), intent(in) :: x (n) independant variable vector real(kind=wp), intent(out) :: fvec (n) value of function at x integer, intent(inout) :: iflag set to <0 to terminate execution abstract interface public subroutine func2(m, n, x, fvec, iflag) user-supplied subroutine for fdjac2 , lmdif , and lmdif1 Arguments Type Intent Optional Attributes Name integer, intent(in) :: m the number of functions. integer, intent(in) :: n the number of variables. real(kind=wp), intent(in) :: x (n) independant variable vector real(kind=wp), intent(out) :: fvec (m) value of function at x integer, intent(inout) :: iflag the value of iflag should not be changed unless\nthe user wants to terminate execution of lmdif.\nin this case set iflag to a negative integer. abstract interface public subroutine fcn_hybrj(n, x, fvec, fjac, ldfjac, iflag) user-supplied subroutine for hybrj and hybrj1 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the number of variables. real(kind=wp), intent(in), dimension(n) :: x independant variable vector real(kind=wp), intent(out), dimension(n) :: fvec value of function at x real(kind=wp), intent(out), dimension(ldfjac, n) :: fjac jacobian matrix at x integer, intent(in) :: ldfjac leading dimension of the array fjac. integer, intent(inout) :: iflag if iflag = 1 calculate the functions at x and\nreturn this vector in fvec. do not alter fjac.\nif iflag = 2 calculate the jacobian at x and\nreturn this matrix in fjac. do not alter fvec. the value of iflag should not be changed by fcn unless\nthe user wants to terminate execution of hybrj.\nin this case set iflag to a negative integer. abstract interface public subroutine fcn_lmder(m, n, x, fvec, fjac, ldfjac, iflag) user-supplied subroutine for lmder and lmder1 Arguments Type Intent Optional Attributes Name integer, intent(in) :: m the number of functions. integer, intent(in) :: n the number of variables. real(kind=wp), intent(in) :: x (n) independant variable vector real(kind=wp), intent(inout) :: fvec (m) value of function at x real(kind=wp), intent(inout) :: fjac (ldfjac,n) jacobian matrix at x integer, intent(in) :: ldfjac leading dimension of the array fjac. integer, intent(inout) :: iflag if iflag = 1 calculate the functions at x and\nreturn this vector in fvec. do not alter fjac.\nif iflag = 2 calculate the jacobian at x and\nreturn this matrix in fjac. do not alter fvec. the value of iflag should not be changed by fcn unless\nthe user wants to terminate execution of lmder.\nin this case set iflag to a negative integer. abstract interface public subroutine fcn_lmstr(m, n, x, fvec, fjrow, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m the number of functions. integer, intent(in) :: n the number of variables. real(kind=wp), intent(in) :: x (n) independent variable vector real(kind=wp), intent(inout) :: fvec (m) value of function at x real(kind=wp), intent(inout) :: fjrow (n) jacobian row integer, intent(inout) :: iflag if iflag = 1 calculate the functions at x and\nreturn this vector in fvec.\nif iflag = i calculate the (i-1)-st row of the\njacobian at x and return this vector in fjrow. the value of iflag should not be changed by fcn unless\nthe user wants to terminate execution of lmstr.\nin this case set iflag to a negative integer. Functions public pure function enorm (n, x) given an n-vector x, this function calculates the\neuclidean norm of x. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable. real(kind=wp), intent(in) :: x (n) an input array of length n. Return Value real(kind=wp) Subroutines public subroutine chkder (m, n, x, Fvec, Fjac, Ldfjac, Xp, Fvecp, Mode, Err) this subroutine checks the gradients of m nonlinear functions\nin n variables, evaluated at a point x, for consistency with\nthe functions themselves. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. real(kind=wp), intent(in) :: x (n) input array real(kind=wp), intent(in) :: Fvec (m) an array of length m. on input when mode = 2,\nfvec must contain the functions evaluated at x. real(kind=wp), intent(in) :: Fjac (Ldfjac,n) an m by n array. on input when mode = 2,\nthe rows of fjac must contain the gradients of\nthe respective functions evaluated at x. integer, intent(in) :: Ldfjac a positive integer input parameter not less than m\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(out) :: Xp (n) an array of length n. on output when mode = 1,\nxp is set to a neighboring point of x. real(kind=wp), intent(in) :: Fvecp (m) an array of length m. on input when mode = 2,\nfvecp must contain the functions evaluated at xp. integer, intent(in) :: Mode an integer input variable set to 1 on the first call\nand 2 on the second. other values of mode are equivalent\nto mode = 1. the user must call chkder twice,\nfirst with mode = 1 and then with mode = 2. mode = 1. on input , x must contain the point of evaluation. on output , xp is set to a neighboring point. mode = 2. on input , fvec must contain the functions and the\n   rows of fjac must contain the gradients\n   of the respective functions each evaluated\n   at x, and fvecp must contain the functions\n   evaluated at xp. on output , err contains measures of correctness of\n   the respective gradients. real(kind=wp), intent(out) :: Err (m) an array of length m. on output when mode = 2,\nerr contains measures of correctness of the respective\ngradients. if there is no severe loss of significance,\nthen if err(i) is 1.0 the i-th gradient is correct,\nwhile if err(i) is 0.0 the i-th gradient is incorrect.\nfor values of err between 0.0 and 1.0, the categorization\nis less certain. in general, a value of err(i) greater\nthan 0.5 indicates that the i-th gradient is probably\ncorrect, while a value of err(i) less than 0.5 indicates\nthat the i-th gradient is probably incorrect. public subroutine dogleg (n, r, Lr, Diag, Qtb, Delta, x, Wa1, Wa2) given an m by n matrix a, an n by n nonsingular diagonal\nmatrix d, an m-vector b, and a positive number delta, the\nproblem is to determine the convex combination x of the\ngauss-newton and scaled gradient directions that minimizes\n(a x - b) in the least squares sense, subject to the\nrestriction that the euclidean norm of d x be at most delta. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the order of r. real(kind=wp), intent(in) :: r (Lr) an input array of length lr which must contain the upper\ntriangular matrix r stored by rows. integer, intent(in) :: Lr a positive integer input variable not less than (n*(n+1))/2. real(kind=wp), intent(in) :: Diag (n) an input array of length n which must contain the\ndiagonal elements of the matrix d. real(kind=wp), intent(in) :: Qtb (n) an input array of length n which must contain the first\nn elements of the vector (q transpose)*b. real(kind=wp), intent(in) :: Delta a positive input variable which specifies an upper\nbound on the euclidean norm of d*x. real(kind=wp), intent(out) :: x (n) an output array of length n which contains the desired\nconvex combination of the gauss-newton direction and the\nscaled gradient direction. real(kind=wp), intent(inout) :: Wa1 (n) work arrays of length n real(kind=wp), intent(inout) :: Wa2 (n) work arrays of length n public subroutine fdjac1 (fcn, n, x, Fvec, Fjac, Ldfjac, Iflag, Ml, Mu, Epsfcn, Wa1, Wa2) this subroutine computes a forward-difference approximation\nto the n by n jacobian matrix associated with a specified\nproblem of n functions in n variables. if the jacobian has\na banded form, then function evaluations are saved by only\napproximating the nonzero terms. Arguments Type Intent Optional Attributes Name procedure( func ) :: fcn the user-supplied subroutine which\ncalculates the functions. integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout) :: x (n) an input array of length n. real(kind=wp), intent(in) :: Fvec (n) an input array of length n which must contain the\nfunctions evaluated at x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output n by n array which contains the\napproximation to the jacobian matrix evaluated at x. integer, intent(in) :: Ldfjac a positive integer input variable not less than n\nwhich specifies the leading dimension of the array fjac. integer, intent(out) :: Iflag an integer variable which can be used to terminate\nthe execution of fdjac1. see description of func . integer, intent(in) :: Ml a nonnegative integer input variable which specifies\nthe number of subdiagonals within the band of the\njacobian matrix. if the jacobian is not banded, set\nml to at least n - 1. integer, intent(in) :: Mu a nonnegative integer input variable which specifies\nthe number of superdiagonals within the band of the\njacobian matrix. if the jacobian is not banded, set\nmu to at least n - 1. real(kind=wp), intent(in) :: Epsfcn an input variable used in determining a suitable\nstep length for the forward-difference approximation. this\napproximation assumes that the relative errors in the\nfunctions are of the order of epsfcn. if epsfcn is less\nthan the machine precision, it is assumed that the relative\nerrors in the functions are of the order of the machine\nprecision. real(kind=wp), intent(inout) :: Wa1 (n) work array of length n. real(kind=wp), intent(inout) :: Wa2 (n) work array of length n. if ml + mu + 1 is at\nleast n, then the jacobian is considered dense, and wa2 is\nnot referenced. public subroutine fdjac2 (fcn, m, n, x, Fvec, Fjac, Ldfjac, Iflag, Epsfcn, Wa) this subroutine computes a forward-difference approximation\nto the m by n jacobian matrix associated with a specified\nproblem of m functions in n variables. Arguments Type Intent Optional Attributes Name procedure( func2 ) :: fcn the user-supplied subroutine which\ncalculates the functions. integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an input array of length n. real(kind=wp), intent(in) :: Fvec (m) an input array of length m which must contain the\nfunctions evaluated at x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output m by n array which contains the\napproximation to the jacobian matrix evaluated at x. integer, intent(in) :: Ldfjac a positive integer input variable not less than m\nwhich specifies the leading dimension of the array fjac. integer, intent(out) :: Iflag an integer variable which can be used to terminate\nthe execution of fdjac2. see description of func2 . real(kind=wp), intent(in) :: Epsfcn an input variable used in determining a suitable\nstep length for the forward-difference approximation. this\napproximation assumes that the relative errors in the\nfunctions are of the order of epsfcn. if epsfcn is less\nthan the machine precision, it is assumed that the relative\nerrors in the functions are of the order of the machine\nprecision. real(kind=wp), intent(inout) :: Wa (m) a work array of length m. public subroutine hybrd (fcn, n, x, fvec, xtol, maxfev, ml, mu, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, r, lr, qtf, wa1, wa2, wa3, wa4) the purpose of hybrd is to find a zero of a system of\nn nonlinear functions in n variables by a modification\nof the powell hybrid method. the user must provide a\nsubroutine which calculates the functions. the jacobian is\nthen calculated by a forward-difference approximation. Arguments Type Intent Optional Attributes Name procedure( func ) :: fcn user-supplied subroutine which calculates the functions integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout) :: x (n) array of length n. on input x must contain\nan initial estimate of the solution vector. on output x contains the final estimate of the solution vector. real(kind=wp), intent(out) :: fvec (n) an output array of length n which contains\nthe functions evaluated at the output x . real(kind=wp), intent(in) :: xtol a nonnegative input variable. termination\noccurs when the relative error between two consecutive\niterates is at most xtol . integer, intent(in) :: maxfev a positive integer input variable. termination\noccurs when the number of calls to fcn is at least maxfev by the end of an iteration. integer, intent(in) :: ml a nonnegative integer input variable which specifies\nthe number of subdiagonals within the band of the\njacobian matrix. if the jacobian is not banded, set ml to at least n - 1 . integer, intent(in) :: mu a nonnegative integer input variable which specifies\nthe number of superdiagonals within the band of the\njacobian matrix. if the jacobian is not banded, set mu to at least n - 1 . real(kind=wp), intent(in) :: epsfcn an input variable used in determining a suitable\nstep length for the forward-difference approximation. this\napproximation assumes that the relative errors in the\nfunctions are of the order of epsfcn . if epsfcn is less\nthan the machine precision, it is assumed that the relative\nerrors in the functions are of the order of the machine\nprecision. real(kind=wp), intent(inout) :: diag (n) an array of length n . if mode = 1 (see\nbelow), diag is internally set. if mode = 2 , diag must contain positive entries that serve as\nmultiplicative scale factors for the variables. integer, intent(in) :: mode if mode = 1 , the\nvariables will be scaled internally. if mode = 2 ,\nthe scaling is specified by the input diag . other\nvalues of mode are equivalent to mode = 1 . real(kind=wp), intent(in) :: factor a positive input variable used in determining the\ninitial step bound. this bound is set to the product of factor and the euclidean norm of diag*x if nonzero, or else\nto factor itself. in most cases factor should lie in the\ninterval (.1,100.). 100. is a generally recommended value. integer, intent(in) :: nprint an integer input variable that enables controlled\nprinting of iterates if it is positive. in this case, fcn is called with iflag = 0 at the beginning of the first\niteration and every nprint iterations thereafter and\nimmediately prior to return, with x and fvec available\nfor printing. if nprint is not positive, no special calls\nof fcn with iflag = 0 are made. integer, intent(out) :: info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag . see description of fcn . otherwise, info is set as follows: info = 0 improper input parameters. info = 1 relative error between two consecutive iterates\n   is at most xtol . info = 2 number of calls to fcn has reached or exceeded maxfev . info = 3 xtol is too small. no further improvement in\n   the approximate solution x is possible. info = 4 iteration is not making good progress, as\n   measured by the improvement from the last\n   five jacobian evaluations. info = 5 iteration is not making good progress, as\n   measured by the improvement from the last\n   ten iterations. integer, intent(out) :: nfev output variable set to the number of calls to fcn . real(kind=wp), intent(out) :: fjac (ldfjac,n) array which contains the\northogonal matrix q produced by the QR factorization\nof the final approximate jacobian. integer, intent(in) :: ldfjac a positive integer input variable not less than n which specifies the leading dimension of the array fjac . real(kind=wp), intent(out) :: r (lr) an output array which contains the\nupper triangular matrix produced by the QR factorization\nof the final approximate jacobian, stored rowwise. integer, intent(in) :: lr a positive integer input variable not less than (n*(n+1))/2 . real(kind=wp), intent(out) :: qtf (n) an output array of length n which contains\nthe vector (q transpose)*fvec . real(kind=wp), intent(inout) :: wa1 (n) work array real(kind=wp), intent(inout) :: wa2 (n) work array real(kind=wp), intent(inout) :: wa3 (n) work array real(kind=wp), intent(inout) :: wa4 (n) work array public subroutine hybrd1 (fcn, n, x, fvec, tol, info, Wa, Lwa) the purpose of hybrd1 is to find a zero of a system of\nn nonlinear functions in n variables by a modification\nof the powell hybrid method. this is done by using the\nmore general nonlinear equation solver hybrd. the user\nmust provide a subroutine which calculates the functions.\nthe jacobian is then calculated by a forward-difference\napproximation. Arguments Type Intent Optional Attributes Name procedure( func ) :: fcn user-supplied subroutine which calculates the functions integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout), dimension(n) :: x an array of length n . on input x must contain\nan initial estimate of the solution vector. on output x contains the final estimate of the solution vector. real(kind=wp), intent(out), dimension(n) :: fvec an output array of length n which contains\nthe functions evaluated at the output x . real(kind=wp), intent(in) :: tol a nonnegative input variable. termination occurs\nwhen the algorithm estimates that the relative error\nbetween x and the solution is at most tol . integer, intent(out) :: info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag . see description of fcn . otherwise, info is set as follows: info = 0 improper input parameters. info = 1 algorithm estimates that the relative error\n between x and the solution is at most tol . info = 2 number of calls to fcn has reached or exceeded 200*(n+1) . info = 3 tol is too small. no further improvement in\n the approximate solution x is possible. info = 4 iteration is not making good progress. real(kind=wp), intent(inout) :: Wa (Lwa) a work array of length lwa. integer, intent(in) :: Lwa a positive integer input variable not less than\n(n (3 n+13))/2. public subroutine hybrj (fcn, n, x, Fvec, Fjac, Ldfjac, Xtol, Maxfev, Diag, Mode, Factor, Nprint, Info, Nfev, Njev, r, Lr, Qtf, Wa1, Wa2, Wa3, Wa4) the purpose of hybrj is to find a zero of a system of\nn nonlinear functions in n variables by a modification\nof the powell hybrid method. the user must provide a\nsubroutine which calculates the functions and the jacobian. Arguments Type Intent Optional Attributes Name procedure( fcn_hybrj ) :: fcn the user-supplied subroutine which\ncalculates the functions and the jacobian integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (n) an output array of length n which contains\nthe functions evaluated at the output x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output n by n array which contains the\northogonal matrix q produced by the qr factorization\nof the final approximate jacobian. integer, intent(in) :: Ldfjac a positive integer input variable not less than n\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(in) :: Xtol a nonnegative input variable. termination\noccurs when the relative error between two consecutive\niterates is at most xtol. integer, intent(in) :: Maxfev a positive integer input variable. termination\noccurs when the number of calls to fcn with iflag = 1\nhas reached maxfev. real(kind=wp), intent(inout) :: Diag (n) an array of length n. if mode = 1 (see\nbelow), diag is internally set. if mode = 2, diag\nmust contain positive entries that serve as\nmultiplicative scale factors for the variables. integer, intent(in) :: Mode an integer input variable. if mode = 1, the\nvariables will be scaled internally. if mode = 2,\nthe scaling is specified by the input diag. other\nvalues of mode are equivalent to mode = 1. real(kind=wp), intent(in) :: Factor a positive input variable used in determining the\ninitial step bound. this bound is set to the product of\nfactor and the euclidean norm of diag*x if nonzero, or else\nto factor itself. in most cases factor should lie in the\ninterval (.1,100.). 100. is a generally recommended value. integer, intent(in) :: Nprint an integer input variable that enables controlled\nprinting of iterates if it is positive. in this case,\nfcn is called with iflag = 0 at the beginning of the first\niteration and every nprint iterations thereafter and\nimmediately prior to return, with x and fvec available\nfor printing. fvec and fjac should not be altered.\nif nprint is not positive, no special calls of fcn\nwith iflag = 0 are made. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 relative error between two consecutive iterates\n   is at most xtol. info = 2 number of calls to fcn with iflag = 1 has\n   reached maxfev. info = 3 xtol is too small. no further improvement in\n   the approximate solution x is possible. info = 4 iteration is not making good progress, as\n   measured by the improvement from the last\n   five jacobian evaluations. info = 5 iteration is not making good progress, as\n   measured by the improvement from the last\n   ten iterations. integer, intent(out) :: Nfev an integer output variable set to the number of\ncalls to fcn with iflag = 1. integer, intent(out) :: Njev an integer output variable set to the number of\ncalls to fcn with iflag = 2. real(kind=wp), intent(out) :: r (Lr) an output array of length lr which contains the\nupper triangular matrix produced by the qr factorization\nof the final approximate jacobian, stored rowwise. integer, intent(in) :: Lr a positive integer input variable not less than\n(n*(n+1))/2. real(kind=wp), intent(out) :: Qtf (n) an output array of length n which contains\nthe vector (q transpose)*fvec. real(kind=wp), intent(inout) :: Wa1 (n) work array of length n. real(kind=wp), intent(inout) :: Wa2 (n) work array of length n. real(kind=wp), intent(inout) :: Wa3 (n) work array of length n. real(kind=wp), intent(inout) :: Wa4 (n) work array of length n. public subroutine hybrj1 (fcn, n, x, Fvec, Fjac, Ldfjac, Tol, Info, Wa, Lwa) the purpose of hybrj1 is to find a zero of a system of\nn nonlinear functions in n variables by a modification\nof the powell hybrid method. this is done by using the\nmore general nonlinear equation solver hybrj. the user\nmust provide a subroutine which calculates the functions\nand the jacobian. Arguments Type Intent Optional Attributes Name procedure( fcn_hybrj ) :: fcn the user-supplied subroutine which\ncalculates the functions and the jacobian integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (n) an output array of length n which contains\nthe functions evaluated at the output x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output n by n array which contains the\northogonal matrix q produced by the qr factorization\nof the final approximate jacobian. integer, intent(in) :: Ldfjac a positive integer input variable not less than n\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(in) :: Tol a nonnegative input variable. termination occurs\nwhen the algorithm estimates that the relative error\nbetween x and the solution is at most tol. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 algorithm estimates that the relative error\n   between x and the solution is at most tol. info = 2 number of calls to fcn with iflag = 1 has\n   reached 100*(n+1). info = 3 tol is too small. no further improvement in\n   the approximate solution x is possible. info = 4 iteration is not making good progress. real(kind=wp), intent(inout) :: Wa (Lwa) a work array of length lwa. integer, intent(in) :: Lwa a positive integer input variable not less than\n(n*(n+13))/2. public subroutine lmder (fcn, m, n, x, Fvec, Fjac, Ldfjac, Ftol, Xtol, Gtol, Maxfev, Diag, Mode, Factor, Nprint, Info, Nfev, Njev, Ipvt, Qtf, Wa1, Wa2, Wa3, Wa4) the purpose of lmder is to minimize the sum of the squares of\nm nonlinear functions in n variables by a modification of\nthe levenberg-marquardt algorithm. the user must provide a\nsubroutine which calculates the functions and the jacobian. Arguments Type Intent Optional Attributes Name procedure( fcn_lmder ) :: fcn the user-supplied subroutine which\ncalculates the functions and the jacobian integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (m) an output array of length m which contains\nthe functions evaluated at the output x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output m by n array. the upper n by n submatrix\n of fjac contains an upper triangular matrix r with\n diagonal elements of nonincreasing magnitude such that t     t           t\n       p *(jac *jac)*p = r *r, where p is a permutation matrix and jac is the final\n calculated jacobian. column j of p is column ipvt(j)\n (see below) of the identity matrix. the lower trapezoidal\n part of fjac contains information generated during\n the computation of r. integer, intent(in) :: Ldfjac a positive integer input variable not less than m\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(in) :: Ftol a nonnegative input variable. termination\noccurs when both the actual and predicted relative\nreductions in the sum of squares are at most ftol.\ntherefore, ftol measures the relative error desired\nin the sum of squares. real(kind=wp), intent(in) :: Xtol a nonnegative input variable. termination\noccurs when the relative error between two consecutive\niterates is at most xtol. therefore, xtol measures the\nrelative error desired in the approximate solution. real(kind=wp), intent(in) :: Gtol a nonnegative input variable. termination\noccurs when the cosine of the angle between fvec and\nany column of the jacobian is at most gtol in absolute\nvalue. therefore, gtol measures the orthogonality\ndesired between the function vector and the columns\nof the jacobian. integer, intent(in) :: Maxfev a positive integer input variable. termination\noccurs when the number of calls to fcn with iflag = 1\nhas reached maxfev. real(kind=wp), intent(inout) :: Diag (n) an array of length n. if mode = 1 (see\nbelow), diag is internally set. if mode = 2, diag\nmust contain positive entries that serve as\nmultiplicative scale factors for the variables. integer, intent(in) :: Mode an integer input variable. if mode = 1, the\nvariables will be scaled internally. if mode = 2,\nthe scaling is specified by the input diag. other\nvalues of mode are equivalent to mode = 1. real(kind=wp), intent(in) :: Factor a positive input variable used in determining the\ninitial step bound. this bound is set to the product of\nfactor and the euclidean norm of diag*x if nonzero, or else\nto factor itself. in most cases factor should lie in the\ninterval (.1,100.).100. is a generally recommended value. integer, intent(in) :: Nprint an integer input variable that enables controlled\nprinting of iterates if it is positive. in this case,\nfcn is called with iflag = 0 at the beginning of the first\niteration and every nprint iterations thereafter and\nimmediately prior to return, with x, fvec, and fjac\navailable for printing. fvec and fjac should not be\naltered. if nprint is not positive, no special calls\nof fcn with iflag = 0 are made. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 both actual and predicted relative reductions\n   in the sum of squares are at most ftol. info = 2 relative error between two consecutive iterates\n   is at most xtol. info = 3 conditions for info = 1 and info = 2 both hold. info = 4 the cosine of the angle between fvec and any\n   column of the jacobian is at most gtol in\n   absolute value. info = 5 number of calls to fcn with iflag = 1 has\n   reached maxfev. info = 6 ftol is too small. no further reduction in\n   the sum of squares is possible. info = 7 xtol is too small. no further improvement in\n   the approximate solution x is possible. info = 8 gtol is too small. fvec is orthogonal to the\n   columns of the jacobian to machine precision. integer, intent(out) :: Nfev an integer output variable set to the number of\ncalls to fcn with iflag = 1. integer, intent(out) :: Njev an integer output variable set to the number of\ncalls to fcn with iflag = 2. integer, intent(out) :: Ipvt (n) an integer output array of length n. ipvt\ndefines a permutation matrix p such that jac p = q r,\nwhere jac is the final calculated jacobian, q is\northogonal (not stored), and r is upper triangular\nwith diagonal elements of nonincreasing magnitude.\ncolumn j of p is column ipvt(j) of the identity matrix. real(kind=wp), intent(out) :: Qtf (n) an output array of length n which contains\nthe first n elements of the vector (q transpose)*fvec. real(kind=wp), intent(inout) :: Wa1 (n) work array of length n. real(kind=wp), intent(inout) :: Wa2 (n) work array of length n. real(kind=wp), intent(inout) :: Wa3 (n) work array of length n. real(kind=wp), intent(inout) :: Wa4 (m) work array of length n. public subroutine lmder1 (fcn, m, n, x, Fvec, Fjac, Ldfjac, Tol, Info, Ipvt, Wa, Lwa) the purpose of lmder1 is to minimize the sum of the squares of\nm nonlinear functions in n variables by a modification of the\nlevenberg-marquardt algorithm. this is done by using the more\ngeneral least-squares solver lmder. the user must provide a\nsubroutine which calculates the functions and the jacobian. Arguments Type Intent Optional Attributes Name procedure( fcn_lmder ) :: fcn user-supplied subroutine which\ncalculates the functions and the jacobian. integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (m) an output array of length m which contains\nthe functions evaluated at the output x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output m by n array. the upper n by n submatrix\n of fjac contains an upper triangular matrix r with\n diagonal elements of nonincreasing magnitude such that t     t           t\n       p *(jac *jac)*p = r *r, where p is a permutation matrix and jac is the final\n calculated jacobian. column j of p is column ipvt(j)\n (see below) of the identity matrix. the lower trapezoidal\n part of fjac contains information generated during\n the computation of r. integer, intent(in) :: Ldfjac a positive integer input variable not less than m\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(in) :: Tol a nonnegative input variable. termination occurs\nwhen the algorithm estimates either that the relative\nerror in the sum of squares is at most tol or that\nthe relative error between x and the solution is at\nmost tol. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows. info = 0 improper input parameters. info = 1 algorithm estimates that the relative error\n   in the sum of squares is at most tol. info = 2 algorithm estimates that the relative error\n   between x and the solution is at most tol. info = 3 conditions for info = 1 and info = 2 both hold. info = 4 fvec is orthogonal to the columns of the\n   jacobian to machine precision. info = 5 number of calls to fcn with iflag = 1 has\n   reached 100*(n+1). info = 6 tol is too small. no further reduction in\n   the sum of squares is possible. info = 7 tol is too small. no further improvement in\n   the approximate solution x is possible. integer, intent(out) :: Ipvt (n) an integer output array of length n. ipvt\ndefines a permutation matrix p such that jac p = q r,\nwhere jac is the final calculated jacobian, q is\northogonal (not stored), and r is upper triangular\nwith diagonal elements of nonincreasing magnitude.\ncolumn j of p is column ipvt(j) of the identity matrix. real(kind=wp), intent(inout) :: Wa (Lwa) a work array of length lwa. integer, intent(in) :: Lwa a positive integer input variable not less than 5*n+m. public subroutine lmdif (fcn, m, n, x, Fvec, Ftol, Xtol, Gtol, Maxfev, Epsfcn, Diag, Mode, Factor, Nprint, Info, Nfev, Fjac, Ldfjac, Ipvt, Qtf, Wa1, Wa2, Wa3, Wa4) the purpose of lmdif is to minimize the sum of the squares of\nm nonlinear functions in n variables by a modification of\nthe levenberg-marquardt algorithm. the user must provide a\nsubroutine which calculates the functions. the jacobian is\nthen calculated by a forward-difference approximation. Arguments Type Intent Optional Attributes Name procedure( func2 ) :: fcn the user-supplied subroutine which\ncalculates the functions. integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (m) an output array of length m which contains\nthe functions evaluated at the output x. real(kind=wp), intent(in) :: Ftol a nonnegative input variable. termination\noccurs when both the actual and predicted relative\nreductions in the sum of squares are at most ftol.\ntherefore, ftol measures the relative error desired\nin the sum of squares. real(kind=wp), intent(in) :: Xtol a nonnegative input variable. termination\noccurs when the relative error between two consecutive\niterates is at most xtol. therefore, xtol measures the\nrelative error desired in the approximate solution. real(kind=wp), intent(in) :: Gtol a nonnegative input variable. termination\noccurs when the cosine of the angle between fvec and\nany column of the jacobian is at most gtol in absolute\nvalue. therefore, gtol measures the orthogonality\ndesired between the function vector and the columns\nof the jacobian. integer, intent(in) :: Maxfev a positive integer input variable. termination\noccurs when the number of calls to fcn is at least\nmaxfev by the end of an iteration. real(kind=wp), intent(in) :: Epsfcn an input variable used in determining a suitable\nstep length for the forward-difference approximation. this\napproximation assumes that the relative errors in the\nfunctions are of the order of epsfcn. if epsfcn is less\nthan the machine precision, it is assumed that the relative\nerrors in the functions are of the order of the machine\nprecision. real(kind=wp), intent(inout) :: Diag (n) an array of length n. if mode = 1 (see\nbelow), diag is internally set. if mode = 2, diag\nmust contain positive entries that serve as\nmultiplicative scale factors for the variables. integer, intent(in) :: Mode an integer input variable. if mode = 1, the\nvariables will be scaled internally. if mode = 2,\nthe scaling is specified by the input diag. other\nvalues of mode are equivalent to mode = 1. real(kind=wp), intent(in) :: Factor a positive input variable used in determining the\ninitial step bound. this bound is set to the product of\nfactor and the euclidean norm of diag*x if nonzero, or else\nto factor itself. in most cases factor should lie in the\ninterval (.1,100.). 100. is a generally recommended value. integer, intent(in) :: Nprint an integer input variable that enables controlled\nprinting of iterates if it is positive. in this case,\nfcn is called with iflag = 0 at the beginning of the first\niteration and every nprint iterations thereafter and\nimmediately prior to return, with x and fvec available\nfor printing. if nprint is not positive, no special calls\nof fcn with iflag = 0 are made. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 both actual and predicted relative reductions\n   in the sum of squares are at most ftol. info = 2 relative error between two consecutive iterates\n   is at most xtol. info = 3 conditions for info = 1 and info = 2 both hold. info = 4 the cosine of the angle between fvec and any\n   column of the jacobian is at most gtol in\n   absolute value. info = 5 number of calls to fcn has reached or\n   exceeded maxfev. info = 6 ftol is too small. no further reduction in\n   the sum of squares is possible. info = 7 xtol is too small. no further improvement in\n   the approximate solution x is possible. info = 8 gtol is too small. fvec is orthogonal to the\n   columns of the jacobian to machine precision. integer, intent(out) :: Nfev an integer output variable set to the number of\ncalls to fcn. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output m by n array. the upper n by n submatrix\n of fjac contains an upper triangular matrix r with\n diagonal elements of nonincreasing magnitude such that t     t           t\n       p *(jac *jac)*p = r *r, where p is a permutation matrix and jac is the final\n calculated jacobian. column j of p is column ipvt(j)\n (see below) of the identity matrix. the lower trapezoidal\n part of fjac contains information generated during\n the computation of r. integer, intent(in) :: Ldfjac a positive integer input variable not less than m\nwhich specifies the leading dimension of the array fjac. integer, intent(out) :: Ipvt (n) an integer output array of length n. ipvt\ndefines a permutation matrix p such that jac p = q r,\nwhere jac is the final calculated jacobian, q is\northogonal (not stored), and r is upper triangular\nwith diagonal elements of nonincreasing magnitude.\ncolumn j of p is column ipvt(j) of the identity matrix. real(kind=wp), intent(out) :: Qtf (n) an output array of length n which contains\nthe first n elements of the vector (q transpose)*fvec. real(kind=wp), intent(inout) :: Wa1 (n) work array of length n. real(kind=wp), intent(inout) :: Wa2 (n) work array of length n. real(kind=wp), intent(inout) :: Wa3 (n) work array of length n. real(kind=wp), intent(inout) :: Wa4 (m) work array of length n. public subroutine lmdif1 (fcn, m, n, x, Fvec, Tol, Info, Iwa, Wa, Lwa) the purpose of lmdif1 is to minimize the sum of the squares of\nm nonlinear functions in n variables by a modification of the\nlevenberg-marquardt algorithm. this is done by using the more\ngeneral least-squares solver lmdif. the user must provide a\nsubroutine which calculates the functions. the jacobian is\nthen calculated by a forward-difference approximation. Arguments Type Intent Optional Attributes Name procedure( func2 ) :: fcn the user-supplied subroutine which\ncalculates the functions. integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (m) an output array of length m which contains\nthe functions evaluated at the output x. real(kind=wp), intent(in) :: Tol a nonnegative input variable. termination occurs\nwhen the algorithm estimates either that the relative\nerror in the sum of squares is at most tol or that\nthe relative error between x and the solution is at\nmost tol. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 algorithm estimates that the relative error\n   in the sum of squares is at most tol. info = 2 algorithm estimates that the relative error\n   between x and the solution is at most tol. info = 3 conditions for info = 1 and info = 2 both hold. info = 4 fvec is orthogonal to the columns of the\n   jacobian to machine precision. info = 5 number of calls to fcn has reached or\n   exceeded 200*(n+1). info = 6 tol is too small. no further reduction in\n   the sum of squares is possible. info = 7 tol is too small. no further improvement in\n   the approximate solution x is possible. integer, intent(inout) :: Iwa (n) an integer work array of length n. real(kind=wp), intent(inout) :: Wa (Lwa) a work array of length lwa. integer, intent(in) :: Lwa a positive integer input variable not less than\nm n+5 n+m. public subroutine lmpar (n, r, Ldr, Ipvt, Diag, Qtb, Delta, Par, x, Sdiag, Wa1, Wa2) given an m by n matrix a, an n by n nonsingular diagonal\n  matrix d, an m-vector b, and a positive number delta,\n  the problem is to determine a value for the parameter\n  par such that if x solves the system Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the order of r. real(kind=wp), intent(inout) :: r (Ldr,n) an n by n array. on input the full upper triangle\nmust contain the full upper triangle of the matrix r.\non output the full upper triangle is unaltered, and the\nstrict lower triangle contains the strict upper triangle\n(transposed) of the upper triangular matrix s. integer, intent(in) :: Ldr a positive integer input variable not less than n\nwhich specifies the leading dimension of the array r. integer, intent(in) :: Ipvt (n) an integer input array of length n which defines the\npermutation matrix p such that a p = q r. column j of p\nis column ipvt(j) of the identity matrix. real(kind=wp), intent(in) :: Diag (n) an input array of length n which must contain the\ndiagonal elements of the matrix d. real(kind=wp), intent(in) :: Qtb (n) an input array of length n which must contain the first\nn elements of the vector (q transpose)*b. real(kind=wp) :: Delta a positive input variable which specifies an upper\nbound on the euclidean norm of d*x. real(kind=wp), intent(inout) :: Par a nonnegative variable. on input par contains an\ninitial estimate of the levenberg-marquardt parameter.\non output par contains the final estimate. real(kind=wp), intent(out) :: x (n) an output array of length n which contains the least\nsquares solution of the system a x = b, sqrt(par) d*x = 0,\nfor the output par. real(kind=wp), intent(out) :: Sdiag (n) an output array of length n which contains the\ndiagonal elements of the upper triangular matrix s. real(kind=wp), intent(inout) :: Wa1 (n) work array of length n. real(kind=wp), intent(inout) :: Wa2 (n) work array of length n. public subroutine lmstr (fcn, m, n, x, Fvec, Fjac, Ldfjac, Ftol, Xtol, Gtol, Maxfev, Diag, Mode, Factor, Nprint, Info, Nfev, Njev, Ipvt, Qtf, Wa1, Wa2, Wa3, Wa4) the purpose of lmstr is to minimize the sum of the squares of\nm nonlinear functions in n variables by a modification of\nthe levenberg-marquardt algorithm which uses minimal storage.\nthe user must provide a subroutine which calculates the\nfunctions and the rows of the jacobian. Arguments Type Intent Optional Attributes Name procedure( fcn_lmstr ) :: fcn user-supplied subroutine which\ncalculates the functions and the rows of the jacobian. integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (m) an output array of length m which contains\nthe functions evaluated at the output x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output n by n array. the upper triangle of fjac\n contains an upper triangular matrix r such that t     t           t\n       p *(jac *jac)*p = r *r, where p is a permutation matrix and jac is the final\n calculated jacobian. column j of p is column ipvt(j)\n (see below) of the identity matrix. the lower triangular\n part of fjac contains information generated during\n the computation of r. integer, intent(in) :: Ldfjac a positive integer input variable not less than n\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(in) :: Ftol a nonnegative input variable. termination\noccurs when both the actual and predicted relative\nreductions in the sum of squares are at most ftol.\ntherefore, ftol measures the relative error desired\nin the sum of squares. real(kind=wp), intent(in) :: Xtol a nonnegative input variable. termination\noccurs when the relative error between two consecutive\niterates is at most xtol. therefore, xtol measures the\nrelative error desired in the approximate solution. real(kind=wp), intent(in) :: Gtol a nonnegative input variable. termination\noccurs when the cosine of the angle between fvec and\nany column of the jacobian is at most gtol in absolute\nvalue. therefore, gtol measures the orthogonality\ndesired between the function vector and the columns\nof the jacobian. integer, intent(in) :: Maxfev a positive integer input variable. termination\noccurs when the number of calls to fcn with iflag = 1\nhas reached maxfev. real(kind=wp), intent(inout) :: Diag (n) an array of length n. if mode = 1 (see\nbelow), diag is internally set. if mode = 2, diag\nmust contain positive entries that serve as\nmultiplicative scale factors for the variables. integer, intent(in) :: Mode an integer input variable. if mode = 1, the\nvariables will be scaled internally. if mode = 2,\nthe scaling is specified by the input diag. other\nvalues of mode are equivalent to mode = 1. real(kind=wp), intent(in) :: Factor a positive input variable used in determining the\ninitial step bound. this bound is set to the product of\nfactor and the euclidean norm of diag*x if nonzero, or else\nto factor itself. in most cases factor should lie in the\ninterval (.1,100.). 100. is a generally recommended value. integer, intent(in) :: Nprint an integer input variable that enables controlled\nprinting of iterates if it is positive. in this case,\nfcn is called with iflag = 0 at the beginning of the first\niteration and every nprint iterations thereafter and\nimmediately prior to return, with x and fvec available\nfor printing. if nprint is not positive, no special calls\nof fcn with iflag = 0 are made. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 both actual and predicted relative reductions\n   in the sum of squares are at most ftol. info = 2 relative error between two consecutive iterates\n   is at most xtol. info = 3 conditions for info = 1 and info = 2 both hold. info = 4 the cosine of the angle between fvec and any\n   column of the jacobian is at most gtol in\n   absolute value. info = 5 number of calls to fcn with iflag = 1 has\n   reached maxfev. info = 6 ftol is too small. no further reduction in\n   the sum of squares is possible. info = 7 xtol is too small. no further improvement in\n   the approximate solution x is possible. info = 8 gtol is too small. fvec is orthogonal to the\n   columns of the jacobian to machine precision. integer, intent(out) :: Nfev an integer output variable set to the number of\ncalls to fcn with iflag = 1. integer, intent(out) :: Njev an integer output variable set to the number of\ncalls to fcn with iflag = 2. integer, intent(out) :: Ipvt (n) an integer output array of length n. ipvt\ndefines a permutation matrix p such that jac p = q r,\nwhere jac is the final calculated jacobian, q is\northogonal (not stored), and r is upper triangular.\ncolumn j of p is column ipvt(j) of the identity matrix. real(kind=wp), intent(out) :: Qtf (n) an output array of length n which contains\nthe first n elements of the vector (q transpose)*fvec. real(kind=wp), intent(inout) :: Wa1 (n) work array of length n. real(kind=wp), intent(inout) :: Wa2 (n) work array of length n. real(kind=wp), intent(inout) :: Wa3 (n) work array of length n. real(kind=wp), intent(inout) :: Wa4 (m) work array of length m. public subroutine lmstr1 (fcn, m, n, x, Fvec, Fjac, Ldfjac, Tol, Info, Ipvt, Wa, Lwa) the purpose of lmstr1 is to minimize the sum of the squares of\nm nonlinear functions in n variables by a modification of\nthe levenberg-marquardt algorithm which uses minimal storage.\nthis is done by using the more general least-squares solver\nlmstr. the user must provide a subroutine which calculates\nthe functions and the rows of the jacobian. Arguments Type Intent Optional Attributes Name procedure( fcn_lmstr ) :: fcn user-supplied subroutine which\ncalculates the functions and the rows of the jacobian. integer, intent(in) :: m a positive integer input variable set to the number\nof functions. integer, intent(in) :: n a positive integer input variable set to the number\nof variables. n must not exceed m. real(kind=wp), intent(inout) :: x (n) an array of length n. on input x must contain\nan initial estimate of the solution vector. on output x\ncontains the final estimate of the solution vector. real(kind=wp), intent(out) :: Fvec (m) an output array of length m which contains\nthe functions evaluated at the output x. real(kind=wp), intent(out) :: Fjac (Ldfjac,n) an output n by n array. the upper triangle of fjac\n contains an upper triangular matrix r such that t     t           t\n       p *(jac *jac)*p = r *r, where p is a permutation matrix and jac is the final\n calculated jacobian. column j of p is column ipvt(j)\n (see below) of the identity matrix. the lower triangular\n part of fjac contains information generated during\n the computation of r. integer, intent(in) :: Ldfjac a positive integer input variable not less than n\nwhich specifies the leading dimension of the array fjac. real(kind=wp), intent(in) :: Tol a nonnegative input variable. termination occurs\nwhen the algorithm estimates either that the relative\nerror in the sum of squares is at most tol or that\nthe relative error between x and the solution is at\nmost tol. integer, intent(out) :: Info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag. see description of fcn. otherwise,\ninfo is set as follows: info = 0 improper input parameters. info = 1 algorithm estimates that the relative error\n          in the sum of squares is at most tol. info = 2 algorithm estimates that the relative error\n          between x and the solution is at most tol. info = 3 conditions for info = 1 and info = 2 both hold. info = 4 fvec is orthogonal to the columns of the\n          jacobian to machine precision. info = 5 number of calls to fcn with iflag = 1 has\n          reached 100*(n+1). info = 6 tol is too small. no further reduction in\n          the sum of squares is possible. info = 7 tol is too small. no further improvement in\n          the approximate solution x is possible. integer, intent(out) :: Ipvt (n) an integer output array of length n. ipvt\ndefines a permutation matrix p such that jac p = q r,\nwhere jac is the final calculated jacobian, q is\northogonal (not stored), and r is upper triangular.\ncolumn j of p is column ipvt(j) of the identity matrix. real(kind=wp), intent(inout) :: Wa (Lwa) a work array of length lwa. integer, intent(in) :: Lwa a positive integer input variable not less than 5*n+m. public subroutine qform (m, n, q, Ldq, Wa) this subroutine proceeds from the computed qr factorization of\nan m by n matrix a to accumulate the m by m orthogonal matrix\nq from its factored form. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a and the order of q. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a. real(kind=wp), intent(inout) :: q (Ldq,m) an m by m array. on input the full lower trapezoid in\nthe first min(m,n) columns of q contains the factored form.\non output q has been accumulated into a square matrix. integer, intent(in) :: Ldq a positive integer input variable not less than m\nwhich specifies the leading dimension of the array q. real(kind=wp), intent(inout) :: Wa (m) a work array of length m. public subroutine qrfac (m, n, a, Lda, Pivot, Ipvt, Lipvt, Rdiag, Acnorm, Wa) this subroutine uses householder transformations with column\n  pivoting (optional) to compute a qr factorization of the\n  m by n matrix a. that is, qrfac determines an orthogonal\n  matrix q, a permutation matrix p, and an upper trapezoidal\n  matrix r with diagonal elements of nonincreasing magnitude,\n  such that a p = q r. the householder transformation for\n  column k, k = 1,2,...,min(m,n), is of the form Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a. real(kind=wp), intent(inout) :: a (Lda,n) an m by n array. on input a contains the matrix for\nwhich the qr factorization is to be computed. on output\nthe strict upper trapezoidal part of a contains the strict\nupper trapezoidal part of r, and the lower trapezoidal\npart of a contains a factored form of q (the non-trivial\nelements of the u vectors described above). integer, intent(in) :: Lda a positive integer input variable not less than m\nwhich specifies the leading dimension of the array a. logical, intent(in) :: Pivot a logical input variable. if pivot is set true,\nthen column pivoting is enforced. if pivot is set false,\nthen no column pivoting is done. integer, intent(out) :: Ipvt (Lipvt) an integer output array of length lipvt. ipvt\ndefines the permutation matrix p such that a p = q r.\ncolumn j of p is column ipvt(j) of the identity matrix.\nif pivot is false, ipvt is not referenced. integer, intent(in) :: Lipvt a positive integer input variable. if pivot is false,\nthen lipvt may be as small as 1. if pivot is true, then\nlipvt must be at least n. real(kind=wp), intent(out) :: Rdiag (n) an output array of length n which contains the\ndiagonal elements of r. real(kind=wp), intent(out) :: Acnorm (n) an output array of length n which contains the\nnorms of the corresponding columns of the input matrix a.\nif this information is not needed, then acnorm can coincide\nwith rdiag. real(kind=wp), intent(inout) :: Wa (n) a work array of length n. if pivot is false, then wa\ncan coincide with rdiag. public subroutine qrsolv (n, r, Ldr, Ipvt, Diag, Qtb, x, Sdiag, Wa) given an m by n matrix a, an n by n diagonal matrix d,\n  and an m-vector b, the problem is to determine an x which\n  solves the system Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the order of r. real(kind=wp), intent(inout) :: r (Ldr,n) an n by n array. on input the full upper triangle\nmust contain the full upper triangle of the matrix r.\non output the full upper triangle is unaltered, and the\nstrict lower triangle contains the strict upper triangle\n(transposed) of the upper triangular matrix s. integer, intent(in) :: Ldr a positive integer input variable not less than n\nwhich specifies the leading dimension of the array r. integer, intent(in) :: Ipvt (n) an integer input array of length n which defines the\npermutation matrix p such that a p = q r. column j of p\nis column ipvt(j) of the identity matrix. real(kind=wp), intent(in) :: Diag (n) an input array of length n which must contain the\ndiagonal elements of the matrix d. real(kind=wp), intent(in) :: Qtb (n) an input array of length n which must contain the first\nn elements of the vector (q transpose)*b. real(kind=wp), intent(out) :: x (n) an output array of length n which contains the least\nsquares solution of the system a x = b, d x = 0. real(kind=wp), intent(out) :: Sdiag (n) an output array of length n which contains the\ndiagonal elements of the upper triangular matrix s. real(kind=wp), intent(inout) :: Wa (n) a work array of length n. public subroutine r1mpyq (m, n, a, Lda, v, w) given an m by n matrix a, this subroutine computes a q where\n  q is the product of 2 (n - 1) transformations Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of a. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of a. real(kind=wp), intent(inout) :: a (Lda,n) an m by n array. on input a must contain the matrix\nto be postmultiplied by the orthogonal matrix q\ndescribed above. on output a*q has replaced a. integer, intent(in) :: Lda a positive integer input variable not less than m\nwhich specifies the leading dimension of the array a. real(kind=wp), intent(in) :: v (n) an input array of length n. v(i) must contain the\ninformation necessary to recover the givens rotation gv(i)\ndescribed above. real(kind=wp), intent(in) :: w (n) an input array of length n. w(i) must contain the\ninformation necessary to recover the givens rotation gw(i)\ndescribed above. public subroutine r1updt (m, n, s, Ls, u, v, w, Sing) given an m by n lower trapezoidal matrix s, an m-vector u,\n  and an n-vector v, the problem is to determine an\n  orthogonal matrix q such that Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m a positive integer input variable set to the number\nof rows of s. integer, intent(in) :: n a positive integer input variable set to the number\nof columns of s. n must not exceed m. real(kind=wp), intent(inout) :: s (Ls) an array of length ls. on input s must contain the lower\ntrapezoidal matrix s stored by columns. on output s contains\nthe lower trapezoidal matrix produced as described above. integer, intent(in) :: Ls a positive integer input variable not less than\n(n (2 m-n+1))/2. real(kind=wp), intent(in) :: u (m) an input array of length m which must contain the\nvector u. real(kind=wp), intent(inout) :: v (n) an array of length n. on input v must contain the vector\nv. on output v(i) contains the information necessary to\nrecover the givens rotation gv(i) described above. real(kind=wp), intent(out) :: w (m) an output array of length m. w(i) contains information\nnecessary to recover the givens rotation gw(i) described\nabove. logical, intent(out) :: Sing a logical output variable. sing is set true if any\nof the diagonal elements of the output s are zero. otherwise\nsing is set false. public subroutine rwupdt (n, r, Ldr, w, b, Alpha, Cos, Sin) given an n by n upper triangular matrix r, this subroutine\n  computes the qr decomposition of the matrix formed when a row\n  is added to r. if the row is specified by the vector w, then\n  rwupdt determines an orthogonal matrix q such that when the\n  n+1 by n matrix composed of r augmented by w is premultiplied\n  by (q transpose), the resulting matrix is upper trapezoidal.\n  the matrix (q transpose) is the product of n transformations Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n a positive integer input variable set to the order of r. real(kind=wp), intent(inout) :: r (Ldr,n) an n by n array. on input the upper triangular part of\nr must contain the matrix to be updated. on output r\ncontains the updated triangular matrix. integer, intent(in) :: Ldr a positive integer input variable not less than n\nwhich specifies the leading dimension of the array r. real(kind=wp), intent(in) :: w (n) an input array of length n which must contain the row\nvector to be added to r. real(kind=wp), intent(inout) :: b (n) an array of length n. on input b must contain the\nfirst n elements of the vector c. on output b contains\nthe first n elements of the vector (q transpose)*c. real(kind=wp), intent(inout) :: Alpha a variable. on input alpha must contain the\n(n+1)-st element of the vector c. on output alpha contains\nthe (n+1)-st element of the vector (q transpose)*c. real(kind=wp), intent(out) :: Cos (n) an output array of length n which contains the\ncosines of the transforming givens rotations. real(kind=wp), intent(out) :: Sin (n) an output array of length n which contains the\nsines of the transforming givens rotations.","tags":"","loc":"module/minpack_module.html"},{"title":"minpack_capi – minpack","text":"Uses iso_c_binding minpack_module module~~minpack_capi~~UsesGraph module~minpack_capi minpack_capi module~minpack_module minpack_module module~minpack_capi->module~minpack_module iso_c_binding iso_c_binding module~minpack_capi->iso_c_binding iso_fortran_env iso_fortran_env module~minpack_module->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Abstract Interfaces minpack_func minpack_func2 minpack_fcn_hybrj minpack_fcn_lmder minpack_fcn_lmstr Functions minpack_dpmpar Subroutines minpack_hybrd minpack_hybrd1 minpack_hybrj minpack_hybrj1 minpack_lmdif minpack_lmdif1 minpack_lmder minpack_lmder1 minpack_lmstr minpack_lmstr1 minpack_chkder Abstract Interfaces abstract interface public subroutine minpack_func(n, x, fvec, iflag, udata) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n real(kind=c_double), intent(in) :: x (n) real(kind=c_double), intent(out) :: fvec (n) integer(kind=c_int), intent(inout) :: iflag type(c_ptr), value :: udata abstract interface public subroutine minpack_func2(m, n, x, fvec, iflag, udata) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(in) :: x (n) real(kind=c_double), intent(out) :: fvec (m) integer(kind=c_int), intent(inout) :: iflag type(c_ptr), value :: udata abstract interface public subroutine minpack_fcn_hybrj(n, x, fvec, fjac, ldfjac, iflag, udata) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n real(kind=c_double), intent(in) :: x (n) real(kind=c_double), intent(out) :: fvec (n) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac integer(kind=c_int), intent(inout) :: iflag type(c_ptr), value :: udata abstract interface public subroutine minpack_fcn_lmder(m, n, x, fvec, fjac, ldfjac, iflag, udata) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(in) :: x (n) real(kind=c_double), intent(inout) :: fvec (m) real(kind=c_double), intent(inout) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac integer(kind=c_int), intent(inout) :: iflag type(c_ptr), value :: udata abstract interface public subroutine minpack_fcn_lmstr(m, n, x, fvec, fjrow, iflag, udata) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(in) :: x (n) real(kind=c_double), intent(inout) :: fvec (m) real(kind=c_double), intent(inout) :: fjrow (n) integer(kind=c_int), intent(inout) :: iflag type(c_ptr), value :: udata Functions public function minpack_dpmpar (i) result(par) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: i Return Value real(kind=c_double) Subroutines public subroutine minpack_hybrd (fcn, n, x, fvec, xtol, maxfev, ml, mu, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, r, lr, qtf, wa1, wa2, wa3, wa4, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_func ) :: fcn integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (n) real(kind=c_double), value :: xtol integer(kind=c_int), value :: maxfev integer(kind=c_int), value :: ml integer(kind=c_int), value :: mu real(kind=c_double), value :: epsfcn real(kind=c_double), intent(inout) :: diag (n) integer(kind=c_int), value :: mode real(kind=c_double), value :: factor integer(kind=c_int), value :: nprint integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: nfev real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), intent(out) :: r (lr) integer(kind=c_int), value :: lr real(kind=c_double), intent(out) :: qtf (n) real(kind=c_double), intent(inout) :: wa1 (n) real(kind=c_double), intent(inout) :: wa2 (n) real(kind=c_double), intent(inout) :: wa3 (n) real(kind=c_double), intent(inout) :: wa4 (n) type(c_ptr), value :: udata public subroutine minpack_hybrd1 (fcn, n, x, fvec, tol, info, Wa, Lwa, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_func ) :: fcn integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (n) real(kind=c_double), value :: tol integer(kind=c_int), intent(out) :: info real(kind=c_double), intent(inout) :: Wa (Lwa) integer(kind=c_int), value :: Lwa type(c_ptr), value :: udata public subroutine minpack_hybrj (fcn, n, x, fvec, fjac, ldfjac, xtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, r, lr, qtf, wa1, wa2, wa3, wa4, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_fcn_hybrj ) :: fcn integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (n) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), value :: xtol integer(kind=c_int), value :: maxfev real(kind=c_double), intent(inout) :: diag (n) integer(kind=c_int), value :: mode real(kind=c_double), value :: factor integer(kind=c_int), value :: nprint integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: nfev integer(kind=c_int), intent(out) :: njev real(kind=c_double), intent(out) :: r (lr) integer(kind=c_int), value :: lr real(kind=c_double), intent(out) :: qtf (n) real(kind=c_double), intent(inout) :: wa1 (n) real(kind=c_double), intent(inout) :: wa2 (n) real(kind=c_double), intent(inout) :: wa3 (n) real(kind=c_double), intent(inout) :: wa4 (n) type(c_ptr), value :: udata public subroutine minpack_hybrj1 (fcn, n, x, fvec, fjac, ldfjac, tol, info, wa, lwa, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_fcn_hybrj ) :: fcn integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (n) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), value :: tol integer(kind=c_int), intent(out) :: info real(kind=c_double), intent(inout) :: wa (lwa) integer(kind=c_int), value :: lwa type(c_ptr), value :: udata public subroutine minpack_lmdif (fcn, m, n, x, fvec, ftol, xtol, gtol, maxfev, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, ipvt, qtf, wa1, wa2, wa3, wa4, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_func2 ) :: fcn integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (m) real(kind=c_double), value :: ftol real(kind=c_double), value :: xtol real(kind=c_double), value :: gtol integer(kind=c_int), value :: maxfev real(kind=c_double), value :: epsfcn real(kind=c_double), intent(inout) :: diag (n) integer(kind=c_int), value :: mode real(kind=c_double), value :: factor integer(kind=c_int), value :: nprint integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: nfev real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac integer(kind=c_int), intent(out) :: ipvt (n) real(kind=c_double), intent(out) :: qtf (n) real(kind=c_double), intent(inout) :: wa1 (n) real(kind=c_double), intent(inout) :: wa2 (n) real(kind=c_double), intent(inout) :: wa3 (n) real(kind=c_double), intent(inout) :: wa4 (m) type(c_ptr), value :: udata public subroutine minpack_lmdif1 (fcn, m, n, x, fvec, tol, info, iwa, wa, lwa, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_func2 ) :: fcn integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(inout) :: fvec (m) real(kind=c_double), value :: tol integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(inout) :: iwa (n) real(kind=c_double), intent(inout) :: wa (lwa) integer(kind=c_int), value :: lwa type(c_ptr), value :: udata public subroutine minpack_lmder (fcn, m, n, x, fvec, fjac, ldfjac, ftol, xtol, gtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, ipvt, qtf, wa1, wa2, wa3, wa4, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_fcn_lmder ) :: fcn integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (m) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), value :: ftol real(kind=c_double), value :: xtol real(kind=c_double), value :: gtol integer(kind=c_int), value :: maxfev real(kind=c_double), intent(inout) :: diag (n) integer(kind=c_int), value :: mode real(kind=c_double), value :: factor integer(kind=c_int), value :: nprint integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: nfev integer(kind=c_int), intent(out) :: njev integer(kind=c_int), intent(out) :: ipvt (n) real(kind=c_double), intent(out) :: qtf (n) real(kind=c_double), intent(inout) :: wa1 (n) real(kind=c_double), intent(inout) :: wa2 (n) real(kind=c_double), intent(inout) :: wa3 (n) real(kind=c_double), intent(inout) :: wa4 (m) type(c_ptr), value :: udata public subroutine minpack_lmder1 (fcn, m, n, x, fvec, fjac, ldfjac, tol, info, ipvt, wa, lwa, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_fcn_lmder ) :: fcn integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (m) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), value :: tol integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: ipvt (n) real(kind=c_double), intent(inout) :: wa (lwa) integer(kind=c_int), value :: lwa type(c_ptr), value :: udata private subroutine minpack_lmstr (fcn, m, n, x, fvec, fjac, ldfjac, ftol, xtol, gtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, ipvt, qtf, wa1, wa2, wa3, wa4, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_fcn_lmstr ) :: fcn integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (m) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), value :: ftol real(kind=c_double), value :: xtol real(kind=c_double), value :: gtol integer(kind=c_int), value :: maxfev real(kind=c_double), intent(inout) :: diag (n) integer(kind=c_int), value :: mode real(kind=c_double), value :: factor integer(kind=c_int), value :: nprint integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: nfev integer(kind=c_int), intent(out) :: njev integer(kind=c_int), intent(out) :: ipvt (n) real(kind=c_double), intent(out) :: qtf (n) real(kind=c_double), intent(inout) :: wa1 (n) real(kind=c_double), intent(inout) :: wa2 (n) real(kind=c_double), intent(inout) :: wa3 (n) real(kind=c_double), intent(inout) :: wa4 (m) type(c_ptr), value :: udata private subroutine minpack_lmstr1 (fcn, m, n, x, fvec, fjac, ldfjac, tol, info, ipvt, wa, lwa, udata) bind(c) Arguments Type Intent Optional Attributes Name procedure( minpack_fcn_lmstr ) :: fcn integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(inout) :: x (n) real(kind=c_double), intent(out) :: fvec (m) real(kind=c_double), intent(out) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), value :: tol integer(kind=c_int), intent(out) :: info integer(kind=c_int), intent(out) :: ipvt (n) real(kind=c_double), intent(inout) :: wa (lwa) integer(kind=c_int), value :: lwa type(c_ptr), value :: udata public subroutine minpack_chkder (m, n, x, fvec, fjac, ldfjac, xp, fvecp, mode, err) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: m integer(kind=c_int), value :: n real(kind=c_double), intent(in) :: x (n) real(kind=c_double), intent(in) :: fvec (m) real(kind=c_double), intent(in) :: fjac (ldfjac,n) integer(kind=c_int), value :: ldfjac real(kind=c_double), intent(out) :: xp (n) real(kind=c_double), intent(in) :: fvecp (m) integer(kind=c_int), value :: mode real(kind=c_double), intent(out) :: err (m)","tags":"","loc":"module/minpack_capi.html"}]}