<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   <meta name="description" content="Modernized Minpack">
    <meta name="author" content="Jacob Williams" >
    <link rel="icon" href="../favicon.png">

    <title>minpack_module &ndash; minpack</title>

    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
    <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script src="../js/jquery-2.1.3.min.js"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>

  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">minpack </a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown hidden-xs visible-sm visible-md hidden-lg">
              <a href="#" class="dropdown-toggle"
              data-toggle="dropdown" role="button"
              aria-haspopup="true"
     aria-expanded="false">Contents <span class="caret"></span></a>
        <ul class="dropdown-menu">
            <li><a href="../lists/files.html">Source Files</a></li>
            <li><a href="../lists/modules.html">Modules</a></li>
            <li><a href="../lists/procedures.html">Procedures</a></li>
            <li><a href="../lists/absint.html">Abstract Interfaces</a></li>
              
            </ul>
        
            </li>
<li class="visible-xs hidden-sm visible-lg"><a href="../lists/files.html">Source Files</a></li>
<li class="visible-xs hidden-sm visible-lg"><a href="../lists/modules.html">Modules</a></li>
<li class="visible-xs hidden-sm visible-lg"><a href="../lists/procedures.html">Procedures</a></li>
<li class="visible-xs hidden-sm visible-lg"><a href="../lists/absint.html">Abstract Interfaces</a></li>
                                       </ul>
        <form action="../search.html" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
        </div>
<!--
        <button type="submit" class="btn btn-default">Submit</button>
-->
        </form>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
  <div class="row">
    <h1>minpack_module 
    <small>Module</small>
    </h1>
    <div class="row">
  <div class="col-lg-12">
<div class="well well-sm">
  <ul class="list-inline" style="margin-bottom:0px;display:inline">
     <li><i class="fa fa-list-ol"></i>
       <a data-toggle="tooltip"
    data-placement="bottom" data-html="true"
    title="83.0% of total for modules and submodules.">1909 statements</a>
     </li> 
    <li><i class="fa fa-code"></i><a href="../src/minpack.f90"> Source File</a></li>
  </ul>
  <ol class="breadcrumb in-well text-right">
     <li><a href='../sourcefile/minpack.f90.html'>minpack.f90</a></li>
     <li class="active">minpack_module</li>
  </ol>
</div>
</div>
</div>
<script>
  $(function () {
  $('[data-toggle="tooltip"]').tooltip()
  })
</script>

  </div>
  
  <div class="row">
    <div class="col-md-3 hidden-xs hidden-sm visible-md visible-lg">
    <div id="sidebar">
  <h3>Contents</h3>
 
<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#vars-0">Variables</a></h3></div>
  <div id="vars-0" class="panel-collapse collapse">
    <div class="list-group">
      <a class="list-group-item" href="../module/minpack_module.html#variable-dpmpar">dpmpar</a>
      <a class="list-group-item" href="../module/minpack_module.html#variable-epsmch">epsmch</a>
      <a class="list-group-item" href="../module/minpack_module.html#variable-one">one</a>
      <a class="list-group-item" href="../module/minpack_module.html#variable-zero">zero</a>
    </div>
  </div>
</div>
<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#absints-0">Abstract Interfaces</a></h3></div>
  <div id="absints-0" class="panel-collapse collapse">
    <div class="list-group">
      <a class="list-group-item" href="../module/minpack_module.html#interface-func">func</a>
      <a class="list-group-item" href="../module/minpack_module.html#interface-func2">func2</a>
      <a class="list-group-item" href="../module/minpack_module.html#interface-fcn_hybrj">fcn_hybrj</a>
      <a class="list-group-item" href="../module/minpack_module.html#interface-fcn_lmder">fcn_lmder</a>
      <a class="list-group-item" href="../module/minpack_module.html#interface-fcn_lmstr">fcn_lmstr</a>
    </div>
  </div>
</div>
<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#funcs-0">Functions</a></h3></div>
  <div id="funcs-0" class="panel-collapse collapse">
    <div class="list-group">
      <a class="list-group-item" href="../module/minpack_module.html#proc-enorm">enorm</a>
    </div>
  </div>
</div>
<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#subs-0">Subroutines</a></h3></div>
  <div class="list-group">
    <div id="subs-0" class="panel-collapse collapse">
      <a class="list-group-item" href="../module/minpack_module.html#proc-chkder">chkder</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-dogleg">dogleg</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-fdjac1">fdjac1</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-fdjac2">fdjac2</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-hybrd">hybrd</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-hybrd1">hybrd1</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-hybrj">hybrj</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-hybrj1">hybrj1</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmder">lmder</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmder1">lmder1</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmdif">lmdif</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmdif1">lmdif1</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmpar">lmpar</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmstr">lmstr</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmstr1">lmstr1</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-qform">qform</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-qrfac">qrfac</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-qrsolv">qrsolv</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-r1mpyq">r1mpyq</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-r1updt">r1updt</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-rwupdt">rwupdt</a>
    </div>
  </div>
</div>

</div>

    </div>
    
    <div class="col-md-9" id='text'>
    <p>Modernized Minpack</p>
<h3>Authors</h3>
<ul>
<li>argonne national laboratory. minpack project. march 1980.
    burton s. garbow, kenneth e. hillstrom, jorge j. more.</li>
<li>Jacob Williams, Sept 2021, updated to modern standards.</li>
</ul>
<br>        <div class="panel panel-default">
      <div class="panel-heading">
  <h3 class="panel-title">Uses</h3>
      </div>
      <ul class="list-group">
      <li class="list-group-item">
  <ul class="list-inline">
    <li><a href="https://gcc.gnu.org/onlinedocs/gfortran/ISO_005fFORTRAN_005fENV.html">iso_fortran_env</a></li>
  </ul>
      </li>
      <li class="list-group-item">
  <div class="depgraph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.50.0 (20220117.2223)
 -->
<!-- Title: module~~minpack_module~~UsesGraph Pages: 1 -->
<svg id="moduleminpack_moduleUsesGraph" width="242pt" height="32pt"
 viewBox="0.00 0.00 242.00 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="module~~minpack_module~~UsesGraph" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>module~~minpack_module~~UsesGraph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 238,-28 238,4 -4,4"/>
<!-- module~minpack_module -->
<g id="module~~minpack_module~~UsesGraph_node1" class="node">
<title>module~minpack_module</title>
<polygon fill="none" stroke="black" points="234,-24 130,-24 130,0 234,0 234,-24"/>
<text text-anchor="middle" x="182" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">minpack_module</text>
</g>
<!-- iso_fortran_env -->
<g id="module~~minpack_module~~UsesGraph_node2" class="node">
<title>iso_fortran_env</title>
<g id="a_module~~minpack_module~~UsesGraph_node2"><a xlink:href="https://gcc.gnu.org/onlinedocs/gfortran/ISO_005fFORTRAN_005fENV.html" xlink:title="iso_fortran_env">
<polygon fill="#337ab7" stroke="#337ab7" points="94,-24 0,-24 0,0 94,0 94,-24"/>
<text text-anchor="middle" x="47" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">iso_fortran_env</text>
</a>
</g>
</g>
<!-- module~minpack_module&#45;&gt;iso_fortran_env -->
<g id="module~~minpack_module~~UsesGraph_edge1" class="edge">
<title>module~minpack_module&#45;&gt;iso_fortran_env</title>
<path fill="none" stroke="#000000" stroke-dasharray="5,2" d="M129.96,-12C121.63,-12 112.95,-12 104.5,-12"/>
<polygon fill="#000000" stroke="#000000" points="104.33,-8.5 94.33,-12 104.33,-15.5 104.33,-8.5"/>
</g>
</g>
</svg>
</div><div><a type="button" class="graph-help" data-toggle="modal" href="#graph-help-text">Help</a></div><div class="modal fade" id="graph-help-text" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title" id="-graph-help-label">Graph Key</h4></div><div class="modal-body">
    <p>Nodes of different colours represent the following: </p>
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.50.0 (20220117.2223)
 -->
<!-- Title: Graph Key Pages: 1 -->
<svg width="518pt" height="32pt"
 viewBox="0.00 0.00 517.50 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>Graph Key</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 513.5,-28 513.5,4 -4,4"/>
<!-- Module -->
<g id="node1" class="node">
<title>Module</title>
<polygon fill="#337ab7" stroke="#337ab7" points="54,-24 0,-24 0,0 54,0 54,-24"/>
<text text-anchor="middle" x="27" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Module</text>
</g>
<!-- Submodule -->
<g id="node2" class="node">
<title>Submodule</title>
<polygon fill="#5bc0de" stroke="#5bc0de" points="145.5,-24 72.5,-24 72.5,0 145.5,0 145.5,-24"/>
<text text-anchor="middle" x="109" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Submodule</text>
</g>
<!-- Subroutine -->
<g id="node3" class="node">
<title>Subroutine</title>
<polygon fill="#d9534f" stroke="#d9534f" points="234,-24 164,-24 164,0 234,0 234,-24"/>
<text text-anchor="middle" x="199" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Subroutine</text>
</g>
<!-- Function -->
<g id="node4" class="node">
<title>Function</title>
<polygon fill="#d94e8f" stroke="#d94e8f" points="310,-24 252,-24 252,0 310,0 310,-24"/>
<text text-anchor="middle" x="281" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Function</text>
</g>
<!-- Program -->
<g id="node5" class="node">
<title>Program</title>
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="386,-24 328,-24 328,0 386,0 386,-24"/>
<text text-anchor="middle" x="357" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Program</text>
</g>
<!-- This Page&#39;s Entity -->
<g id="node6" class="node">
<title>This Page&#39;s Entity</title>
<polygon fill="none" stroke="black" points="509.5,-24 404.5,-24 404.5,0 509.5,0 509.5,-24"/>
<text text-anchor="middle" x="457" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">This Page&#39;s Entity</text>
</g>
</g>
</svg>

    
    <p>Solid arrows point from a submodule to the (sub)module which it is
    descended from. Dashed arrows point from a module or program unit to 
    modules which it uses.
    </p>
    </div></div></div></div>
      </li>
      </ul>
    </div>

        <div class="panel panel-default">
      <div class="panel-heading">
  <h3 class="panel-title">Used by</h3>
      </div>
      <ul class="list-group">
  <li class="list-group-item">
    <div class="depgraph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.50.0 (20220117.2223)
 -->
<!-- Title: module~~minpack_module~~UsedByGraph Pages: 1 -->
<svg id="moduleminpack_moduleUsedByGraph" width="234pt" height="32pt"
 viewBox="0.00 0.00 234.00 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="module~~minpack_module~~UsedByGraph" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>module~~minpack_module~~UsedByGraph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 230,-28 230,4 -4,4"/>
<!-- module~minpack_module -->
<g id="module~~minpack_module~~UsedByGraph_node1" class="node">
<title>module~minpack_module</title>
<polygon fill="none" stroke="black" points="104,-24 0,-24 0,0 104,0 104,-24"/>
<text text-anchor="middle" x="52" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">minpack_module</text>
</g>
<!-- module~minpack_capi -->
<g id="module~~minpack_module~~UsedByGraph_node2" class="node">
<title>module~minpack_capi</title>
<g id="a_module~~minpack_module~~UsedByGraph_node2"><a xlink:href=".././module/minpack_capi.html" xlink:title="minpack_capi">
<polygon fill="#337ab7" stroke="#337ab7" points="226,-24 140,-24 140,0 226,0 226,-24"/>
<text text-anchor="middle" x="183" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">minpack_capi</text>
</a>
</g>
</g>
<!-- module~minpack_capi&#45;&gt;module~minpack_module -->
<g id="module~~minpack_module~~UsedByGraph_edge1" class="edge">
<title>module~minpack_capi&#45;&gt;module~minpack_module</title>
<path fill="none" stroke="#000000" stroke-dasharray="5,2" d="M139.76,-12C131.63,-12 122.96,-12 114.36,-12"/>
<polygon fill="#000000" stroke="#000000" points="114.34,-8.5 104.34,-12 114.34,-15.5 114.34,-8.5"/>
</g>
</g>
</svg>
</div><div><a type="button" class="graph-help" data-toggle="modal" href="#graph-help-text">Help</a></div><div class="modal fade" id="graph-help-text" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title" id="-graph-help-label">Graph Key</h4></div><div class="modal-body">
    <p>Nodes of different colours represent the following: </p>
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.50.0 (20220117.2223)
 -->
<!-- Title: Graph Key Pages: 1 -->
<svg width="518pt" height="32pt"
 viewBox="0.00 0.00 517.50 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>Graph Key</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 513.5,-28 513.5,4 -4,4"/>
<!-- Module -->
<g id="node1" class="node">
<title>Module</title>
<polygon fill="#337ab7" stroke="#337ab7" points="54,-24 0,-24 0,0 54,0 54,-24"/>
<text text-anchor="middle" x="27" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Module</text>
</g>
<!-- Submodule -->
<g id="node2" class="node">
<title>Submodule</title>
<polygon fill="#5bc0de" stroke="#5bc0de" points="145.5,-24 72.5,-24 72.5,0 145.5,0 145.5,-24"/>
<text text-anchor="middle" x="109" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Submodule</text>
</g>
<!-- Subroutine -->
<g id="node3" class="node">
<title>Subroutine</title>
<polygon fill="#d9534f" stroke="#d9534f" points="234,-24 164,-24 164,0 234,0 234,-24"/>
<text text-anchor="middle" x="199" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Subroutine</text>
</g>
<!-- Function -->
<g id="node4" class="node">
<title>Function</title>
<polygon fill="#d94e8f" stroke="#d94e8f" points="310,-24 252,-24 252,0 310,0 310,-24"/>
<text text-anchor="middle" x="281" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Function</text>
</g>
<!-- Program -->
<g id="node5" class="node">
<title>Program</title>
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="386,-24 328,-24 328,0 386,0 386,-24"/>
<text text-anchor="middle" x="357" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Program</text>
</g>
<!-- This Page&#39;s Entity -->
<g id="node6" class="node">
<title>This Page&#39;s Entity</title>
<polygon fill="none" stroke="black" points="509.5,-24 404.5,-24 404.5,0 509.5,0 509.5,-24"/>
<text text-anchor="middle" x="457" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">This Page&#39;s Entity</text>
</g>
</g>
</svg>

    
    <p>Solid arrows point from a submodule to the (sub)module which it is
    descended from. Dashed arrows point from a module or program unit to 
    modules which it uses.
    </p>
    </div></div></div></div>
  </li>
      </ul>
    </div>

    <br>

    <section class="visible-xs visible-sm hidden-md">
      <h3>Contents</h3>
 
<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#vars-1">Variables</a></h3></div>
  <div id="vars-1" class="panel-collapse collapse">
    <div class="list-group">
      <a class="list-group-item" href="../module/minpack_module.html#variable-dpmpar">dpmpar</a>
      <a class="list-group-item" href="../module/minpack_module.html#variable-epsmch">epsmch</a>
      <a class="list-group-item" href="../module/minpack_module.html#variable-one">one</a>
      <a class="list-group-item" href="../module/minpack_module.html#variable-zero">zero</a>
    </div>
  </div>
</div>
<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#absints-1">Abstract Interfaces</a></h3></div>
  <div id="absints-1" class="panel-collapse collapse">
    <div class="list-group">
      <a class="list-group-item" href="../module/minpack_module.html#interface-func">func</a>
      <a class="list-group-item" href="../module/minpack_module.html#interface-func2">func2</a>
      <a class="list-group-item" href="../module/minpack_module.html#interface-fcn_hybrj">fcn_hybrj</a>
      <a class="list-group-item" href="../module/minpack_module.html#interface-fcn_lmder">fcn_lmder</a>
      <a class="list-group-item" href="../module/minpack_module.html#interface-fcn_lmstr">fcn_lmstr</a>
    </div>
  </div>
</div>
<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#funcs-1">Functions</a></h3></div>
  <div id="funcs-1" class="panel-collapse collapse">
    <div class="list-group">
      <a class="list-group-item" href="../module/minpack_module.html#proc-enorm">enorm</a>
    </div>
  </div>
</div>
<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#subs-1">Subroutines</a></h3></div>
  <div class="list-group">
    <div id="subs-1" class="panel-collapse collapse">
      <a class="list-group-item" href="../module/minpack_module.html#proc-chkder">chkder</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-dogleg">dogleg</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-fdjac1">fdjac1</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-fdjac2">fdjac2</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-hybrd">hybrd</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-hybrd1">hybrd1</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-hybrj">hybrj</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-hybrj1">hybrj1</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmder">lmder</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmder1">lmder1</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmdif">lmdif</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmdif1">lmdif1</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmpar">lmpar</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmstr">lmstr</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-lmstr1">lmstr1</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-qform">qform</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-qrfac">qrfac</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-qrsolv">qrsolv</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-r1mpyq">r1mpyq</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-r1updt">r1updt</a>
      <a class="list-group-item" href="../module/minpack_module.html#proc-rwupdt">rwupdt</a>
    </div>
  </div>
</div>

    </section>
    <br class="visible-xs visible-sm hidden-md">


    <section>
    <h2>Variables</h2>
    <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Visibility</th><th>Attributes</th><th></th><th>Name</th><th></th><th>Initial</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" id="variable-dpmpar"></span>real(kind=wp),</td>
<td>public,</td>  <td>parameter, dimension(3)</td><td>::</td>
  <td><strong>dpmpar</strong></td><td> =</td><td>[epsilon(1.0_wp), tiny(1.0_wp), huge(1.0_wp)]</td><td><p>machine constants</p></td>
</tr>
<tr>
  <td><span class="anchor" id="variable-epsmch"></span>real(kind=wp),</td>
<td>private,</td>  <td>parameter</td><td>::</td>
  <td><strong>epsmch</strong></td><td> =</td><td>dpmpar(1)</td><td><p>the machine precision</p></td>
</tr>
<tr>
  <td><span class="anchor" id="variable-one"></span>real(kind=wp),</td>
<td>private,</td>  <td>parameter</td><td>::</td>
  <td><strong>one</strong></td><td> =</td><td>1.0_wp</td><td></td>
</tr>
<tr>
  <td><span class="anchor" id="variable-zero"></span>real(kind=wp),</td>
<td>private,</td>  <td>parameter</td><td>::</td>
  <td><strong>zero</strong></td><td> =</td><td>0.0_wp</td><td></td>
</tr>
</tbody>
</table>

    </section>
    <br>
    
    

    <section>
     <h2>Abstract Interfaces</h2>
     <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="interface-func"></span><h3>abstract interface
  </h3></div>
  <ul class="list-group">
    <li class="list-group-item">
    <h3>public subroutine func(n, x, fvec, iflag)</h3><p>user-supplied subroutine for <a href="../proc/hybrd.html">hybrd</a>, <a href="../proc/hybrd1.html">hybrd1</a>, and <a href="../proc/fdjac1.html">fdjac1</a></p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>the number of variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>independant variable vector</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fvec</strong>(n)</td><td><p>value of function at <code>x</code></p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>iflag</strong></td><td><p>set to &lt;0 to terminate execution</p></td>
</tr>
</tbody>
</table>


    </li>
  </ul>
</div>

     <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="interface-func2"></span><h3>abstract interface
  </h3></div>
  <ul class="list-group">
    <li class="list-group-item">
    <h3>public subroutine func2(m, n, x, fvec, iflag)</h3><p>user-supplied subroutine for <a href="../proc/fdjac2.html">fdjac2</a>, <a href="../proc/lmdif.html">lmdif</a>, and <a href="../proc/lmdif1.html">lmdif1</a></p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>the number of functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>the number of variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>independant variable vector</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fvec</strong>(m)</td><td><p>value of function at <code>x</code></p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>iflag</strong></td><td><p>the value of iflag should not be changed unless
the user wants to terminate execution of lmdif.
in this case set iflag to a negative integer.</p></td>
</tr>
</tbody>
</table>


    </li>
  </ul>
</div>

     <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="interface-fcn_hybrj"></span><h3>abstract interface
  </h3></div>
  <ul class="list-group">
    <li class="list-group-item">
    <h3>public subroutine fcn_hybrj(n, x, fvec, fjac, ldfjac, iflag)</h3><p>user-supplied subroutine for <a href="../proc/hybrj.html">hybrj</a> and <a href="../proc/hybrj1.html">hybrj1</a></p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>the number of variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in),</td>
  <td></td>  <td>dimension(n)</td><td>::</td>
  <td><strong>x</strong></td><td><p>independant variable vector</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out),</td>
  <td></td>  <td>dimension(n)</td><td>::</td>
  <td><strong>fvec</strong></td><td><p>value of function at <code>x</code></p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out),</td>
  <td></td>  <td>dimension(ldfjac, n)</td><td>::</td>
  <td><strong>fjac</strong></td><td><p>jacobian matrix at <code>x</code></p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>ldfjac</strong></td><td><p>leading dimension of the array fjac.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>iflag</strong></td><td><p>if iflag = 1 calculate the functions at x and
return this vector in fvec. do not alter fjac.
if iflag = 2 calculate the jacobian at x and
return this matrix in fjac. do not alter fvec.</p>
<p>the value of iflag should not be changed by fcn unless
the user wants to terminate execution of hybrj.
in this case set iflag to a negative integer.</p></td>
</tr>
</tbody>
</table>


    </li>
  </ul>
</div>

     <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="interface-fcn_lmder"></span><h3>abstract interface
  </h3></div>
  <ul class="list-group">
    <li class="list-group-item">
    <h3>public subroutine fcn_lmder(m, n, x, fvec, fjac, ldfjac, iflag)</h3><p>user-supplied subroutine for <a href="../proc/lmder.html">lmder</a> and <a href="../proc/lmder1.html">lmder1</a></p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>the number of functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>the number of variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>independant variable vector</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fvec</strong>(m)</td><td><p>value of function at <code>x</code></p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fjac</strong>(ldfjac,n)</td><td><p>jacobian matrix at <code>x</code></p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>ldfjac</strong></td><td><p>leading dimension of the array fjac.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>iflag</strong></td><td><p>if iflag = 1 calculate the functions at x and
return this vector in fvec. do not alter fjac.
if iflag = 2 calculate the jacobian at x and
return this matrix in fjac. do not alter fvec.</p>
<p>the value of iflag should not be changed by fcn unless
the user wants to terminate execution of lmder.
in this case set iflag to a negative integer.</p></td>
</tr>
</tbody>
</table>


    </li>
  </ul>
</div>

     <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="interface-fcn_lmstr"></span><h3>abstract interface
  </h3></div>
  <ul class="list-group">
    <li class="list-group-item">
    <h3>public subroutine fcn_lmstr(m, n, x, fvec, fjrow, iflag)</h3>    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>the number of functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>the number of variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>independent variable vector</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fvec</strong>(m)</td><td><p>value of function at <code>x</code></p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fjrow</strong>(n)</td><td><p>jacobian row</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>iflag</strong></td><td><p>if iflag = 1 calculate the functions at x and
return this vector in fvec.
if iflag = i calculate the (i-1)-st row of the
jacobian at x and return this vector in fjrow.</p>
<p>the value of iflag should not be changed by fcn unless
the user wants to terminate execution of lmstr.
in this case set iflag to a negative integer.</p></td>
</tr>
</tbody>
</table>


    </li>
  </ul>
</div>

    </section>
  <br>
    
    
 
    <section>
    <h2>Functions</h2>
      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-enorm"></span><h3>public pure function <a href='../proc/enorm.html'>enorm</a>(n, x)</h3></div>
  <div class="panel-body">
       
<p>given an n-vector x, this function calculates the
euclidean norm of x.</p><a href="../proc/enorm.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an input array of length n.</p></td>
</tr>
</tbody>
</table>

<h4>Return Value <small>real(kind=wp)</small></h4>  

  </div>
  </div>

    </section>
    <br>

    <section>
    <h2>Subroutines</h2>
      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-chkder"></span><h3>public subroutine <a href='../proc/chkder.html'>chkder</a>(m, n, x, Fvec, Fjac, Ldfjac, Xp, Fvecp, Mode, Err)</h3></div>
  <div class="panel-body">
       
<p>this subroutine checks the gradients of m nonlinear functions
in n variables, evaluated at a point x, for consistency with
the functions themselves.</p><a href="../proc/chkder.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>a positive integer input variable set to the number
of functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>input array</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fvec</strong>(m)</td><td><p>an array of length m. on input when mode = 2,
fvec must contain the functions evaluated at x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fjac</strong>(Ldfjac,n)</td><td><p>an m by n array. on input when mode = 2,
the rows of fjac must contain the gradients of
the respective functions evaluated at x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldfjac</strong></td><td><p>a positive integer input parameter not less than m
which specifies the leading dimension of the array fjac.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Xp</strong>(n)</td><td><p>an array of length n. on output when mode = 1,
xp is set to a neighboring point of x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fvecp</strong>(m)</td><td><p>an array of length m. on input when mode = 2,
fvecp must contain the functions evaluated at xp.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Mode</strong></td><td><p>an integer input variable set to 1 on the first call
and 2 on the second. other values of mode are equivalent
to mode = 1.</p>
<p>the user must call chkder twice,
first with mode = 1 and then with mode = 2.</p>
<ul>
<li>
<p>mode = 1. <strong>on input</strong>, x must contain the point of evaluation.
   <strong>on output</strong>, xp is set to a neighboring point.</p>
</li>
<li>
<p>mode = 2. <strong>on input</strong>, fvec must contain the functions and the
   rows of fjac must contain the gradients
   of the respective functions each evaluated
   at x, and fvecp must contain the functions
   evaluated at xp.
   <strong>on output</strong>, err contains measures of correctness of
   the respective gradients.</p>
</li>
</ul></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Err</strong>(m)</td><td><p>an array of length m. on output when mode = 2,
err contains measures of correctness of the respective
gradients. if there is no severe loss of significance,
then if err(i) is 1.0 the i-th gradient is correct,
while if err(i) is 0.0 the i-th gradient is incorrect.
for values of err between 0.0 and 1.0, the categorization
is less certain. in general, a value of err(i) greater
than 0.5 indicates that the i-th gradient is probably
correct, while a value of err(i) less than 0.5 indicates
that the i-th gradient is probably incorrect.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-dogleg"></span><h3>public subroutine <a href='../proc/dogleg.html'>dogleg</a>(n, r, Lr, Diag, Qtb, Delta, x, Wa1, Wa2)</h3></div>
  <div class="panel-body">
       
<p>given an m by n matrix a, an n by n nonsingular diagonal
matrix d, an m-vector b, and a positive number delta, the
problem is to determine the convex combination x of the
gauss-newton and scaled gradient directions that minimizes
(a<em>x - b) in the least squares sense, subject to the
restriction that the euclidean norm of d</em>x be at most delta.</p><a href="../proc/dogleg.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the order of r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>r</strong>(Lr)</td><td><p>an input array of length lr which must contain the upper
triangular matrix r stored by rows.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Lr</strong></td><td><p>a positive integer input variable not less than (n*(n+1))/2.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Diag</strong>(n)</td><td><p>an input array of length n which must contain the
diagonal elements of the matrix d.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Qtb</strong>(n)</td><td><p>an input array of length n which must contain the first
n elements of the vector (q transpose)*b.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Delta</strong></td><td><p>a positive input variable which specifies an upper
bound on the euclidean norm of d*x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an output array of length n which contains the desired
convex combination of the gauss-newton direction and the
scaled gradient direction.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa1</strong>(n)</td><td><p>work arrays of length n</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa2</strong>(n)</td><td><p>work arrays of length n</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-fdjac1"></span><h3>public subroutine <a href='../proc/fdjac1.html'>fdjac1</a>(fcn, n, x, Fvec, Fjac, Ldfjac, Iflag, Ml, Mu, Epsfcn, Wa1, Wa2)</h3></div>
  <div class="panel-body">
       
<p>this subroutine computes a forward-difference approximation
to the n by n jacobian matrix associated with a specified
problem of n functions in n variables. if the jacobian has
a banded form, then function evaluations are saved by only
approximating the nonzero terms.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>procedure(<a href='../interface/func.html'>func</a>)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fcn</strong></td><td><p>the user-supplied subroutine which
calculates the functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of functions and variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an input array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fvec</strong>(n)</td><td><p>an input array of length n which must contain the
functions evaluated at x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fjac</strong>(Ldfjac,n)</td><td><p>an output n by n array which contains the
approximation to the jacobian matrix evaluated at x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldfjac</strong></td><td><p>a positive integer input variable not less than n
which specifies the leading dimension of the array fjac.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Iflag</strong></td><td><p>an integer variable which can be used to terminate
the execution of fdjac1. see description of <a href="../interface/func.html">func</a>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ml</strong></td><td><p>a nonnegative integer input variable which specifies
the number of subdiagonals within the band of the
jacobian matrix. if the jacobian is not banded, set
ml to at least n - 1.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Mu</strong></td><td><p>a nonnegative integer input variable which specifies
the number of superdiagonals within the band of the
jacobian matrix. if the jacobian is not banded, set
mu to at least n - 1.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Epsfcn</strong></td><td><p>an input variable used in determining a suitable
step length for the forward-difference approximation. this
approximation assumes that the relative errors in the
functions are of the order of epsfcn. if epsfcn is less
than the machine precision, it is assumed that the relative
errors in the functions are of the order of the machine
precision.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa1</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa2</strong>(n)</td><td><p>work array of length n. if ml + mu + 1 is at
least n, then the jacobian is considered dense, and wa2 is
not referenced.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-fdjac2"></span><h3>public subroutine <a href='../proc/fdjac2.html'>fdjac2</a>(fcn, m, n, x, Fvec, Fjac, Ldfjac, Iflag, Epsfcn, Wa)</h3></div>
  <div class="panel-body">
       
<p>this subroutine computes a forward-difference approximation
to the m by n jacobian matrix associated with a specified
problem of m functions in n variables.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>procedure(<a href='../interface/func2.html'>func2</a>)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fcn</strong></td><td><p>the user-supplied subroutine which
calculates the functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>a positive integer input variable set to the number
of functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of variables. n must not exceed m.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an input array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fvec</strong>(m)</td><td><p>an input array of length m which must contain the
functions evaluated at x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fjac</strong>(Ldfjac,n)</td><td><p>an output m by n array which contains the
approximation to the jacobian matrix evaluated at x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldfjac</strong></td><td><p>a positive integer input variable not less than m
which specifies the leading dimension of the array fjac.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Iflag</strong></td><td><p>an integer variable which can be used to terminate
the execution of fdjac2. see description of <a href="../interface/func2.html">func2</a>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Epsfcn</strong></td><td><p>an input variable used in determining a suitable
step length for the forward-difference approximation. this
approximation assumes that the relative errors in the
functions are of the order of epsfcn. if epsfcn is less
than the machine precision, it is assumed that the relative
errors in the functions are of the order of the machine
precision.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa</strong>(m)</td><td><p>a work array of length m.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-hybrd"></span><h3>public subroutine <a href='../proc/hybrd.html'>hybrd</a>(fcn, n, x, fvec, xtol, maxfev, ml, mu, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, r, lr, qtf, wa1, wa2, wa3, wa4)</h3></div>
  <div class="panel-body">
       
<p>the purpose of hybrd is to find a zero of a system of
n nonlinear functions in n variables by a modification
of the powell hybrid method. the user must provide a
subroutine which calculates the functions. the jacobian is
then calculated by a forward-difference approximation.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>procedure(<a href='../interface/func.html'>func</a>)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fcn</strong></td><td><p>user-supplied subroutine which calculates the functions</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of functions and variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>array of length n. on input <code>x</code> must contain
an initial estimate of the solution vector. on output <code>x</code>
contains the final estimate of the solution vector.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fvec</strong>(n)</td><td><p>an output array of length <code>n</code> which contains
the functions evaluated at the output <code>x</code>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>xtol</strong></td><td><p>a nonnegative input variable. termination
occurs when the relative error between two consecutive
iterates is at most <code>xtol</code>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>maxfev</strong></td><td><p>a positive integer input variable. termination
occurs when the number of calls to <code>fcn</code> is at least <code>maxfev</code>
by the end of an iteration.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>ml</strong></td><td><p>a nonnegative integer input variable which specifies
the number of subdiagonals within the band of the
jacobian matrix. if the jacobian is not banded, set
<code>ml</code> to at least <code>n - 1</code>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>mu</strong></td><td><p>a nonnegative integer input variable which specifies
the number of superdiagonals within the band of the
jacobian matrix. if the jacobian is not banded, set
<code>mu</code> to at least<code>n - 1</code>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>epsfcn</strong></td><td><p>an input variable used in determining a suitable
step length for the forward-difference approximation. this
approximation assumes that the relative errors in the
functions are of the order of <code>epsfcn</code>. if <code>epsfcn</code> is less
than the machine precision, it is assumed that the relative
errors in the functions are of the order of the machine
precision.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>diag</strong>(n)</td><td><p>an array of length <code>n</code>. if <code>mode = 1</code> (see
below), <code>diag</code> is internally set. if <code>mode = 2</code>, <code>diag</code>
must contain positive entries that serve as
multiplicative scale factors for the variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>mode</strong></td><td><p>if <code>mode = 1</code>, the
variables will be scaled internally. if <code>mode = 2</code>,
the scaling is specified by the input <code>diag</code>. other
values of <code>mode</code> are equivalent to <code>mode = 1</code>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>factor</strong></td><td><p>a positive input variable used in determining the
initial step bound. this bound is set to the product of
<code>factor</code> and the euclidean norm of <code>diag*x</code> if nonzero, or else
to <code>factor</code> itself. in most cases factor should lie in the
interval (.1,100.). 100. is a generally recommended value.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>nprint</strong></td><td><p>an integer input variable that enables controlled
printing of iterates if it is positive. in this case,
<code>fcn</code> is called with <code>iflag = 0</code> at the beginning of the first
iteration and every <code>nprint</code> iterations thereafter and
immediately prior to return, with <code>x</code> and <code>fvec</code> available
for printing. if <code>nprint</code> is not positive, no special calls
of <code>fcn</code> with <code>iflag = 0</code> are made.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>info</strong></td><td><p>an integer output variable. if the user has
terminated execution, <code>info</code> is set to the (negative)
value of <code>iflag</code>. see description of <code>fcn</code>. otherwise,
<code>info</code> is set as follows:</p>
<ul>
<li><strong><em>info = 0</em></strong> improper input parameters.</li>
<li><strong><em>info = 1</em></strong> relative error between two consecutive iterates
   is at most <code>xtol</code>.</li>
<li><strong><em>info = 2</em></strong> number of calls to <code>fcn</code> has reached or exceeded
   <code>maxfev</code>.</li>
<li><strong><em>info = 3</em></strong> <code>xtol</code> is too small. no further improvement in
   the approximate solution <code>x</code> is possible.</li>
<li><strong><em>info = 4</em></strong> iteration is not making good progress, as
   measured by the improvement from the last
   five jacobian evaluations.</li>
<li><strong><em>info = 5</em></strong> iteration is not making good progress, as
   measured by the improvement from the last
   ten iterations.</li>
</ul></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>nfev</strong></td><td><p>output variable set to the number of calls to <code>fcn</code>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fjac</strong>(ldfjac,n)</td><td><p>array which contains the
orthogonal matrix <code>q</code> produced by the QR factorization
of the final approximate jacobian.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>ldfjac</strong></td><td><p>a positive integer input variable not less than <code>n</code>
which specifies the leading dimension of the array <code>fjac</code>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>r</strong>(lr)</td><td><p>an output array which contains the
upper triangular matrix produced by the QR factorization
of the final approximate jacobian, stored rowwise.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>lr</strong></td><td><p>a positive integer input variable not less than <code>(n*(n+1))/2</code>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>qtf</strong>(n)</td><td><p>an output array of length <code>n</code> which contains
the vector <code>(q transpose)*fvec</code>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>wa1</strong>(n)</td><td><p>work array</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>wa2</strong>(n)</td><td><p>work array</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>wa3</strong>(n)</td><td><p>work array</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>wa4</strong>(n)</td><td><p>work array</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-hybrd1"></span><h3>public subroutine <a href='../proc/hybrd1.html'>hybrd1</a>(fcn, n, x, fvec, tol, info, Wa, Lwa)</h3></div>
  <div class="panel-body">
       
<p>the purpose of hybrd1 is to find a zero of a system of
n nonlinear functions in n variables by a modification
of the powell hybrid method. this is done by using the
more general nonlinear equation solver hybrd. the user
must provide a subroutine which calculates the functions.
the jacobian is then calculated by a forward-difference
approximation.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>procedure(<a href='../interface/func.html'>func</a>)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fcn</strong></td><td><p>user-supplied subroutine which calculates the functions</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of functions and variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout),</td>
  <td></td>  <td>dimension(n)</td><td>::</td>
  <td><strong>x</strong></td><td><p>an array of length <code>n</code>. on input <code>x</code> must contain
an initial estimate of the solution vector. on output <code>x</code>
contains the final estimate of the solution vector.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out),</td>
  <td></td>  <td>dimension(n)</td><td>::</td>
  <td><strong>fvec</strong></td><td><p>an output array of length <code>n</code> which contains
the functions evaluated at the output <code>x</code>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>tol</strong></td><td><p>a nonnegative input variable. termination occurs
when the algorithm estimates that the relative error
between <code>x</code> and the solution is at most <code>tol</code>.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>info</strong></td><td><p>an integer output variable. if the user has
terminated execution, info is set to the (negative)
value of <code>iflag</code>. see description of <code>fcn</code>. otherwise,
<code>info</code> is set as follows:</p>
<ul>
<li><strong><em>info = 0</em></strong> improper input parameters.</li>
<li><strong><em>info = 1</em></strong> algorithm estimates that the relative error
 between <code>x</code> and the solution is at most <code>tol</code>.</li>
<li><strong><em>info = 2</em></strong> number of calls to <code>fcn</code> has reached or exceeded
 <code>200*(n+1)</code>.</li>
<li><strong><em>info = 3</em></strong> <code>tol</code> is too small. no further improvement in
 the approximate solution <code>x</code> is possible.</li>
<li><strong><em>info = 4</em></strong> iteration is not making good progress.</li>
</ul></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa</strong>(Lwa)</td><td><p>a work array of length lwa.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Lwa</strong></td><td><p>a positive integer input variable not less than
(n<em>(3</em>n+13))/2.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-hybrj"></span><h3>public subroutine <a href='../proc/hybrj.html'>hybrj</a>(fcn, n, x, Fvec, Fjac, Ldfjac, Xtol, Maxfev, Diag, Mode, Factor, Nprint, Info, Nfev, Njev, r, Lr, Qtf, Wa1, Wa2, Wa3, Wa4)</h3></div>
  <div class="panel-body">
       
<p>the purpose of hybrj is to find a zero of a system of
n nonlinear functions in n variables by a modification
of the powell hybrid method. the user must provide a
subroutine which calculates the functions and the jacobian.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>procedure(<a href='../interface/fcn_hybrj.html'>fcn_hybrj</a>)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fcn</strong></td><td><p>the user-supplied subroutine which
calculates the functions and the jacobian</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of functions and variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an array of length n. on input x must contain
an initial estimate of the solution vector. on output x
contains the final estimate of the solution vector.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fvec</strong>(n)</td><td><p>an output array of length n which contains
the functions evaluated at the output x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fjac</strong>(Ldfjac,n)</td><td><p>an output n by n array which contains the
orthogonal matrix q produced by the qr factorization
of the final approximate jacobian.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldfjac</strong></td><td><p>a positive integer input variable not less than n
which specifies the leading dimension of the array fjac.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Xtol</strong></td><td><p>a nonnegative input variable. termination
occurs when the relative error between two consecutive
iterates is at most xtol.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Maxfev</strong></td><td><p>a positive integer input variable. termination
occurs when the number of calls to fcn with iflag = 1
has reached maxfev.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Diag</strong>(n)</td><td><p>an array of length n. if mode = 1 (see
below), diag is internally set. if mode = 2, diag
must contain positive entries that serve as
multiplicative scale factors for the variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Mode</strong></td><td><p>an integer input variable. if mode = 1, the
variables will be scaled internally. if mode = 2,
the scaling is specified by the input diag. other
values of mode are equivalent to mode = 1.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Factor</strong></td><td><p>a positive input variable used in determining the
initial step bound. this bound is set to the product of
factor and the euclidean norm of diag*x if nonzero, or else
to factor itself. in most cases factor should lie in the
interval (.1,100.). 100. is a generally recommended value.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Nprint</strong></td><td><p>an integer input variable that enables controlled
printing of iterates if it is positive. in this case,
fcn is called with iflag = 0 at the beginning of the first
iteration and every nprint iterations thereafter and
immediately prior to return, with x and fvec available
for printing. fvec and fjac should not be altered.
if nprint is not positive, no special calls of fcn
with iflag = 0 are made.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Info</strong></td><td><p>an integer output variable. if the user has
terminated execution, info is set to the (negative)
value of iflag. see description of fcn. otherwise,
info is set as follows:</p>
<ul>
<li><strong><em>info = 0</em></strong>   improper input parameters.</li>
<li><strong><em>info = 1</em></strong>   relative error between two consecutive iterates
   is at most xtol.</li>
<li><strong><em>info = 2</em></strong>   number of calls to fcn with iflag = 1 has
   reached maxfev.</li>
<li><strong><em>info = 3</em></strong>   xtol is too small. no further improvement in
   the approximate solution x is possible.</li>
<li><strong><em>info = 4</em></strong>   iteration is not making good progress, as
   measured by the improvement from the last
   five jacobian evaluations.</li>
<li><strong><em>info = 5</em></strong>   iteration is not making good progress, as
   measured by the improvement from the last
   ten iterations.</li>
</ul></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Nfev</strong></td><td><p>an integer output variable set to the number of
calls to fcn with iflag = 1.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Njev</strong></td><td><p>an integer output variable set to the number of
calls to fcn with iflag = 2.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>r</strong>(Lr)</td><td><p>an output array of length lr which contains the
upper triangular matrix produced by the qr factorization
of the final approximate jacobian, stored rowwise.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Lr</strong></td><td><p>a positive integer input variable not less than
(n*(n+1))/2.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Qtf</strong>(n)</td><td><p>an output array of length n which contains
the vector (q transpose)*fvec.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa1</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa2</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa3</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa4</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-hybrj1"></span><h3>public subroutine <a href='../proc/hybrj1.html'>hybrj1</a>(fcn, n, x, Fvec, Fjac, Ldfjac, Tol, Info, Wa, Lwa)</h3></div>
  <div class="panel-body">
       
<p>the purpose of hybrj1 is to find a zero of a system of
n nonlinear functions in n variables by a modification
of the powell hybrid method. this is done by using the
more general nonlinear equation solver hybrj. the user
must provide a subroutine which calculates the functions
and the jacobian.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>procedure(<a href='../interface/fcn_hybrj.html'>fcn_hybrj</a>)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fcn</strong></td><td><p>the user-supplied subroutine which
calculates the functions and the jacobian</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of functions and variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an array of length n. on input x must contain
an initial estimate of the solution vector. on output x
contains the final estimate of the solution vector.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fvec</strong>(n)</td><td><p>an output array of length n which contains
the functions evaluated at the output x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fjac</strong>(Ldfjac,n)</td><td><p>an output n by n array which contains the
orthogonal matrix q produced by the qr factorization
of the final approximate jacobian.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldfjac</strong></td><td><p>a positive integer input variable not less than n
which specifies the leading dimension of the array fjac.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Tol</strong></td><td><p>a nonnegative input variable. termination occurs
when the algorithm estimates that the relative error
between x and the solution is at most tol.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Info</strong></td><td><p>an integer output variable. if the user has
terminated execution, info is set to the (negative)
value of iflag. see description of fcn. otherwise,
info is set as follows:</p>
<ul>
<li><strong><em>info = 0</em></strong>   improper input parameters.</li>
<li><strong><em>info = 1</em></strong>   algorithm estimates that the relative error
   between x and the solution is at most tol.</li>
<li><strong><em>info = 2</em></strong>   number of calls to fcn with iflag = 1 has
   reached 100*(n+1).</li>
<li><strong><em>info = 3</em></strong>   tol is too small. no further improvement in
   the approximate solution x is possible.</li>
<li><strong><em>info = 4</em></strong>   iteration is not making good progress.</li>
</ul></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa</strong>(Lwa)</td><td><p>a work array of length lwa.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Lwa</strong></td><td><p>a positive integer input variable not less than
(n*(n+13))/2.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-lmder"></span><h3>public subroutine <a href='../proc/lmder.html'>lmder</a>(fcn, m, n, x, Fvec, Fjac, Ldfjac, Ftol, Xtol, Gtol, Maxfev, Diag, Mode, Factor, Nprint, Info, Nfev, Njev, Ipvt, Qtf, Wa1, Wa2, Wa3, Wa4)</h3></div>
  <div class="panel-body">
       
<p>the purpose of lmder is to minimize the sum of the squares of
m nonlinear functions in n variables by a modification of
the levenberg-marquardt algorithm. the user must provide a
subroutine which calculates the functions and the jacobian.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>procedure(<a href='../interface/fcn_lmder.html'>fcn_lmder</a>)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fcn</strong></td><td><p>the user-supplied subroutine which
calculates the functions and the jacobian</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>a positive integer input variable set to the number
of functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of variables. n must not exceed m.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an array of length n. on input x must contain
an initial estimate of the solution vector. on output x
contains the final estimate of the solution vector.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fvec</strong>(m)</td><td><p>an output array of length m which contains
the functions evaluated at the output x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fjac</strong>(Ldfjac,n)</td><td><p>an output m by n array. the upper n by n submatrix
 of fjac contains an upper triangular matrix r with
 diagonal elements of nonincreasing magnitude such that</p>
<div class="codehilite"><pre><span></span><code>        t     t           t
       p *(jac *jac)*p = r *r,
</code></pre></div>

<p>where p is a permutation matrix and jac is the final
 calculated jacobian. column j of p is column ipvt(j)
 (see below) of the identity matrix. the lower trapezoidal
 part of fjac contains information generated during
 the computation of r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldfjac</strong></td><td><p>a positive integer input variable not less than m
which specifies the leading dimension of the array fjac.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ftol</strong></td><td><p>a nonnegative input variable. termination
occurs when both the actual and predicted relative
reductions in the sum of squares are at most ftol.
therefore, ftol measures the relative error desired
in the sum of squares.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Xtol</strong></td><td><p>a nonnegative input variable. termination
occurs when the relative error between two consecutive
iterates is at most xtol. therefore, xtol measures the
relative error desired in the approximate solution.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Gtol</strong></td><td><p>a nonnegative input variable. termination
occurs when the cosine of the angle between fvec and
any column of the jacobian is at most gtol in absolute
value. therefore, gtol measures the orthogonality
desired between the function vector and the columns
of the jacobian.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Maxfev</strong></td><td><p>a positive integer input variable. termination
occurs when the number of calls to fcn with iflag = 1
has reached maxfev.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Diag</strong>(n)</td><td><p>an array of length n. if mode = 1 (see
below), diag is internally set. if mode = 2, diag
must contain positive entries that serve as
multiplicative scale factors for the variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Mode</strong></td><td><p>an integer input variable. if mode = 1, the
variables will be scaled internally. if mode = 2,
the scaling is specified by the input diag. other
values of mode are equivalent to mode = 1.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Factor</strong></td><td><p>a positive input variable used in determining the
initial step bound. this bound is set to the product of
factor and the euclidean norm of diag*x if nonzero, or else
to factor itself. in most cases factor should lie in the
interval (.1,100.).100. is a generally recommended value.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Nprint</strong></td><td><p>an integer input variable that enables controlled
printing of iterates if it is positive. in this case,
fcn is called with iflag = 0 at the beginning of the first
iteration and every nprint iterations thereafter and
immediately prior to return, with x, fvec, and fjac
available for printing. fvec and fjac should not be
altered. if nprint is not positive, no special calls
of fcn with iflag = 0 are made.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Info</strong></td><td><p>an integer output variable. if the user has
terminated execution, info is set to the (negative)
value of iflag. see description of fcn. otherwise,
info is set as follows:</p>
<ul>
<li><strong><em>info = 0</em></strong>  improper input parameters.</li>
<li><strong><em>info = 1</em></strong>  both actual and predicted relative reductions
   in the sum of squares are at most ftol.</li>
<li><strong><em>info = 2</em></strong>  relative error between two consecutive iterates
   is at most xtol.</li>
<li><strong><em>info = 3</em></strong>  conditions for info = 1 and info = 2 both hold.</li>
<li><strong><em>info = 4</em></strong>  the cosine of the angle between fvec and any
   column of the jacobian is at most gtol in
   absolute value.</li>
<li><strong><em>info = 5</em></strong>  number of calls to fcn with iflag = 1 has
   reached maxfev.</li>
<li><strong><em>info = 6</em></strong>  ftol is too small. no further reduction in
   the sum of squares is possible.</li>
<li><strong><em>info = 7</em></strong>  xtol is too small. no further improvement in
   the approximate solution x is possible.</li>
<li><strong><em>info = 8</em></strong>  gtol is too small. fvec is orthogonal to the
   columns of the jacobian to machine precision.</li>
</ul></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Nfev</strong></td><td><p>an integer output variable set to the number of
calls to fcn with iflag = 1.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Njev</strong></td><td><p>an integer output variable set to the number of
calls to fcn with iflag = 2.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ipvt</strong>(n)</td><td><p>an integer output array of length n. ipvt
defines a permutation matrix p such that jac<em>p = q</em>r,
where jac is the final calculated jacobian, q is
orthogonal (not stored), and r is upper triangular
with diagonal elements of nonincreasing magnitude.
column j of p is column ipvt(j) of the identity matrix.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Qtf</strong>(n)</td><td><p>an output array of length n which contains
the first n elements of the vector (q transpose)*fvec.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa1</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa2</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa3</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa4</strong>(m)</td><td><p>work array of length n.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-lmder1"></span><h3>public subroutine <a href='../proc/lmder1.html'>lmder1</a>(fcn, m, n, x, Fvec, Fjac, Ldfjac, Tol, Info, Ipvt, Wa, Lwa)</h3></div>
  <div class="panel-body">
       
<p>the purpose of lmder1 is to minimize the sum of the squares of
m nonlinear functions in n variables by a modification of the
levenberg-marquardt algorithm. this is done by using the more
general least-squares solver lmder. the user must provide a
subroutine which calculates the functions and the jacobian.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>procedure(<a href='../interface/fcn_lmder.html'>fcn_lmder</a>)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fcn</strong></td><td><p>user-supplied subroutine which
calculates the functions and the jacobian.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>a positive integer input variable set to the number
of functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of variables. n must not exceed m.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an array of length n. on input x must contain
an initial estimate of the solution vector. on output x
contains the final estimate of the solution vector.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fvec</strong>(m)</td><td><p>an output array of length m which contains
the functions evaluated at the output x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fjac</strong>(Ldfjac,n)</td><td><p>an output m by n array. the upper n by n submatrix
 of fjac contains an upper triangular matrix r with
 diagonal elements of nonincreasing magnitude such that</p>
<div class="codehilite"><pre><span></span><code>        t     t           t
       p *(jac *jac)*p = r *r,
</code></pre></div>

<p>where p is a permutation matrix and jac is the final
 calculated jacobian. column j of p is column ipvt(j)
 (see below) of the identity matrix. the lower trapezoidal
 part of fjac contains information generated during
 the computation of r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldfjac</strong></td><td><p>a positive integer input variable not less than m
which specifies the leading dimension of the array fjac.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Tol</strong></td><td><p>a nonnegative input variable. termination occurs
when the algorithm estimates either that the relative
error in the sum of squares is at most tol or that
the relative error between x and the solution is at
most tol.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Info</strong></td><td><p>an integer output variable. if the user has
terminated execution, info is set to the (negative)
value of iflag. see description of fcn. otherwise,
info is set as follows.</p>
<ul>
<li><strong><em>info = 0</em></strong>  improper input parameters.</li>
<li><strong><em>info = 1</em></strong>  algorithm estimates that the relative error
   in the sum of squares is at most tol.</li>
<li><strong><em>info = 2</em></strong>  algorithm estimates that the relative error
   between x and the solution is at most tol.</li>
<li><strong><em>info = 3</em></strong>  conditions for info = 1 and info = 2 both hold.</li>
<li><strong><em>info = 4</em></strong>  fvec is orthogonal to the columns of the
   jacobian to machine precision.</li>
<li><strong><em>info = 5</em></strong>  number of calls to fcn with iflag = 1 has
   reached 100*(n+1).</li>
<li><strong><em>info = 6</em></strong>  tol is too small. no further reduction in
   the sum of squares is possible.</li>
<li><strong><em>info = 7</em></strong>  tol is too small. no further improvement in
   the approximate solution x is possible.</li>
</ul></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ipvt</strong>(n)</td><td><p>an integer output array of length n. ipvt
defines a permutation matrix p such that jac<em>p = q</em>r,
where jac is the final calculated jacobian, q is
orthogonal (not stored), and r is upper triangular
with diagonal elements of nonincreasing magnitude.
column j of p is column ipvt(j) of the identity matrix.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa</strong>(Lwa)</td><td><p>a work array of length lwa.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Lwa</strong></td><td><p>a positive integer input variable not less than 5*n+m.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-lmdif"></span><h3>public subroutine <a href='../proc/lmdif.html'>lmdif</a>(fcn, m, n, x, Fvec, Ftol, Xtol, Gtol, Maxfev, Epsfcn, Diag, Mode, Factor, Nprint, Info, Nfev, Fjac, Ldfjac, Ipvt, Qtf, Wa1, Wa2, Wa3, Wa4)</h3></div>
  <div class="panel-body">
       
<p>the purpose of lmdif is to minimize the sum of the squares of
m nonlinear functions in n variables by a modification of
the levenberg-marquardt algorithm. the user must provide a
subroutine which calculates the functions. the jacobian is
then calculated by a forward-difference approximation.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>procedure(<a href='../interface/func2.html'>func2</a>)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fcn</strong></td><td><p>the user-supplied subroutine which
calculates the functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>a positive integer input variable set to the number
of functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of variables. n must not exceed m.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an array of length n. on input x must contain
an initial estimate of the solution vector. on output x
contains the final estimate of the solution vector.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fvec</strong>(m)</td><td><p>an output array of length m which contains
the functions evaluated at the output x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ftol</strong></td><td><p>a nonnegative input variable. termination
occurs when both the actual and predicted relative
reductions in the sum of squares are at most ftol.
therefore, ftol measures the relative error desired
in the sum of squares.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Xtol</strong></td><td><p>a nonnegative input variable. termination
occurs when the relative error between two consecutive
iterates is at most xtol. therefore, xtol measures the
relative error desired in the approximate solution.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Gtol</strong></td><td><p>a nonnegative input variable. termination
occurs when the cosine of the angle between fvec and
any column of the jacobian is at most gtol in absolute
value. therefore, gtol measures the orthogonality
desired between the function vector and the columns
of the jacobian.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Maxfev</strong></td><td><p>a positive integer input variable. termination
occurs when the number of calls to fcn is at least
maxfev by the end of an iteration.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Epsfcn</strong></td><td><p>an input variable used in determining a suitable
step length for the forward-difference approximation. this
approximation assumes that the relative errors in the
functions are of the order of epsfcn. if epsfcn is less
than the machine precision, it is assumed that the relative
errors in the functions are of the order of the machine
precision.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Diag</strong>(n)</td><td><p>an array of length n. if mode = 1 (see
below), diag is internally set. if mode = 2, diag
must contain positive entries that serve as
multiplicative scale factors for the variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Mode</strong></td><td><p>an integer input variable. if mode = 1, the
variables will be scaled internally. if mode = 2,
the scaling is specified by the input diag. other
values of mode are equivalent to mode = 1.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Factor</strong></td><td><p>a positive input variable used in determining the
initial step bound. this bound is set to the product of
factor and the euclidean norm of diag*x if nonzero, or else
to factor itself. in most cases factor should lie in the
interval (.1,100.). 100. is a generally recommended value.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Nprint</strong></td><td><p>an integer input variable that enables controlled
printing of iterates if it is positive. in this case,
fcn is called with iflag = 0 at the beginning of the first
iteration and every nprint iterations thereafter and
immediately prior to return, with x and fvec available
for printing. if nprint is not positive, no special calls
of fcn with iflag = 0 are made.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Info</strong></td><td><p>an integer output variable. if the user has
terminated execution, info is set to the (negative)
value of iflag. see description of fcn. otherwise,
info is set as follows:</p>
<ul>
<li><strong><em>info = 0</em></strong>  improper input parameters.</li>
<li><strong><em>info = 1</em></strong>  both actual and predicted relative reductions
   in the sum of squares are at most ftol.</li>
<li><strong><em>info = 2</em></strong>  relative error between two consecutive iterates
   is at most xtol.</li>
<li><strong><em>info = 3</em></strong>  conditions for info = 1 and info = 2 both hold.</li>
<li><strong><em>info = 4</em></strong>  the cosine of the angle between fvec and any
   column of the jacobian is at most gtol in
   absolute value.</li>
<li><strong><em>info = 5</em></strong>  number of calls to fcn has reached or
   exceeded maxfev.</li>
<li><strong><em>info = 6</em></strong>  ftol is too small. no further reduction in
   the sum of squares is possible.</li>
<li><strong><em>info = 7</em></strong>  xtol is too small. no further improvement in
   the approximate solution x is possible.</li>
<li><strong><em>info = 8</em></strong>  gtol is too small. fvec is orthogonal to the
   columns of the jacobian to machine precision.</li>
</ul></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Nfev</strong></td><td><p>an integer output variable set to the number of
calls to fcn.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fjac</strong>(Ldfjac,n)</td><td><p>an output m by n array. the upper n by n submatrix
 of fjac contains an upper triangular matrix r with
 diagonal elements of nonincreasing magnitude such that</p>
<div class="codehilite"><pre><span></span><code>        t     t           t
       p *(jac *jac)*p = r *r,
</code></pre></div>

<p>where p is a permutation matrix and jac is the final
 calculated jacobian. column j of p is column ipvt(j)
 (see below) of the identity matrix. the lower trapezoidal
 part of fjac contains information generated during
 the computation of r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldfjac</strong></td><td><p>a positive integer input variable not less than m
which specifies the leading dimension of the array fjac.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ipvt</strong>(n)</td><td><p>an integer output array of length n. ipvt
defines a permutation matrix p such that jac<em>p = q</em>r,
where jac is the final calculated jacobian, q is
orthogonal (not stored), and r is upper triangular
with diagonal elements of nonincreasing magnitude.
column j of p is column ipvt(j) of the identity matrix.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Qtf</strong>(n)</td><td><p>an output array of length n which contains
the first n elements of the vector (q transpose)*fvec.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa1</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa2</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa3</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa4</strong>(m)</td><td><p>work array of length n.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-lmdif1"></span><h3>public subroutine <a href='../proc/lmdif1.html'>lmdif1</a>(fcn, m, n, x, Fvec, Tol, Info, Iwa, Wa, Lwa)</h3></div>
  <div class="panel-body">
       
<p>the purpose of lmdif1 is to minimize the sum of the squares of
m nonlinear functions in n variables by a modification of the
levenberg-marquardt algorithm. this is done by using the more
general least-squares solver lmdif. the user must provide a
subroutine which calculates the functions. the jacobian is
then calculated by a forward-difference approximation.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>procedure(<a href='../interface/func2.html'>func2</a>)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fcn</strong></td><td><p>the user-supplied subroutine which
calculates the functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>a positive integer input variable set to the number
of functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of variables. n must not exceed m.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an array of length n. on input x must contain
an initial estimate of the solution vector. on output x
contains the final estimate of the solution vector.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fvec</strong>(m)</td><td><p>an output array of length m which contains
the functions evaluated at the output x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Tol</strong></td><td><p>a nonnegative input variable. termination occurs
when the algorithm estimates either that the relative
error in the sum of squares is at most tol or that
the relative error between x and the solution is at
most tol.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Info</strong></td><td><p>an integer output variable. if the user has
terminated execution, info is set to the (negative)
value of iflag. see description of fcn. otherwise,
info is set as follows:</p>
<ul>
<li><strong><em>info = 0</em></strong>  improper input parameters.</li>
<li><strong><em>info = 1</em></strong>  algorithm estimates that the relative error
   in the sum of squares is at most tol.</li>
<li><strong><em>info = 2</em></strong>  algorithm estimates that the relative error
   between x and the solution is at most tol.</li>
<li><strong><em>info = 3</em></strong>  conditions for info = 1 and info = 2 both hold.</li>
<li><strong><em>info = 4</em></strong>  fvec is orthogonal to the columns of the
   jacobian to machine precision.</li>
<li><strong><em>info = 5</em></strong>  number of calls to fcn has reached or
   exceeded 200*(n+1).</li>
<li><strong><em>info = 6</em></strong>  tol is too small. no further reduction in
   the sum of squares is possible.</li>
<li><strong><em>info = 7</em></strong>  tol is too small. no further improvement in
   the approximate solution x is possible.</li>
</ul></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Iwa</strong>(n)</td><td><p>an integer work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa</strong>(Lwa)</td><td><p>a work array of length lwa.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Lwa</strong></td><td><p>a positive integer input variable not less than
m<em>n+5</em>n+m.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-lmpar"></span><h3>public subroutine <a href='../proc/lmpar.html'>lmpar</a>(n, r, Ldr, Ipvt, Diag, Qtb, Delta, Par, x, Sdiag, Wa1, Wa2)</h3></div>
  <div class="panel-body">
       
<p>given an m by n matrix a, an n by n nonsingular diagonal
  matrix d, an m-vector b, and a positive number delta,
  the problem is to determine a value for the parameter
  par such that if x solves the system</p><a href="../proc/lmpar.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the order of r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>r</strong>(Ldr,n)</td><td><p>an n by n array. on input the full upper triangle
must contain the full upper triangle of the matrix r.
on output the full upper triangle is unaltered, and the
strict lower triangle contains the strict upper triangle
(transposed) of the upper triangular matrix s.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldr</strong></td><td><p>a positive integer input variable not less than n
which specifies the leading dimension of the array r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ipvt</strong>(n)</td><td><p>an integer input array of length n which defines the
permutation matrix p such that a<em>p = q</em>r. column j of p
is column ipvt(j) of the identity matrix.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Diag</strong>(n)</td><td><p>an input array of length n which must contain the
diagonal elements of the matrix d.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Qtb</strong>(n)</td><td><p>an input array of length n which must contain the first
n elements of the vector (q transpose)*b.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Delta</strong></td><td><p>a positive input variable which specifies an upper
bound on the euclidean norm of d*x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Par</strong></td><td><p>a nonnegative variable. on input par contains an
initial estimate of the levenberg-marquardt parameter.
on output par contains the final estimate.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an output array of length n which contains the least
squares solution of the system a<em>x = b, sqrt(par)</em>d*x = 0,
for the output par.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Sdiag</strong>(n)</td><td><p>an output array of length n which contains the
diagonal elements of the upper triangular matrix s.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa1</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa2</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-lmstr"></span><h3>public subroutine <a href='../proc/lmstr.html'>lmstr</a>(fcn, m, n, x, Fvec, Fjac, Ldfjac, Ftol, Xtol, Gtol, Maxfev, Diag, Mode, Factor, Nprint, Info, Nfev, Njev, Ipvt, Qtf, Wa1, Wa2, Wa3, Wa4)</h3></div>
  <div class="panel-body">
       
<p>the purpose of lmstr is to minimize the sum of the squares of
m nonlinear functions in n variables by a modification of
the levenberg-marquardt algorithm which uses minimal storage.
the user must provide a subroutine which calculates the
functions and the rows of the jacobian.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>procedure(<a href='../interface/fcn_lmstr.html'>fcn_lmstr</a>)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fcn</strong></td><td><p>user-supplied subroutine which
calculates the functions and the rows of the jacobian.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>a positive integer input variable set to the number
of functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of variables. n must not exceed m.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an array of length n. on input x must contain
an initial estimate of the solution vector. on output x
contains the final estimate of the solution vector.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fvec</strong>(m)</td><td><p>an output array of length m which contains
the functions evaluated at the output x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fjac</strong>(Ldfjac,n)</td><td><p>an output n by n array. the upper triangle of fjac
 contains an upper triangular matrix r such that</p>
<div class="codehilite"><pre><span></span><code>        t     t           t
       p *(jac *jac)*p = r *r,
</code></pre></div>

<p>where p is a permutation matrix and jac is the final
 calculated jacobian. column j of p is column ipvt(j)
 (see below) of the identity matrix. the lower triangular
 part of fjac contains information generated during
 the computation of r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldfjac</strong></td><td><p>a positive integer input variable not less than n
which specifies the leading dimension of the array fjac.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ftol</strong></td><td><p>a nonnegative input variable. termination
occurs when both the actual and predicted relative
reductions in the sum of squares are at most ftol.
therefore, ftol measures the relative error desired
in the sum of squares.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Xtol</strong></td><td><p>a nonnegative input variable. termination
occurs when the relative error between two consecutive
iterates is at most xtol. therefore, xtol measures the
relative error desired in the approximate solution.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Gtol</strong></td><td><p>a nonnegative input variable. termination
occurs when the cosine of the angle between fvec and
any column of the jacobian is at most gtol in absolute
value. therefore, gtol measures the orthogonality
desired between the function vector and the columns
of the jacobian.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Maxfev</strong></td><td><p>a positive integer input variable. termination
occurs when the number of calls to fcn with iflag = 1
has reached maxfev.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Diag</strong>(n)</td><td><p>an array of length n. if mode = 1 (see
below), diag is internally set. if mode = 2, diag
must contain positive entries that serve as
multiplicative scale factors for the variables.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Mode</strong></td><td><p>an integer input variable. if mode = 1, the
variables will be scaled internally. if mode = 2,
the scaling is specified by the input diag. other
values of mode are equivalent to mode = 1.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Factor</strong></td><td><p>a positive input variable used in determining the
initial step bound. this bound is set to the product of
factor and the euclidean norm of diag*x if nonzero, or else
to factor itself. in most cases factor should lie in the
interval (.1,100.). 100. is a generally recommended value.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Nprint</strong></td><td><p>an integer input variable that enables controlled
printing of iterates if it is positive. in this case,
fcn is called with iflag = 0 at the beginning of the first
iteration and every nprint iterations thereafter and
immediately prior to return, with x and fvec available
for printing. if nprint is not positive, no special calls
of fcn with iflag = 0 are made.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Info</strong></td><td><p>an integer output variable. if the user has
terminated execution, info is set to the (negative)
value of iflag. see description of fcn. otherwise,
info is set as follows:</p>
<ul>
<li><strong><em>info = 0</em></strong>  improper input parameters.</li>
<li><strong><em>info = 1</em></strong>  both actual and predicted relative reductions
   in the sum of squares are at most ftol.</li>
<li><strong><em>info = 2</em></strong>  relative error between two consecutive iterates
   is at most xtol.</li>
<li><strong><em>info = 3</em></strong>  conditions for info = 1 and info = 2 both hold.</li>
<li><strong><em>info = 4</em></strong>  the cosine of the angle between fvec and any
   column of the jacobian is at most gtol in
   absolute value.</li>
<li><strong><em>info = 5</em></strong>  number of calls to fcn with iflag = 1 has
   reached maxfev.</li>
<li><strong><em>info = 6</em></strong>  ftol is too small. no further reduction in
   the sum of squares is possible.</li>
<li><strong><em>info = 7</em></strong>  xtol is too small. no further improvement in
   the approximate solution x is possible.</li>
<li><strong><em>info = 8</em></strong>  gtol is too small. fvec is orthogonal to the
   columns of the jacobian to machine precision.</li>
</ul></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Nfev</strong></td><td><p>an integer output variable set to the number of
calls to fcn with iflag = 1.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Njev</strong></td><td><p>an integer output variable set to the number of
calls to fcn with iflag = 2.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ipvt</strong>(n)</td><td><p>an integer output array of length n. ipvt
defines a permutation matrix p such that jac<em>p = q</em>r,
where jac is the final calculated jacobian, q is
orthogonal (not stored), and r is upper triangular.
column j of p is column ipvt(j) of the identity matrix.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Qtf</strong>(n)</td><td><p>an output array of length n which contains
the first n elements of the vector (q transpose)*fvec.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa1</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa2</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa3</strong>(n)</td><td><p>work array of length n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa4</strong>(m)</td><td><p>work array of length m.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-lmstr1"></span><h3>public subroutine <a href='../proc/lmstr1.html'>lmstr1</a>(fcn, m, n, x, Fvec, Fjac, Ldfjac, Tol, Info, Ipvt, Wa, Lwa)</h3></div>
  <div class="panel-body">
       
<p>the purpose of lmstr1 is to minimize the sum of the squares of
m nonlinear functions in n variables by a modification of
the levenberg-marquardt algorithm which uses minimal storage.
this is done by using the more general least-squares solver
lmstr. the user must provide a subroutine which calculates
the functions and the rows of the jacobian.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>procedure(<a href='../interface/fcn_lmstr.html'>fcn_lmstr</a>)</td>
<td></td>
  <td></td>  <td></td><td>::</td>
  <td><strong>fcn</strong></td><td><p>user-supplied subroutine which
calculates the functions and the rows of the jacobian.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>a positive integer input variable set to the number
of functions.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of variables. n must not exceed m.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an array of length n. on input x must contain
an initial estimate of the solution vector. on output x
contains the final estimate of the solution vector.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fvec</strong>(m)</td><td><p>an output array of length m which contains
the functions evaluated at the output x.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Fjac</strong>(Ldfjac,n)</td><td><p>an output n by n array. the upper triangle of fjac
 contains an upper triangular matrix r such that</p>
<div class="codehilite"><pre><span></span><code>        t     t           t
       p *(jac *jac)*p = r *r,
</code></pre></div>

<p>where p is a permutation matrix and jac is the final
 calculated jacobian. column j of p is column ipvt(j)
 (see below) of the identity matrix. the lower triangular
 part of fjac contains information generated during
 the computation of r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldfjac</strong></td><td><p>a positive integer input variable not less than n
which specifies the leading dimension of the array fjac.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Tol</strong></td><td><p>a nonnegative input variable. termination occurs
when the algorithm estimates either that the relative
error in the sum of squares is at most tol or that
the relative error between x and the solution is at
most tol.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Info</strong></td><td><p>an integer output variable. if the user has
terminated execution, info is set to the (negative)
value of iflag. see description of fcn. otherwise,
info is set as follows:</p>
<ul>
<li><strong><em>info = 0</em></strong>  improper input parameters.</li>
<li><strong><em>info = 1</em></strong>  algorithm estimates that the relative error
          in the sum of squares is at most tol.</li>
<li><strong><em>info = 2</em></strong>  algorithm estimates that the relative error
          between x and the solution is at most tol.</li>
<li><strong><em>info = 3</em></strong>  conditions for info = 1 and info = 2 both hold.</li>
<li><strong><em>info = 4</em></strong>  fvec is orthogonal to the columns of the
          jacobian to machine precision.</li>
<li><strong><em>info = 5</em></strong>  number of calls to fcn with iflag = 1 has
          reached 100*(n+1).</li>
<li><strong><em>info = 6</em></strong>  tol is too small. no further reduction in
          the sum of squares is possible.</li>
<li><strong><em>info = 7</em></strong>  tol is too small. no further improvement in
          the approximate solution x is possible.</li>
</ul></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ipvt</strong>(n)</td><td><p>an integer output array of length n. ipvt
defines a permutation matrix p such that jac<em>p = q</em>r,
where jac is the final calculated jacobian, q is
orthogonal (not stored), and r is upper triangular.
column j of p is column ipvt(j) of the identity matrix.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa</strong>(Lwa)</td><td><p>a work array of length lwa.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Lwa</strong></td><td><p>a positive integer input variable not less than 5*n+m.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-qform"></span><h3>public subroutine <a href='../proc/qform.html'>qform</a>(m, n, q, Ldq, Wa)</h3></div>
  <div class="panel-body">
       
<p>this subroutine proceeds from the computed qr factorization of
an m by n matrix a to accumulate the m by m orthogonal matrix
q from its factored form.</p>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>a positive integer input variable set to the number
of rows of a and the order of q.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of columns of a.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>q</strong>(Ldq,m)</td><td><p>an m by m array. on input the full lower trapezoid in
the first min(m,n) columns of q contains the factored form.
on output q has been accumulated into a square matrix.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldq</strong></td><td><p>a positive integer input variable not less than m
which specifies the leading dimension of the array q.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa</strong>(m)</td><td><p>a work array of length m.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-qrfac"></span><h3>public subroutine <a href='../proc/qrfac.html'>qrfac</a>(m, n, a, Lda, Pivot, Ipvt, Lipvt, Rdiag, Acnorm, Wa)</h3></div>
  <div class="panel-body">
       
<p>this subroutine uses householder transformations with column
  pivoting (optional) to compute a qr factorization of the
  m by n matrix a. that is, qrfac determines an orthogonal
  matrix q, a permutation matrix p, and an upper trapezoidal
  matrix r with diagonal elements of nonincreasing magnitude,
  such that a<em>p = q</em>r. the householder transformation for
  column k, k = 1,2,...,min(m,n), is of the form</p><a href="../proc/qrfac.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>a positive integer input variable set to the number
of rows of a.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of columns of a.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>a</strong>(Lda,n)</td><td><p>an m by n array. on input a contains the matrix for
which the qr factorization is to be computed. on output
the strict upper trapezoidal part of a contains the strict
upper trapezoidal part of r, and the lower trapezoidal
part of a contains a factored form of q (the non-trivial
elements of the u vectors described above).</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Lda</strong></td><td><p>a positive integer input variable not less than m
which specifies the leading dimension of the array a.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>logical,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Pivot</strong></td><td><p>a logical input variable. if pivot is set true,
then column pivoting is enforced. if pivot is set false,
then no column pivoting is done.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ipvt</strong>(Lipvt)</td><td><p>an integer output array of length lipvt. ipvt
defines the permutation matrix p such that a<em>p = q</em>r.
column j of p is column ipvt(j) of the identity matrix.
if pivot is false, ipvt is not referenced.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Lipvt</strong></td><td><p>a positive integer input variable. if pivot is false,
then lipvt may be as small as 1. if pivot is true, then
lipvt must be at least n.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Rdiag</strong>(n)</td><td><p>an output array of length n which contains the
diagonal elements of r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Acnorm</strong>(n)</td><td><p>an output array of length n which contains the
norms of the corresponding columns of the input matrix a.
if this information is not needed, then acnorm can coincide
with rdiag.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa</strong>(n)</td><td><p>a work array of length n. if pivot is false, then wa
can coincide with rdiag.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-qrsolv"></span><h3>public subroutine <a href='../proc/qrsolv.html'>qrsolv</a>(n, r, Ldr, Ipvt, Diag, Qtb, x, Sdiag, Wa)</h3></div>
  <div class="panel-body">
       
<p>given an m by n matrix a, an n by n diagonal matrix d,
  and an m-vector b, the problem is to determine an x which
  solves the system</p><a href="../proc/qrsolv.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the order of r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>r</strong>(Ldr,n)</td><td><p>an n by n array. on input the full upper triangle
must contain the full upper triangle of the matrix r.
on output the full upper triangle is unaltered, and the
strict lower triangle contains the strict upper triangle
(transposed) of the upper triangular matrix s.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldr</strong></td><td><p>a positive integer input variable not less than n
which specifies the leading dimension of the array r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ipvt</strong>(n)</td><td><p>an integer input array of length n which defines the
permutation matrix p such that a<em>p = q</em>r. column j of p
is column ipvt(j) of the identity matrix.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Diag</strong>(n)</td><td><p>an input array of length n which must contain the
diagonal elements of the matrix d.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Qtb</strong>(n)</td><td><p>an input array of length n which must contain the first
n elements of the vector (q transpose)*b.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>an output array of length n which contains the least
squares solution of the system a<em>x = b, d</em>x = 0.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Sdiag</strong>(n)</td><td><p>an output array of length n which contains the
diagonal elements of the upper triangular matrix s.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Wa</strong>(n)</td><td><p>a work array of length n.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-r1mpyq"></span><h3>public subroutine <a href='../proc/r1mpyq.html'>r1mpyq</a>(m, n, a, Lda, v, w)</h3></div>
  <div class="panel-body">
       
<p>given an m by n matrix a, this subroutine computes a<em>q where
  q is the product of 2</em>(n - 1) transformations</p><a href="../proc/r1mpyq.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>a positive integer input variable set to the number
of rows of a.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of columns of a.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>a</strong>(Lda,n)</td><td><p>an m by n array. on input a must contain the matrix
to be postmultiplied by the orthogonal matrix q
described above. on output a*q has replaced a.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Lda</strong></td><td><p>a positive integer input variable not less than m
which specifies the leading dimension of the array a.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>v</strong>(n)</td><td><p>an input array of length n. v(i) must contain the
information necessary to recover the givens rotation gv(i)
described above.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>w</strong>(n)</td><td><p>an input array of length n. w(i) must contain the
information necessary to recover the givens rotation gw(i)
described above.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-r1updt"></span><h3>public subroutine <a href='../proc/r1updt.html'>r1updt</a>(m, n, s, Ls, u, v, w, Sing)</h3></div>
  <div class="panel-body">
       
<p>given an m by n lower trapezoidal matrix s, an m-vector u,
  and an n-vector v, the problem is to determine an
  orthogonal matrix q such that</p><a href="../proc/r1updt.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>a positive integer input variable set to the number
of rows of s.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the number
of columns of s. n must not exceed m.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>s</strong>(Ls)</td><td><p>an array of length ls. on input s must contain the lower
trapezoidal matrix s stored by columns. on output s contains
the lower trapezoidal matrix produced as described above.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ls</strong></td><td><p>a positive integer input variable not less than
(n<em>(2</em>m-n+1))/2.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>u</strong>(m)</td><td><p>an input array of length m which must contain the
vector u.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>v</strong>(n)</td><td><p>an array of length n. on input v must contain the vector
v. on output v(i) contains the information necessary to
recover the givens rotation gv(i) described above.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>w</strong>(m)</td><td><p>an output array of length m. w(i) contains information
necessary to recover the givens rotation gw(i) described
above.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>logical,</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Sing</strong></td><td><p>a logical output variable. sing is set true if any
of the diagonal elements of the output s are zero. otherwise
sing is set false.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

      <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-rwupdt"></span><h3>public subroutine <a href='../proc/rwupdt.html'>rwupdt</a>(n, r, Ldr, w, b, Alpha, Cos, Sin)</h3></div>
  <div class="panel-body">
       
<p>given an n by n upper triangular matrix r, this subroutine
  computes the qr decomposition of the matrix formed when a row
  is added to r. if the row is specified by the vector w, then
  rwupdt determines an orthogonal matrix q such that when the
  n+1 by n matrix composed of r augmented by w is premultiplied
  by (q transpose), the resulting matrix is upper trapezoidal.
  the matrix (q transpose) is the product of n transformations</p><a href="../proc/rwupdt.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
<h4>Arguments</h4>      <table class="table table-striped varlist">
<thead><tr><th>Type</th><th>Intent</th><th>Optional</th><th>Attributes</th><th></th><th>Name</th><th></th></thead>
<tbody>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>a positive integer input variable set to the order of r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>r</strong>(Ldr,n)</td><td><p>an n by n array. on input the upper triangular part of
r must contain the matrix to be updated. on output r
contains the updated triangular matrix.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>integer,</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Ldr</strong></td><td><p>a positive integer input variable not less than n
which specifies the leading dimension of the array r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(in)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>w</strong>(n)</td><td><p>an input array of length n which must contain the row
vector to be added to r.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>b</strong>(n)</td><td><p>an array of length n. on input b must contain the
first n elements of the vector c. on output b contains
the first n elements of the vector (q transpose)*c.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(inout)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Alpha</strong></td><td><p>a variable. on input alpha must contain the
(n+1)-st element of the vector c. on output alpha contains
the (n+1)-st element of the vector (q transpose)*c.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Cos</strong>(n)</td><td><p>an output array of length n which contains the
cosines of the transforming givens rotations.</p></td>
</tr>
<tr>
  <td><span class="anchor" ></span>real(kind=wp),</td>
<td>intent(out)</td>
  <td></td>  <td></td><td>::</td>
  <td><strong>Sin</strong>(n)</td><td><p>an output array of length n which contains the
sines of the transforming givens rotations.</p></td>
</tr>
</tbody>
</table>


  </div>
  </div>

    </section>    
    <br>
    
    </div>
  </div>

    <hr>    
    </div> <!-- /container -->
    <footer>
      <div class="container">
      <div class="row">
        <div class="col-xs-6 col-md-6"><p>minpack was developed by Jacob Williams<br>&copy; 2022 
</p>
        </div>
        <div class="col-xs-6 col-md-6">
          <p class="text-right">
            Documentation generated by 
            <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
          </p>
        </div>
      </div>
      <br>
      </div> <!-- /container -->    
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
<!--
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
-->
    <script src="../js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../js/ie10-viewport-bug-workaround.js"></script>

    <!-- MathJax JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
        jax: ['input/TeX','input/MathML','output/HTML-CSS'],
        extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
      });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script src="../tipuesearch/tipuesearch_content.js"></script>
    <script src="../tipuesearch/tipuesearch_set.js"></script>
    <script src="../tipuesearch/tipuesearch.js"></script>
    
  </body>
</html>